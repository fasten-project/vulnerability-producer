/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package eu.fasten.vulnerabilityproducer;

import com.google.gson.Gson;
import com.mongodb.client.MongoDatabase;
import eu.fasten.vulnerabilityproducer.db.NitriteController;
import eu.fasten.vulnerabilityproducer.utils.connections.JavaHttpClient;
import eu.fasten.vulnerabilityproducer.utils.Vulnerability;
import eu.fasten.vulnerabilityproducer.utils.connections.KafkaConnector;
import eu.fasten.vulnerabilityproducer.utils.parsers.ParserManager;
import eu.fasten.vulnerabilityproducer.utils.stats.Stats;
import org.apache.commons.io.FileUtils;
import org.apache.kafka.clients.producer.KafkaProducer;
import org.apache.kafka.clients.producer.ProducerRecord;
import org.json.JSONArray;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.io.File;
import java.io.IOException;
import java.nio.charset.StandardCharsets;
import java.util.*;

public class VulnerabilityProducer {
    //        Kafka        //
    private List<String> serverAddresses;
    public static final String topic = "fasten.vulnerability.out";
    private KafkaProducer<String, String> kafkaProducer;

    //        Utils        //
    private ParserManager parserManager;
    private ProducerThread pt;
    private MongoDatabase mongoDatabase;
    protected static Queue<Vulnerability> queue = new LinkedList<>();
    private final Logger logger = LoggerFactory.getLogger(VulnerabilityProducer.class.getName());
    private final String pathToNitrite = "./src/main/resources/nitrite/security.db";

    /**
     * Getter necessary to handle stopping of the Updater Thread
     *
     * @return ProducerThread Object that contains an UpdaterThread
     */
    public ProducerThread getProducerThread() {
        return pt;
    }

    /**
     * Setter helps with testing.
     * @param pt
     */
    public void setProducerThread(ProducerThread pt) {
        this.pt = pt;
    }

    public void setKafkaProducer(KafkaProducer<String, String> kafkaProducer) {
        this.kafkaProducer = kafkaProducer;
    }

    public static Queue<Vulnerability> getQueue() {
        return queue;
    }

    public void setServerAddresses(List<String> serverAddresses) {
        this.serverAddresses = serverAddresses;
    }

    public void setMongoDatabase(MongoDatabase mongoDatabase) {
        this.mongoDatabase = mongoDatabase;
    }

    /**
     * Sets the connection to Mongodb instance.
     */
    public void createParserManager() {
        logger.info("Creating the ParserManager");
        JavaHttpClient client = new JavaHttpClient();
        NitriteController nc = new NitriteController(pathToNitrite);
        this.parserManager = new ParserManager(client, this.mongoDatabase, nc);
    }

    /**
     * Method to create a KafkaProducer in order to publish information
     * @return
     */
    public void createKafkaProducer() {
        Properties p = KafkaConnector.kafkaProducerProperties(this.serverAddresses, "vulnerability");
        this.kafkaProducer = new KafkaProducer<>(p);
    }

    /**
     * Helper method to inject the parser in the Plugin.
     * Facilitates testing.
     *
     * @param parser - parser to inject
     */
    public void injectParserManager(ParserManager parser) {
        this.parserManager = parser;
    }

    /**
     * Starting point of the plugin.
     * Sets up the ParserManager and the KafkaProducer.
     * Last, creates and starts the ProducerThread.
     */
    public void start() {
        createParserManager();
        pt = new ProducerThread(queue, parserManager);
        pt.start();

        while (true) {
            this.produce();
        }
    }

    /**
     * Looks into the queue and produces to the topic if it finds something.
     */
    public void produce() {
        while (queue.isEmpty()) {
            // do nothing, waiting for the queue to get some elements
            try {
                // Sleep for 10 seconds since probably there is nothing in the queue
                Thread.sleep(10000);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
        // Poll it and inject in the DB
        Vulnerability v = queue.poll();
        logger.info("Publishing " + v.getId() + " to Kafka");
        ProducerRecord<String, String> record = new ProducerRecord<>(topic, v.toJson());
        kafkaProducer.send(record);
    }

    /**
     * Reads vulnerabilities from a JSON file.
     * Used for the demo
     * @param jsonPath - Path to JSON file
     * @return List of vulnerabilities
     */
    public static List<Vulnerability> getVulnerabilitiesFromJson(String jsonPath) {
        List<Vulnerability> vulns = new ArrayList<>();
        // Read the content from the file
        File file = new File(jsonPath);
        String raw = null;
        try {
            raw = FileUtils.readFileToString(file, StandardCharsets.UTF_8);
        } catch (IOException e) {
            e.printStackTrace();
        }
        if (raw == null) return vulns;
        // Parse the JSON
        JSONArray vulnArray = new JSONArray(raw);
        Gson gson = new Gson();
        for (int i = 0; i < vulnArray.length(); i++) {
            var v = gson.fromJson(vulnArray.getJSONObject(i).toString(), Vulnerability.class);
            vulns.add(v);
        }
        return vulns;
    }
}

class ProducerThread implements Runnable {

    Thread thread;
    Logger logger = LoggerFactory.getLogger(getClass());
    Queue<Vulnerability> queue;
    ParserManager parser;
    UpdaterThread ut;

    public ProducerThread(Queue<Vulnerability> queue, ParserManager parser) {
        this.queue = queue;
        this.parser = parser;
    }

    public UpdaterThread getUpdater() {
        return ut;
    }

    public void start() {
        logger.info("Started ProducerThread");
        thread = new Thread(this);
        thread.start();
    }

    @Override
    public void run() {
        // Get all the vulnerabilities from the Parsers and enqueue them
        logger.info("Gathering information from all parsers");
        HashSet<Vulnerability> vulnerabilities = parser.getVulnerabilitiesFromParsers();
        logger.info("Received a total of " + vulnerabilities.size() + " vulnerabilities from the ParserManager.");
        for (Vulnerability v : vulnerabilities) {
            // Add it to the queue to publish to Kafka
            queue.add(v);
        }

        // Compute stats of the vulnerabilities gathered
        logger.info("Computing statistics and measure quality of vulnerabilities");
//        Stats.saveStats(vulnerabilities, "./src/main/resources/stats/");

        // Start a new Thread that checks
        // for updates every day and writes new vulnerabilities
        logger.info("Starting the Updater Thread");
        ut = new UpdaterThread(queue, parser);
        ut.start();
    }
}

class UpdaterThread implements Runnable {

    Thread thread;
    Queue<Vulnerability> queue;
    ParserManager parser;
    Logger logger = LoggerFactory.getLogger(getClass());
    private volatile boolean exit = false;

    public UpdaterThread(Queue<Vulnerability> queue, ParserManager parser) {
        this.queue = queue;
        this.parser = parser;
    }

    public void start() {
        thread = new Thread(this);
        thread.start();
    }

    public void terminate() {
        exit = true;
    }

    @Override
    public void run() {
        while (!exit) {
            try {
                // Step 1: Sleep for a day
                // Injected into parser logic in order to test
                parser.sleep();

                // Get updates and inject them as well
                HashSet<Vulnerability> updates = parser.getUpdatesFromParsers();
                for (Vulnerability v : updates) {
                    queue.add(v);
                }
            } catch (Exception e) {
                System.out.println("Could not run updater");
            }
        }
    }
}


