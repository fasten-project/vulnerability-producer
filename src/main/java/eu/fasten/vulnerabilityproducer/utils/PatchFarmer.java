/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package eu.fasten.vulnerabilityproducer.utils;

import com.mongodb.client.FindIterable;
import com.mongodb.client.MongoCollection;
import com.mongodb.client.MongoDatabase;
import eu.fasten.vulnerabilityproducer.db.NitriteController;
import eu.fasten.vulnerabilityproducer.db.PatchObject;
import eu.fasten.vulnerabilityproducer.utils.connections.JavaHttpClient;
import eu.fasten.vulnerabilityproducer.utils.connections.MongoConnector;
import eu.fasten.vulnerabilityproducer.utils.parsers.ParserManager;
import org.apache.commons.lang3.StringUtils;
import org.bson.Document;
import org.bson.conversions.Bson;
import org.jooq.tools.json.JSONArray;
import org.jooq.tools.json.JSONObject;
import org.jooq.tools.json.JSONParser;
import org.jsoup.Jsoup;
import org.jsoup.nodes.Element;
import org.jsoup.select.Elements;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.io.FileNotFoundException;
import java.io.PrintWriter;
import java.util.*;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import static com.mongodb.client.model.Filters.and;
import static com.mongodb.client.model.Filters.eq;

/**
 * This class has the responsibility to handle references and crawl for commits.
 * Those will lead to diffs that will lead to changed files.
 * Those files will be considered vulnerable since they needed changes in order
 */
public class PatchFarmer {

    public static JSONParser jsonParser;
    public static MongoCollection<Document> mongoCommitsCollection;
    public static MongoCollection<Document> mongoPullRequestsCollection;
    public static MongoCollection<Document> mongoIssuesCollection;
    public static JavaHttpClient httpClient;
    private final Logger logger = LoggerFactory.getLogger(PatchFarmer.class.getName());

    /**
     * Takes a MongoDatabase object to connect and retrieve collections from.
     */
    public PatchFarmer(MongoDatabase db, JavaHttpClient client) {
        httpClient = client;
        jsonParser = new JSONParser();
        mongoCommitsCollection = db.getCollection("commits");
        mongoPullRequestsCollection = db.getCollection("pull_requests");
        mongoIssuesCollection = db.getCollection("issues");
    }

    /**
     * Extracts information from Pull Request links.
     * First queries GHTorrent and if nothing is found use Github API
     *
     * @param pr            github link to the pull request
     * @return
     */
    public HashSet<Vulnerability.Patch> parsePullRequest(String pr) {
        logger.info("Parsing pull request with URL: " + pr);
        String jsonBody = null;
        HashSet<Vulnerability.Patch> vp = new HashSet<>();
        try {
            // Extract information from the patch and create API Link
            String[] infoPatch = pr.split("/");
            String repoOwner = infoPatch[3];
            String repoName = infoPatch[4];
            String prNumber = infoPatch[6];
            // Query GHTorrent to find the corresponding Pull Request
            Bson filter = and(eq("repo", repoName),
                    eq("owner", repoOwner),
                    eq("number", prNumber));
            FindIterable<Document> mongoElement = mongoPullRequestsCollection.find(filter);
            if (mongoElement.first() != null) {
                jsonBody = mongoElement.first().toJson();
            }

            // If GhTorrent does not find it, query Github API
            if (jsonBody == null) {
                String apiLink = "https://api.github.com/repos/" + repoOwner + "/" + repoName + "/pulls/" + prNumber;
                // Send GET request
                jsonBody = httpClient.sendGet(apiLink);
                if (jsonBody.contains("\"message\": \"Not Found\"")) {
                    return vp;
                }
                // TODO: If it was not on GHTorrent, write it in there (?)
            }

            // Look for a merge_commit_sha and use the parseCommit function
            // Parse the result and extract data
            Object obj = jsonParser.parse(jsonBody);
            JSONObject payload = (JSONObject) obj;
            if (payload.get("merge_commit_sha") != null) {
                // There is a commit we can parse
                String mergeCommitSHA = (String) payload.get("merge_commit_sha");
                String urlCommit = "https://github.com/" + repoOwner + "/" + repoName + "/commit/" + mergeCommitSHA;
                vp = this.parseGHCommit(urlCommit);
            }
        } catch (Exception e) {
            e.printStackTrace();
        }
        return vp;
    }

    /**
     * Method parses Github issues links found in the vulnerability references.
     *
     * @param issue         - link of the issue e.g. https://github.com/restlet/restlet-framework-java/issues/774
     *                      <p>
     *                      The script looks for a pull_request field in the json corresponding to the issue.
     *                      "pull_request": {
     *                      "url": "https://api.github.com/repos/python/cpython/pulls/32",
     *                      "html_url": "https://github.com/python/cpython/pull/32",
     *                      "diff_url": "https://github.com/python/cpython/pull/32.diff",
     *                      "patch_url": "https://github.com/python/cpython/pull/32.patch"
     *                      }
     * @return
     */
    public HashSet<Vulnerability.Patch> parseIssues(String issue) {
        logger.info("Parsing issue with URL: " + issue);
        String jsonBody = null;
        HashSet<Vulnerability.Patch> vp = new HashSet<>();
        try {
            // Extract information from the patch and create API Link
            String[] infoPatch = issue.split("/");
            String repoOwner = infoPatch[3];
            String repoName = infoPatch[4];
            String issueNumber = infoPatch[6];
            // Query GHTorrent to find the corresponding Pull Request
            FindIterable<Document> mongoElement = mongoIssuesCollection.find(and(eq("repo", repoName),
                    eq("owner", repoOwner), eq("number", issueNumber)));
            if (mongoElement.first() != null) {
                jsonBody = mongoElement.first().toJson();
            }
            // If GhTorrent does not find it, query Github API
            if (jsonBody == null) {
                String apiLink = "https://api.github.com/repos/" + repoOwner + "/" + repoName + "/issues/" + issueNumber;
                // Send GET request
                jsonBody = httpClient.sendGet(apiLink);
                if (jsonBody.contains("\"message\": \"Not Found\"")) {
                    return vp;
                }
                // TODO: If it was not on GHTorrent, write it in there (?)
            }

            // Look for a pull_request and use the parsePullRequest function
            // Parse the result and extract data
            Object obj = jsonParser.parse(jsonBody);
            JSONObject payload = (JSONObject) obj;
            if (payload.get("pull_request") != null) {
                // There is a commit we can parse
                JSONObject pullRequest = (JSONObject) payload.get("pull_request");
                String urlPullRequest = (String) pullRequest.get("html_url");
                vp = this.parsePullRequest(urlPullRequest);
            }
        } catch (Exception e) {
            e.printStackTrace();
        }
        return vp;
    }

    /**
     * Parses patch links to git commits using GitHub API v3.
     * Extracts the following information:
     * - files changed
     * - methods affected
     * - days it took to fix
     *
     * @param patchLink     URL to the git commit
     */
    public HashSet<Vulnerability.Patch> parseGHCommit(String patchLink) {
        logger.info("Parsing commit with URL: " + patchLink);
        String jsonBody = null;
        HashSet<Vulnerability.Patch> vp = new HashSet<>();
        try {
            // Extract information from the patch and create API Link
            String[] infoPatch = patchLink.split("/");
            String commitHash = infoPatch[6];
            // Query GHTorrent with the hash of the commit
            FindIterable<Document> mongoElement = mongoCommitsCollection.find(eq("sha", commitHash));
            if (mongoElement.first() != null) {
                jsonBody = mongoElement.first().toJson();
            }

            // If GHTorrent does not find it, query Github API
            if (jsonBody == null) {
                String repoOwner = infoPatch[3];
                String repoName = infoPatch[4];
                String apiLink = "https://api.github.com/repos/" + repoOwner + "/" + repoName + "/commits/" + commitHash;
                // Send GET request
                jsonBody = httpClient.sendGet(apiLink);
                if (jsonBody.contains("\"message\": \"Not Found\"")) {
                    return vp;
                }
            }

            // Parse the result and extract data
            JSONParser jsonParser = new JSONParser();
            Object obj = jsonParser.parse(jsonBody);
            JSONObject payload = (JSONObject) obj;
            JSONObject commit = (JSONObject) payload.get("commit");
            JSONObject author = (JSONObject) commit.get("author");
            String date = (String) author.get("date");
            List<Object> files = (List<Object>) payload.get("files");
            for (Object file : files) {
                JSONObject fileObj = (JSONObject) file;
                String filenameChanged = (String) fileObj.get("filename");
                if (fileObj.get("patch") != null) {
                    List<Integer> hunks = getPatchHunks(fileObj.get("patch").toString());
                    Vulnerability.Patch p = new Vulnerability.Patch(filenameChanged, date, hunks);
                    vp.add(p);
                }
            }
        } catch (Exception e) {
            e.printStackTrace();
        }
        return vp;
    }

    /**
     * Parses link from a GitLab commit.
     * Add .diff to the link to extract the raw diff of the file.
     *
     * @param ref - commit link
     * @return - Set of Patches
     */
    private HashSet<Vulnerability.Patch> parseGLCommit(String ref) {
        logger.info("Parsing GitLab commit with URL: " + ref);
        var linkToDiff = ref + ".diff";
        try {
            var raw = httpClient.sendGet(linkToDiff);
            var patches = getPatchesFromDiffs(raw);
            return patches;
        } catch (Exception e) {
            e.printStackTrace();
        }
        return null;
    }

    /**
     * Injects patch info for Git Tracker links to commits.
     * @param ref - link to a commit that uses cgit
     * @return - set of patches
     */
    private HashSet<Vulnerability.Patch> parseGitTrackerCommit(String ref) {
        logger.info("Parsing Git tracker commit with URL: " + ref);
        // cgit supports rawdiff commmand
        var linkToDiff = ref.replaceFirst("/commit/", "/rawdiff/");
        try {
            var raw = httpClient.sendGet(linkToDiff);
            var patches = getPatchesFromDiffs(raw);
            return patches;
        } catch (Exception e) {
            e.printStackTrace();
        }
        return null;
    }

    /**
     * Injects patch info from Apache SVN revision link.
     * @param ref - link to a revision
     * @return - set of patches
     */
    private HashSet<Vulnerability.Patch> parseApacheSVNRevision(String ref) {
        logger.info("Parsing Apache SVN revision with URL: " + ref);
        HashSet<Vulnerability.Patch> patches = new HashSet<>();
        String baseURL = "https://svn.apache.org";
        org.jsoup.nodes.Document doc = null;
        try {
            String revisionHTML = httpClient.sendGet(ref);
            doc = Jsoup.parse(revisionHTML);
            Elements links = doc.select("a[title=\"View Diff\"]");
            for (Element link : links) {
                var patchLink = baseURL + link.attr("href") + "&view=patch";
                var diff = httpClient.sendGet(patchLink);
                var filename = link.attr("href").substring(8).split("\\?")[0];
                var lineChanges = getPatchHunks(diff);
                patches.add(new Vulnerability.Patch(filename, lineChanges));
            }
            return patches;
        } catch (Exception e) {
            e.printStackTrace();
        }
        return null;
    }

    /**
     * Injects information taking it from JIRA tickets.
     * The information is held into either comments or attachments.
     * @param ref - link to JIRA ticket
     * @return - set of patches
     */
    private HashSet<Vulnerability.Patch> parseJIRATicket(String ref) {
        logger.info("Parsing JIRA Ticket with URL: " + ref);
        HashSet<Vulnerability.Patch> patches = new HashSet<>();
        var jiraServer = ref.split("/browse/")[0];
        var ticketId = ref.split("/browse/")[1];

        var linkToJson = jiraServer + "/rest/api/2/issue/" + ticketId;
        try {
            var ticketJson = httpClient.sendGet(linkToJson);
            // Extract each of the attachments, if the contain a patch, parse it
            Object obj = jsonParser.parse(ticketJson);
            JSONObject payload = (JSONObject) obj;
            JSONObject fields = (JSONObject) payload.get("fields");

            JSONArray attachments = (JSONArray) fields.get("attachment");
            JSONArray comments = (JSONArray) ((JSONObject )fields.get("comment")).get("comments");

            // Attachments
            for (Object attachment : attachments) {
                String linkToAttachment = (String) ((JSONObject) attachment).get("content");
                if (linkToAttachment.endsWith(".patch")) {
                    var rawPatch = httpClient.sendGet(linkToAttachment);
                    // Parse the diffs
                    patches.addAll(getPatchesFromDiffs(rawPatch));
                }
            }

            // Comments
            for (Object comment : comments) {
                String body = (String) ((JSONObject) comment).get("body");
                List<String> potentialPatches = findPatchLinks(body);
                for (String pp : potentialPatches) {
                    var vpp = parseReference(pp);
                    if (vpp != null && vpp.size() > 0)  patches.addAll(vpp);
                }
            }

            return patches;
        } catch (Exception e) {
            e.printStackTrace();
        }
        return null;
    }


    /**
     * Injects information taking it from Bugzilla bug.
     * The information is held into attachments.
     * @param ref - link to Bugzilla bug
     * @return - set of patches
     */
    private HashSet<Vulnerability.Patch> parseBugzillaBug(String ref) {
        logger.info("Parsing Bugzilla Bug with URL: " + ref);
        HashSet<Vulnerability.Patch> patches = new HashSet<>();
        var bugzillaServer = ref.split("/show_bug")[0];
        var bugId = ref.split("/show_bug\\.cgi\\?id=")[1];
        var bugAttachmentsUrl = bugzillaServer + "/rest/bug/" + bugId + "/attachment";

        try {
            var responseJson = httpClient.sendGet(bugAttachmentsUrl);
            // Extract each of the attachments, if the contain a patch, parse it
            Object obj = jsonParser.parse(responseJson);
            JSONObject payload = (JSONObject) obj;
            JSONObject bugs = (JSONObject) payload.get("bugs");
            JSONArray attachments = (JSONArray) bugs.get(bugId);

            for (int i = 0; i < attachments.size(); i++) {
                JSONObject attachment = (JSONObject) attachments.get(i);
                if (attachment.get("is_patch").toString().equals("1")) {
                    // Get data in base 64 encoding
                    byte[] decodedBytes = Base64.getDecoder().decode((String) attachment.get("data"));
                    String patch = new String(decodedBytes);
                    patches.addAll(getPatchesFromDiffs(patch));
                }
            }

            return patches;
        } catch (Exception e) {
            e.printStackTrace();
        }
        return null;
    }

    /**
     * Given a string of text, uses regex to find
     * @param text
     * @return
     */
    private List<String> findPatchLinks(String text) {
        List<String> potentialPatches = new ArrayList<>();
        // TODO: Improve this regex to better filter links
        // TODO: Add support for other links as well
        Pattern regex = Pattern.compile("https://(github|gitlab)\\.com/.*");
        Matcher m = regex.matcher(text);
        while (m.find()) {
            potentialPatches.add(m.group());
        }
        return potentialPatches;
    }

    /**
     * Takes a diff file as input and produces a set of patches to inject into the Vulnerability Object.
     * @param diffs - diffs of the patch to be parsed.
     * @return set of Patches
     */
    private HashSet<Vulnerability.Patch> getPatchesFromDiffs(String diffs) {
        HashSet<Vulnerability.Patch> patches = new HashSet<>();
        String[] hunks = diffs.split("--- ");
        for (int i = 1; i < hunks.length; i++) {
            Vulnerability.Patch patch = new Vulnerability.Patch();
            var filename = hunks[i].split("\n")[0].split("\\t")[0];
            if (filename.startsWith("a/"))  filename = filename.substring(2);
            List<Integer> lineChanged = getPatchHunks(hunks[i]);
            // Fill in the patch
            patch.setFileName(filename);
            patch.setLineNumbers(lineChanged);
            patches.add(patch);
        }
        return patches;
    }

    /**
     * Extracts the hunks from the commit information.
     *
     * @param patch     - String representing the patch information
     * @return
     */
    public static List<Integer> getPatchHunks(String patch) {
        List<Integer> linesAffected = new ArrayList<>();
        String[] linesPatch = patch.split("\n");
        for (int i = 0; i < linesPatch.length; i++) {
            String hunk = StringUtils.substringBetween(linesPatch[i], "@@");
            if (hunk != null) {
                String s = hunk.split("-")[1].split(" \\+")[0];
                if (s.contains(",")) s = s.substring(0, s.indexOf(","));

                String t = hunk.split("\\+")[1].split(",")[0];

                int fromLineNumber = Integer.parseInt(s);
                int toLineNumber = Integer.parseInt(t);

                // Check if the file was deleted (aka: toLineNumber is 0)
                if (toLineNumber == 0) continue;

                // Check if the file was created (aka: fromLineNumber is 0)
                if (fromLineNumber == 0) continue;

                // Go through the next lines looking for + or - and keep going until you find something different
                int j = i + 1;
                boolean currPatch = true;
                int lineChanged = -1;
                int deltaChanges = 0;

                while (j < linesPatch.length && currPatch) {
                    // This is the first + or - we see
                    if (lineChanged < 0 && (linesPatch[j].charAt(0) == '+' || linesPatch[j].charAt(0) == '-')) {
                        lineChanged = fromLineNumber + j - i - deltaChanges - 1;
                    }

                    if (lineChanged > 0 && linesPatch[j].charAt(0) == '+') {
                        deltaChanges += 1;
                    }

                    // There are no more changes in this hunk
                    if (lineChanged >= 0 && ((linesPatch[j].charAt(0) != '+' && linesPatch[j].charAt(0) != '-') || j == linesPatch.length - 1)) {
                        // Add the affected line
                        linesAffected.add(lineChanged);
                        // Reset the lineChanged holder
                        lineChanged = -1;
                    }

                    // Check if the next is another patch
                    currPatch = StringUtils.substringBetween(linesPatch[j], "@@") == null;
                    if (!currPatch)  i = j - 2;
                    j += 1;
                }
            }
        }
        return linesAffected;
    }

    /**
     * Parse all the references looking for diffs.
     *
     * @param vulnerability to parse references and inject info.
     */
    public void parseReferences(Vulnerability vulnerability, NitriteController nc) {
        // Parse all patches and references, scouting for diffs
        HashSet<String> links = vulnerability.getReferences();
        links.addAll(vulnerability.getPatchLinks());

        for (String ref : links) {
            // First look into Nitrite if the ref was already parsed before
            Optional<HashSet<Vulnerability.Patch>> queryFromNC = nc.findPatchEntry(ref);
            if (!queryFromNC.isEmpty()) {
                for (Vulnerability.Patch vp : queryFromNC.get()) {
                    vulnerability.addPatch(vp);
                }
                continue;
            } else {
                HashSet<Vulnerability.Patch> vp = parseReference(ref);

                // If something was found, store it in Nitrite and put in it in the Vulnerability
                if (vp != null && vp.size() > 0) {
                    // Store it in Nitrite
                    PatchObject po = new PatchObject();
                    po.setPatchURL(ref);
                    po.setFilesChanged(vp);
                    nc.insertPatch(po);
                    logger.info("Found " + vp.size() + " patched files for vulnerability " + vulnerability.getId());

                    // Adding patches to the vulnerability
                    for (Vulnerability.Patch p : vp) {
                        vulnerability.addPatch(p);
                    }
                }
            }
        }
    }

    /**
     * Gets a link that might lead to a patch and then extrapolates the information accordingly.
     * @param ref - link contained in the vulnerability.
     * @return - set of patches extracted from the link.
     */
    private HashSet<Vulnerability.Patch> parseReference(String ref) {
        // Case 1: GitHub commit
        if (ref.matches("https://github\\.com/.*/.*/commit/.*")) {
            return parseGHCommit(ref);
        }

        // Case 2: GitHub Pull request
        if (ref.matches("https://github\\.com/.*/.*/pull/.*")) {
            return parsePullRequest(ref);
        }

        // Case 3: GitHub Issues
        if (ref.matches("https://github\\.com/.*/.*/issues/.*")) {
            return parseIssues(ref);
        }

        // Case 4: GitLab commit
        if (ref.matches("https://gitlab\\.com/.*/.*/-/commit/.*")) {
            return parseGLCommit(ref);
        }

        // Case 5: Git trackers
        if (ref.matches("https://.*git\\..*\\.org/.*/commit/.*")) {
            return parseGitTrackerCommit(ref);
        }

        // Case 6: SVN Apache link
        if (ref.matches("https://svn\\.apache\\.org/.*revision=.*")) {
            return parseApacheSVNRevision(ref);
        }

        // Case 7: JIRA tickets
        if ((ref.matches("https://issues\\..*\\.org/jira/browse/.*")) || ref.matches("https://jira\\..*\\.org/browse/.*")) {
            return parseJIRATicket(ref);
        }

        // Case 8: Bugzilla server
        if ((ref.matches("https://bugs\\..*\\..*/show_bug\\.cgi\\?id=.*")) || ref.matches("https://bugzilla\\..*\\..*/show_bug\\.cgi\\?id=.*")) {
            return parseBugzillaBug(ref);
        }

        return null;
    }
}
