/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package eu.fasten.vulnerabilityproducer.utils;

import com.mongodb.client.MongoDatabase;
import eu.fasten.vulnerabilityproducer.db.NitriteController;
import eu.fasten.vulnerabilityproducer.db.PatchObject;
import eu.fasten.vulnerabilityproducer.utils.connections.JavaHttpClient;
import eu.fasten.vulnerabilityproducer.utils.patches.*;
import org.jooq.tools.json.JSONParser;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.util.*;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.function.UnaryOperator;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

/**
 * This class has the responsibility to handle references and crawl for commits.
 * Those will lead to diffs that will lead to changed files.
 * Those files will be considered vulnerable since they needed changes in order
 */
public class PatchFinder {

    public static JSONParser jsonParser;
    public static JavaHttpClient httpClient;
    public String gitHubToken;
    public static GitHubRanger gitHubRanger;
    public static GitLabRanger gitLabRanger;
    public static BitBucketRanger bitBucketRanger;
    public static JIRARanger jiraRanger;
    public static BugzillaRanger bugzillaRanger;
    public static ExtraRanger extraRanger;
    public static HashSet<String> refSet;
    private final Logger logger = LoggerFactory.getLogger(PatchFinder.class.getName());

    // regex utils
    public static final String owner = "[a-zA-Z_0-9\\-]++";
    public static final String project = "[a-zA-Z_0-9\\-\\.]++";
    public static final String sha = "[a-zA-Z_0-9/]++";

    // base repo cutter
    UnaryOperator<String> repoCutter = ref -> {
        var sb = new StringBuilder();
        var repo = ref.split("/");
        if (repo.length > 4) {
            return sb.append("https://").append(repo[2] + "/").append(repo[3] + "/").append(repo[4]).toString();
        } else {
            return null;
        }
    };

    /**
     * Takes a MongoDatabase object to connect and retrieve collections from.
     */
    public PatchFinder(MongoDatabase db, JavaHttpClient client, String ghToken) {
        httpClient = client;
        jsonParser = new JSONParser();
        gitHubToken = ghToken;
        gitHubRanger = new GitHubRanger(client, db, gitHubToken, jsonParser);
        gitLabRanger = new GitLabRanger(client, jsonParser);
        bitBucketRanger = new BitBucketRanger(client, jsonParser);
        bugzillaRanger = new BugzillaRanger(client, jsonParser);
        jiraRanger = new JIRARanger(client, jsonParser);
        extraRanger = new ExtraRanger(client, jsonParser);
        refSet = new HashSet<>();
    }

    /**
     * Given a string of text, uses regex to find
     * @param text
     * @return
     */
    public static List<String> findPatchLinks(String text) {
        List<String> potentialPatches = new ArrayList<>();
        List<Matcher> matchers = new ArrayList<>();

        matchers.add(Pattern.compile("http(s)?://gitlab(\\.com|\\..*\\.org)/.*").matcher(text));
        matchers.add(Pattern.compile("https://github\\.com/.*/.*/(commit|pull|issues)/[\\w]++").matcher(text));
        matchers.add(Pattern.compile("https://(issues|jira)\\.[a-zA-Z_0-9\\-]++\\.org/(jira/)?browse/[a-zA-Z_0-9\\-]++").matcher(text));
        matchers.add(Pattern.compile("https://(bugs|bugzilla)\\..*\\..*/show_bug\\.cgi\\?id=.*").matcher(text));
        matchers.add(Pattern.compile("https://lists\\.apache\\.org/thread\\.html/.*").matcher(text));
        matchers.add(Pattern.compile("http(s)?://svn\\.apache\\.org/(.*revision=.*|r[0-9]++)").matcher(text));
        matchers.add(Pattern.compile("http(s)?://.*git\\..*\\.(org|com)/.*").matcher(text));
        matchers.add(Pattern.compile("https://bitbucket\\.org/" + owner + "/" + project +
                "/(commits|pull-requests|issues)/(" + sha + "|(\\d)++)").matcher(text));
        matchers.add(Pattern.compile("http(s)?://hg\\..*\\.(net|org)/(\\w)++/" + owner + "(/\\w++)?/rev/" + sha).matcher(text));

        for (Matcher matcher : matchers) {
            while (matcher.find()) {
                potentialPatches.add(matcher.group().split("[\t\\s\n]")[0]);
            }
        }

        return potentialPatches;
    }

    /**
     * Parse all the references looking for diffs.
     *
     * @param vulnerability to parse references and inject info.
     */
    public void parseReferences(Vulnerability vulnerability, NitriteController nc) {
        // Parse all patches and references, scouting for diffs
        var links = vulnerability.getReferences();
        links.addAll(vulnerability.getPatchLinks());

        var patchLinks = new HashSet<String>();
        for (String ref : links) {
            // First look into Nitrite if the ref was already parsed before
            var queryFromNC = nc.findPatchEntry(ref);
            if (!queryFromNC.isEmpty()) {
                var count = new AtomicInteger();
                queryFromNC.get().forEach(vp -> {
                    vulnerability.addPatch(vp);
                    patchLinks.add(ref);
                    count.addAndGet(1);
                });
                logger.info("Found " + count.get()
                        + " patched files in ref: " + ref + " for vulnerability " + vulnerability.getId());
            } else {
                var vp = parseReference(ref);

                // If something was found, store it in Nitrite and put in it in the Vulnerability
                if (vp != null && vp.size() > 0) {
                    // Store it in Nitrite
                    var po = new PatchObject();
                    po.setPatchURL(ref);
                    po.setFilesChanged(vp);
                    nc.insertPatch(po);
                    logger.info("Found " + vp.size() + " patched files in ref: " + ref +
                            " for vulnerability " + vulnerability.getId());

                    // Adding patches to the vulnerability
                    vp.forEach(p -> {
                        vulnerability.addPatch(p);
                        patchLinks.add(ref);
                    });
                }
            }
        }
        // Move the patch links from the refs
        vulnerability.getReferences().removeAll(patchLinks);
        vulnerability.setPatchLinks(patchLinks);
    }

    /**
     * Gets a link that might lead to a patch and then extrapolates the information accordingly.
     * @param ref - link contained in the vulnerability.
     * @return - set of patches extracted from the link.
     */
    public static HashSet<Vulnerability.Patch> parseReference(String ref) {
        ref = httpClient.validateAndRedirect(ref, refSet);
        if (ref == null)    return null;
        // Prevents circular links
        if (refSet.contains(ref))   {
            return null;
        } else {
            refSet.add(ref);
        }

        // Case 1: GitHub commit
        if (ref.matches("https://github\\.com/" + owner + "/" + project + "/commit/" + sha)) {
            return gitHubRanger.parseGHCommit(ref);
        }

        // Case 2: GitHub Pull request
        if (ref.matches("https://github\\.com/" + owner + "/" + project + "/pull/(\\d)++")) {
            return gitHubRanger.parseGHPullRequest(ref);
        }

        // Case 3: GitHub Issues
        if (ref.matches("https://github\\.com/" + owner + "/" + project + "/issues/(\\d)++")) {
            return gitHubRanger.parseGHIssue(ref);
        }

        // Case 4: GitLab commit
        if (ref.matches("https://gitlab\\.com/" + owner + "/" + project + "/-/commit/" + sha) ||
                ref.matches("https://gitlab\\..*\\.org/" + owner + "/" + project + "/-/commit/" + sha)) {
            return gitLabRanger.parseGLCommit(ref);
        }

        // Case 5: GitLab issue
        if (ref.matches("https://gitlab\\.com/" + owner + "/" + project + "/-/issues/(\\d)++") ||
                ref.matches("https://gitlab\\..*\\.org/" + owner + "/" + project + "/-/issues/(\\d)++")) {
            return gitLabRanger.parseGLIssue(ref);
        }

        // Case 6: GitLab merge request
        if (ref.matches("https://gitlab\\.com/" + owner + "/" + project + "/-/merge_requests/(\\d)++") ||
                ref.matches("https://gitlab\\..*\\.org/" + owner + "/" + project + "/-/merge_requests/(\\d)++")) {
            return gitLabRanger.parseGLMergeRequest(ref);
        }

        // Case 7: Git trackers
        if (ref.matches("http(s)?://.*git\\..*\\.(org|com)/.*")) {
            return extraRanger.parseGitTrackerCommit(ref);
        }

        // Case 8: SVN Apache link
        if (ref.matches("http(s)?://svn\\.apache\\.org/(.*revision=.*|r[0-9]++)")) {
            return extraRanger.parseApacheSVNRevision(ref);
        }

        // Case 9: JIRA tickets
        if (ref.matches("https://(issues|jira)\\.[a-zA-Z_0-9\\-]++\\.org/(jira/)?browse/[a-zA-Z_0-9\\-]++")) {
            return jiraRanger.parseJIRATicket(ref);
        }

        // Case 10: Bugzilla server
        if (ref.matches("https://(bugs|bugzilla)\\..*\\..*/show_bug\\.cgi\\?id=" + owner)) {
            return bugzillaRanger.parseBugzillaBug(ref);
        }

        // Case 11: Apache Mailing list
        if (ref.matches("https://lists\\.apache\\.org/thread\\.html/.*")) {
            return extraRanger.parseApacheMailThread(ref);
        }

        // Case 12: Bitbucket commit
        if (ref.matches("https://bitbucket\\.org/" + owner + "/" + project + "/commits/" + sha)) {
            return bitBucketRanger.parseBitBucketCommit(ref);
        }

        // Case 13: Bitbucket PR
        if (ref.matches("https://bitbucket\\.org/" + owner + "/" + project + "/pull-requests/(\\d)++")) {
            return bitBucketRanger.parseBitBucketPullRequest(ref);
        }

        // Case 14: Bitbucket Issue
        if (ref.matches("https://bitbucket\\.org/" + owner + "/" + project + "/issues/(\\d)++")) {
            return bitBucketRanger.parseBitBucketIssue(ref);
        }

        // Case 15: Mercurial revision
        if (ref.matches("http(s)?://hg\\..*\\.(net|org)/(\\w)++/" + owner + "(/\\w++)?/rev/" + sha)) {
            return extraRanger.parseMercurialRevision(ref);
        }

        refSet.add(ref);
        return null;
    }

    /**
     * Looks in the patch links for a "repo base" url.
     * For now handle GitHub links only, since they represent the majority of the base links.
     * @param v _ Vulnerability Object
     * @return String with the base url of the repo
     */
    public String getBaseRepo(Vulnerability v) {
        HashMap<String, Integer> mapCounts = new HashMap<>();
        v.getPatchLinks().stream().forEach(
                ref -> mapCounts.merge((repoCutter.apply(ref)), 1, Integer::sum)
        );
        if (mapCounts.isEmpty())    return null;
        return Collections.max(mapCounts.entrySet(), Map.Entry.comparingByValue()).getKey();
    }
}
