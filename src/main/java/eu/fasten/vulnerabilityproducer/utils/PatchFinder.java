/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package eu.fasten.vulnerabilityproducer.utils;

import com.mongodb.client.MongoDatabase;
import eu.fasten.vulnerabilityproducer.db.NitriteController;
import eu.fasten.vulnerabilityproducer.db.PatchObject;
import eu.fasten.vulnerabilityproducer.utils.connections.JavaHttpClient;
import eu.fasten.vulnerabilityproducer.utils.connections.MongoConnector;
import eu.fasten.vulnerabilityproducer.utils.patches.*;
import org.jooq.tools.json.JSONParser;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.io.IOException;
import java.net.HttpURLConnection;
import java.net.URL;
import java.util.*;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

/**
 * This class has the responsibility to handle references and crawl for commits.
 * Those will lead to diffs that will lead to changed files.
 * Those files will be considered vulnerable since they needed changes in order
 */
public class PatchFinder {

    public static JSONParser jsonParser;
    public static JavaHttpClient httpClient;
    public String gitHubToken;
    public static GitHubRanger gitHubRanger;
    public static GitLabRanger gitLabRanger;
    public static BitBucketRanger bitBucketRanger;
    public static JIRARanger jiraRanger;
    public static BugzillaRanger bugzillaRanger;
    public static ExtraRanger extraRanger;
    private final Logger logger = LoggerFactory.getLogger(PatchFinder.class.getName());

    /**
     * Takes a MongoDatabase object to connect and retrieve collections from.
     */
    public PatchFinder(MongoDatabase db, JavaHttpClient client) {
        httpClient = client;
        jsonParser = new JSONParser();
        gitHubToken = System.getenv("FASTEN_GHTOKEN");
        gitHubRanger = new GitHubRanger(client, db, gitHubToken, jsonParser);
        gitLabRanger = new GitLabRanger(client, jsonParser);
        bitBucketRanger = new BitBucketRanger(jsonParser);
        bugzillaRanger = new BugzillaRanger(client, jsonParser);
        jiraRanger = new JIRARanger(client, jsonParser);
        extraRanger = new ExtraRanger(client, jsonParser);
    }

    /**
     * Given a string of text, uses regex to find
     * @param text
     * @return
     */
    public static List<String> findPatchLinks(String text) {
        List<String> potentialPatches = new ArrayList<>();
        List<Matcher> matchers = new ArrayList<>();

        // TODO: Improve this pattern matching to make sure what gets out of here is actually valid stuff
        matchers.add(Pattern.compile("https://gitlab\\.com/.*").matcher(text));
        matchers.add(Pattern.compile("https://github\\.com/.*/.*/(commit|pull|issues)/[\\w]++").matcher(text));
        matchers.add(Pattern.compile("https://(issues|jira)\\..*\\.org/(jira/)?browse/.*").matcher(text));
        matchers.add(Pattern.compile("https://(bugs|bugzilla)\\..*\\..*/show_bug\\.cgi\\?id=.*").matcher(text));
        matchers.add(Pattern.compile("https://lists\\.apache\\.org/thread\\.html/.*").matcher(text));
        matchers.add(Pattern.compile("https://svn\\.apache\\.org/.*(revision=|rev=).*").matcher(text));
        matchers.add(Pattern.compile("https://.*git\\..*\\.org/.*/commit/.*").matcher(text));
        matchers.add(Pattern.compile("https://bitbucket\\.org/[\\w]++/[\\w]++/[\\w]++/[\\w]++").matcher(text));

        for (Matcher matcher : matchers) {
            while (matcher.find()) {
                potentialPatches.add(matcher.group().split("[\t\\s\n]")[0]);
            }
        }

        return potentialPatches;
    }

    /**
     * Parse all the references looking for diffs.
     *
     * @param vulnerability to parse references and inject info.
     */
    public void parseReferences(Vulnerability vulnerability, NitriteController nc) {
        // Parse all patches and references, scouting for diffs
        var links = vulnerability.getReferences();
        links.addAll(vulnerability.getPatchLinks());

        var patchLinks = new HashSet<String>();
        for (String ref : links) {
            // First look into Nitrite if the ref was already parsed before
            var queryFromNC = nc.findPatchEntry(ref);
            if (!queryFromNC.isEmpty()) {
                queryFromNC.get().forEach(vp -> {
                    vulnerability.addPatch(vp);
                    patchLinks.add(ref);
                });
            } else {
                var vp = parseReference(ref);

                // If something was found, store it in Nitrite and put in it in the Vulnerability
                if (vp != null && vp.size() > 0) {
                    // Store it in Nitrite
                    var po = new PatchObject();
                    po.setPatchURL(ref);
                    po.setFilesChanged(vp);
                    nc.insertPatch(po);
                    logger.info("Found " + vp.size() + " patched files for vulnerability " + vulnerability.getId());

                    // Adding patches to the vulnerability
                    vp.forEach(p -> {
                        vulnerability.addPatch(p);
                        patchLinks.add(ref);
                    });
                }
            }
        }
        // Move the patch links from the refs
        vulnerability.getReferences().removeAll(patchLinks);
        vulnerability.setPatchLinks(patchLinks);
    }

    /**
     * Gets a link that might lead to a patch and then extrapolates the information accordingly.
     * @param ref - link contained in the vulnerability.
     * @return - set of patches extracted from the link.
     */
    public static HashSet<Vulnerability.Patch> parseReference(String ref) {
//        ref = validateAndRedirect(ref);
        if (ref == null)    return null;

            // Case 1: GitHub commit
        if (ref.matches("https://github\\.com/.*/.*/commit/.*")) {
            return gitHubRanger.parseGHCommit(ref);
        }

        // Case 2: GitHub Pull request
        if (ref.matches("https://github\\.com/.*/.*/pull/.*")) {
            return gitHubRanger.parseGHPullRequest(ref);
        }

        // Case 3: GitHub Issues
        if (ref.matches("https://github\\.com/.*/.*/issues/.*")) {
            return gitHubRanger.parseGHIssue(ref);
        }

        // Case 4: GitLab commit
        if (ref.matches("https://gitlab\\.com/.*/.*/-/commit/.*") ||
                ref.matches("https://gitlab\\..*\\.org/.*/.*/-/commit/.*")) {
            return gitLabRanger.parseGLCommit(ref);
        }

        // Case 5: GitLab issue
        if (ref.matches("https://gitlab\\.com/.*/.*/-/issues/.*") ||
                ref.matches("https://gitlab\\..*\\.org/.*/.*/-/issues/.*")) {
            return gitLabRanger.parseGLIssue(ref);
        }

        // Case 6: GitLab merge request
        if (ref.matches("https://gitlab\\.com/.*/.*/-/merge_requests/.*") ||
                ref.matches("https://gitlab\\..*\\.org/.*/.*/-/merge_requests/.*")) {
            return gitLabRanger.parseGLMergeRequest(ref);
        }

        // Case 7: Git trackers
        if (ref.matches("http(s)?://.*git\\..*\\.org/.*/commit/.*")) {
            return extraRanger.parseGitTrackerCommit(ref);
        }

        // Case 8: SVN Apache link
        if (ref.matches("http(s)?://svn\\.apache\\.org/(.*revision=.*|r[0-9]++)")) {
            return extraRanger.parseApacheSVNRevision(ref);
        }

        // Case 9: JIRA tickets
        if (ref.matches("https://(issues|jira)\\..*\\.org/(jira/)?browse/.*")) {
            return jiraRanger.parseJIRATicket(ref);
        }

        // Case 10: Bugzilla server
        if (ref.matches("https://(bugs|bugzilla)\\..*\\..*/show_bug\\.cgi\\?id=.*")) {
            return bugzillaRanger.parseBugzillaBug(ref);
        }

        // Case 11: Apache Mailing list
        if (ref.matches("https://lists\\.apache\\.org/thread\\.html/.*")) {
            return extraRanger.parseApacheMailThread(ref);
        }

        // Case 12: Bitbucket commit
        if (ref.matches("https://bitbucket\\.org/.*/.*/commits/.*")) {
            return bitBucketRanger.parseBitBucketCommit(ref);
        }

        // Case 13: Bitbucket PR
        if (ref.matches("https://bitbucket\\.org/.*/.*/pull-requests/.*")) {
            return bitBucketRanger.parseBitBucketPullRequest(ref);
        }

        // Case 14: Bitbucket Issue
        if (ref.matches("https://bitbucket\\.org/.*/.*/issues/.*")) {
            return bitBucketRanger.parseBitBucketIssue(ref);
        }

        return null;
    }

    /**
     * Validates whether the url is valid and looks for redirects.
     * @param url - ref to check
     * @return ref to parse - null if ref is not valid
     */
    private static String validateAndRedirect(String url) {
        try {
            if (url == null)    return null;
            var con = (HttpURLConnection) new URL(url).openConnection();
            con.setInstanceFollowRedirects(false);
            con.connect();
            con.getInputStream();

            if (con.getResponseCode() == HttpURLConnection.HTTP_MOVED_PERM || con.getResponseCode() == HttpURLConnection.HTTP_MOVED_TEMP) {
                String redirectUrl = con.getHeaderField("Location");
                return validateAndRedirect(redirectUrl);
            }
            return url;
        } catch (IOException e) {
            return null;
        }
    }

    /**
     * Looks in the patch links for a "repo base" url.
     * For now handle GitHub links only, since they represent the majority of the base links.
     * @param v _ Vulnerability Object
     * @return String with the base url of the repo
     */
    public String getBaseRepo(Vulnerability v) {
        HashMap<String, Integer> mapCounts = new HashMap<>();
        v.getPatchLinks().stream().filter(ref -> ref.startsWith("https://github.com")).forEach(
                ref -> mapCounts.merge(getBaseGitHub(ref), 1, Integer::sum)
        );
        if (mapCounts.isEmpty())    return null;
        var mostFreqBase = Collections.max(mapCounts.entrySet(), Map.Entry.comparingByValue()).getKey();
        return mostFreqBase;
    }

    /**
     * Extracts base url of the GitHub repo.
     * @param ref - link to commit/pr/issue
     * @return - base url of the repository
     */
    private String getBaseGitHub(String ref) {
        assert ref.contains("github.com");
        var repoInfo = ref.split("/");
        return "https://github.com/" + repoInfo[3] + "/" + repoInfo[4];
    }
}
