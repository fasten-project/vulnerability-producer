/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package eu.fasten.vulnerabilityproducer.utils;

import com.mongodb.client.MongoDatabase;
import eu.fasten.vulnerabilityproducer.db.NitriteController;
import eu.fasten.vulnerabilityproducer.db.PatchObject;
import eu.fasten.vulnerabilityproducer.utils.connections.JavaHttpClient;
import eu.fasten.vulnerabilityproducer.utils.patches.*;
import org.jooq.tools.json.JSONParser;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.util.*;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

/**
 * This class has the responsibility to handle references and crawl for commits.
 * Those will lead to diffs that will lead to changed files.
 * Those files will be considered vulnerable since they needed changes in order
 */
public class PatchFinder {

    public static JSONParser jsonParser;
    public static JavaHttpClient httpClient;
    public String gitHubToken;
    public static GitHubRanger gitHubRanger;
    public static GitLabRanger gitLabRanger;
    public static BitBucketRanger bitBucketRanger;
    public static JIRARanger jiraRanger;
    public static BugzillaRanger bugzillaRanger;
    public static ExtraRanger extraRanger;
    private final Logger logger = LoggerFactory.getLogger(PatchFinder.class.getName());

    /**
     * Takes a MongoDatabase object to connect and retrieve collections from.
     */
    public PatchFinder(MongoDatabase db, JavaHttpClient client) {
        httpClient = client;
        jsonParser = new JSONParser();
        gitHubToken = System.getenv("FASTEN_GHTOKEN");
        gitHubRanger = new GitHubRanger(client, db, gitHubToken, jsonParser);
        gitLabRanger = new GitLabRanger(client, jsonParser);
        bitBucketRanger = new BitBucketRanger(client, jsonParser);
        bugzillaRanger = new BugzillaRanger(client, jsonParser);
        jiraRanger = new JIRARanger(client, jsonParser);
        extraRanger = new ExtraRanger(client, jsonParser);
    }

    /**
     * Given a string of text, uses regex to find
     * @param text
     * @return
     */
    public static List<String> findPatchLinks(String text) {
        List<String> potentialPatches = new ArrayList<>();
        List<Matcher> matchers = new ArrayList<>();

        matchers.add(Pattern.compile("https://gitlab\\.com/.*").matcher(text));
        matchers.add(Pattern.compile("https://github\\.com/[\\w]++/[\\w]++/[\\w]++/[\\w]++").matcher(text));
        matchers.add(Pattern.compile("https://(issues|jira)\\..*\\.org/(jira/)?browse/.*").matcher(text));
        matchers.add(Pattern.compile("https://(bugs|bugzilla)\\..*\\..*/show_bug\\.cgi\\?id=.*").matcher(text));
        matchers.add(Pattern.compile("https://lists\\.apache\\.org/thread\\.html/.*").matcher(text));
        matchers.add(Pattern.compile("https://svn\\.apache\\.org/.*revision=.*").matcher(text));
        matchers.add(Pattern.compile("https://.*git\\..*\\.org/.*/commit/.*").matcher(text));
        matchers.add(Pattern.compile("https://bitbucket\\.org/[\\w]++/[\\w]++/[\\w]++/[\\w]++").matcher(text));

        for (Matcher matcher : matchers) {
            while (matcher.find()) {
                potentialPatches.add(matcher.group().split("[\t\\s\n]")[0]);
            }
        }

        return potentialPatches;
    }

    /**
     * Parse all the references looking for diffs.
     *
     * @param vulnerability to parse references and inject info.
     */
    public void parseReferences(Vulnerability vulnerability, NitriteController nc) {
        // Parse all patches and references, scouting for diffs
        HashSet<String> links = vulnerability.getReferences();
        links.addAll(vulnerability.getPatchLinks());

        for (String ref : links) {
            // First look into Nitrite if the ref was already parsed before
            Optional<HashSet<Vulnerability.Patch>> queryFromNC = nc.findPatchEntry(ref);
            if (!queryFromNC.isEmpty()) {
                for (Vulnerability.Patch vp : queryFromNC.get()) {
                    vulnerability.addPatch(vp);
                }
                continue;
            } else {
                HashSet<Vulnerability.Patch> vp = parseReference(ref);

                // If something was found, store it in Nitrite and put in it in the Vulnerability
                if (vp != null && vp.size() > 0) {
                    // Store it in Nitrite
                    PatchObject po = new PatchObject();
                    po.setPatchURL(ref);
                    po.setFilesChanged(vp);
                    nc.insertPatch(po);
                    logger.info("Found " + vp.size() + " patched files for vulnerability " + vulnerability.getId());

                    // Adding patches to the vulnerability
                    for (Vulnerability.Patch p : vp) {
                        vulnerability.addPatch(p);
                    }
                }
            }
        }
    }

    /**
     * Gets a link that might lead to a patch and then extrapolates the information accordingly.
     * @param ref - link contained in the vulnerability.
     * @return - set of patches extracted from the link.
     */
    public static HashSet<Vulnerability.Patch> parseReference(String ref) {
        if (ref == null)    return null;
        if (ref != null && ref.length() > 0 && !isValid(ref)) {
            return null;
        }

        // Case 1: GitHub commit
        if (ref.matches("https://github\\.com/.*/.*/commit/.*")) {
            return gitHubRanger.parseGHCommit(ref);
        }

        // Case 2: GitHub Pull request
        if (ref.matches("https://github\\.com/.*/.*/pull/.*")) {
            return gitHubRanger.parseGHPullRequest(ref);
        }

        // Case 3: GitHub Issues
        if (ref.matches("https://github\\.com/.*/.*/issues/.*")) {
            return gitHubRanger.parseGHIssue(ref);
        }

        // Case 4: GitLab commit
        if (ref.matches("https://gitlab\\.com/.*/.*/-/commit/.*")) {
            return gitLabRanger.parseGLCommit(ref);
        }

        // Case 5: GitLab issue
        if (ref.matches("https://gitlab\\.com/.*/.*/-/issues/.*")) {
            return gitLabRanger.parseGLIssue(ref);
        }

        // Case 6: GitLab merge request
        if (ref.matches("https://gitlab\\.com/.*/.*/-/merge_requests/.*")) {
            return gitLabRanger.parseGLMergeRequest(ref);
        }

        // Case 7: Git trackers
        if (ref.matches("http[s]://.*git\\..*\\.org/.*/commit/.*")) {
            return extraRanger.parseGitTrackerCommit(ref);
        }

        // Case 8: SVN Apache link
        if (ref.matches("https://svn\\.apache\\.org/.*revision=.*")) {
            return extraRanger.parseApacheSVNRevision(ref);
        }

        // Case 9: JIRA tickets
        if (ref.matches("https://(issues|jira)\\..*\\.org/(jira/)?browse/.*")) {
            return jiraRanger.parseJIRATicket(ref);
        }

        // Case 10: Bugzilla server
        if (ref.matches("https://(bugs|bugzilla)\\..*\\..*/show_bug\\.cgi\\?id=.*")) {
            return bugzillaRanger.parseBugzillaBug(ref);
        }

        // Case 11: Apache Mailing list
        if (ref.matches("https://lists\\.apache\\.org/thread\\.html/.*")) {
            return extraRanger.parseApacheMailThread(ref);
        }

        // Case 12: Bitbucket commit
        if (ref.matches("https://bitbucket\\.org/.*/.*/commits/.*")) {
            return bitBucketRanger.parseBitBucketCommit(ref);
        }

        // Case 13: Bitbucket PR
        if (ref.matches("https://bitbucket\\.org/.*/.*/pull-requests/.*")) {
            return bitBucketRanger.parseBitBucketPullRequest(ref);
        }

        // Case 14: Bitbucket Issue
        if (ref.matches("https://bitbucket\\.org/.*/.*/issues/.*")) {
            return bitBucketRanger.parseBitBucketIssue(ref);
        }

        return null;
    }

    /**
     * This method checks some of the edge cases.
     * @param ref - ref link
     * @return true if the ref is parsable
     */
    private static boolean isValid(String ref) {
        if (ref.contains("</a>"))    return false;
        if (ref.contains("</br>"))   return false;
        if (ref.endsWith("|") || ref.endsWith("]") || ref.endsWith("["))    return false;
        return true;
    }
}
