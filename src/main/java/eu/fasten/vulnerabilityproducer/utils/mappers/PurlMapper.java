/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package eu.fasten.vulnerabilityproducer.utils.mappers;

import com.google.gson.Gson;
import com.google.gson.reflect.TypeToken;
import eu.fasten.vulnerabilityproducer.utils.PatchFinder;
import eu.fasten.vulnerabilityproducer.utils.Vulnerability;
import org.apache.commons.io.FileUtils;
import org.joda.time.DateTime;
import org.joda.time.format.DateTimeFormat;
import org.joda.time.format.DateTimeFormatter;

import java.io.File;
import java.io.IOException;
import java.nio.charset.StandardCharsets;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

public class PurlMapper {
    VersionRanger versionRanger;
    PatchFinder patchFinder;
    DateTimeFormatter formatter = DateTimeFormat.forPattern("yyyy-MM-dd");
    // Base Repo URL --> Base PURL
    public HashMap<String, String> purlMappings;

    public PurlMapper(VersionRanger versionRanger, PatchFinder patchFinder, String pathToReposMaps) {
        this.versionRanger = versionRanger;
        this.patchFinder = patchFinder;
        this.purlMappings = loadReposMapFromMemory(pathToReposMaps);
    }

    private HashMap<String, String> loadReposMapFromMemory(String path) {
        var map = new File(path);
        String jsonString = null;
        if (map.exists()) {
            try {
                jsonString = FileUtils.readFileToString(map, StandardCharsets.UTF_8);
            } catch (IOException e) {
                e.printStackTrace();
            }
        }

        return new Gson().fromJson(jsonString, new TypeToken<HashMap<String, String>>() {}.getType());
    }

    /**
     * Given a vulnerability, it manipulates it to either store or infer mappings.
     * @param v - Vulnerability object
     */
    public void inferPurls(Vulnerability v) {
        var baseRepo = patchFinder.getBaseRepo(v);
        if (baseRepo == null)   return;
        DateTime patchedDate = getPatchDateVulnerability(v);

        // Try to infer purls if missing
        if (v.getPurls().size() == 0 && patchedDate != null) {
            if (purlMappings.get(baseRepo) != null) {
                var basePurl = purlMappings.get(baseRepo);
                if (basePurl != null) {
                    var inferredPurls = versionRanger.getPurlsBeforeDate(basePurl, patchedDate);
                    inferredPurls.forEach(v::addPurl);
                }
            }
        } else {
            // Store purl mappings
            String purlBase = getPurlBase(v);
            purlMappings.put(baseRepo, purlBase);
        }

        // Try to infer firstPatchedVersion if missing
        if (v.getFirstPatchedPurls().size() == 0 && patchedDate != null) {
            var basePurl = purlMappings.get(baseRepo);
            if (basePurl != null) {
                var firstPatchedPurl = versionRanger.getFirstPurlAfterDate(basePurl, patchedDate);
                v.getFirstPatchedPurls().add(firstPatchedPurl);
            }
        }
    }

    /**
     * Finds the patching date for the vulnerability.
     * Either the latest patch date or the published date of the vulnerability.
     * @param v - Vulnerability Object
     * @return DateTime
     */
    public DateTime getPatchDateVulnerability(Vulnerability v) {
        DateTime patchedDate = null;

        if (v.getPatches().size() > 0) {
            // Look for timestamp of the latest patch
            var dateWrapper = new Object(){ DateTime value; };
            dateWrapper.value = new DateTime(1950, 1, 1, 0, 0);
            v.getPatches().forEach(patch->{
                if (patch.getPatchDate() != null) {
                    DateTime date = formatter.parseDateTime(patch.getPatchDate());
                    if (date.isAfter(dateWrapper.value)) {
                        dateWrapper.value = date;
                    }
                }
            });
            patchedDate = dateWrapper.value;

        } else if (patchedDate == null) {
            if (v.getPublishedDate() == null)   return null;
            // Else: look for the published_date of the vulnerability
            patchedDate = formatter.parseDateTime(v.getPublishedDate());
        }

        return patchedDate;
    }

    /**
     * Retrieves the ecosystem and package name from the purls.
     * @param v - Vulnerability Object storing PURLs.
     * @return String
     */
    public String getPurlBase(Vulnerability v) {
        assert v.getPurls().size() > 0;
        var firstPurl = v.getPurls().iterator().next();
        var base = firstPurl.split("@")[0];
        assert base != null;
        return base;
    }
}
