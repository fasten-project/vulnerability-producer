/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package eu.fasten.vulnerabilityproducer.utils.mappers;

import com.google.gson.Gson;
import com.google.gson.reflect.TypeToken;
import eu.fasten.vulnerabilityproducer.utils.PatchFinder;
import eu.fasten.vulnerabilityproducer.utils.Vulnerability;
import eu.fasten.vulnerabilityproducer.utils.connections.*;
import org.apache.commons.io.FileUtils;
import org.joda.time.DateTime;
import org.joda.time.format.DateTimeFormat;
import org.joda.time.format.DateTimeFormatter;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.io.File;
import java.io.IOException;
import java.nio.charset.StandardCharsets;
import java.util.*;

public class PurlMapper {
    VersionRanger versionRanger;
    PatchFinder patchFinder;
    DateTimeFormatter formatter = DateTimeFormat.forPattern("yyyy-MM-dd");
    public HashMap<String, String> mavenMap;     // repo_url -> purl
    public HashMap<String, String> pypiMap;      // repo_url -> purl
    public HashMap<String, String> cpeMap;       // cpe_base -> repo_url
    public HashMap<String, String> debianCpeMap; // cpe_base -> purl
    public HashMap<String, String> cpe2purl;     // cpe_base -> purl
    public String strategy;
    private final Logger logger = LoggerFactory.getLogger(PurlMapper.class.getName());

    public PurlMapper(VersionRanger versionRanger,
                      PatchFinder patchFinder,
                      String pathToMaps,
                      String inferStrategy,
                      JavaHttpClient client) {
        this.versionRanger = versionRanger;
        this.patchFinder   = patchFinder;
        this.strategy      = inferStrategy;
        this.mavenMap      = loadReposMapFromMemory(pathToMaps + "repo_map_maven.json");
        this.pypiMap       = loadReposMapFromMemory(pathToMaps + "repo_map_pypi.json");
        this.cpeMap        = loadReposMapFromMemory(pathToMaps + "cpe_map_repos.json");
        this.debianCpeMap  = loadDebianCPEMap(client);
        this.cpe2purl      = createCpe2PurlMap(cpeMap, mavenMap, pypiMap, debianCpeMap);
    }

    /**
     * Loads the CPE list from Debian Security Advisories.
     * Also handles aliases of those CPEs.
     * @return cpe -> purl map.
     */
    public HashMap<String, String> loadDebianCPEMap(JavaHttpClient client) {
        var map = new HashMap<String, String>();
        var listUrl    = "https://salsa.debian.org/security-tracker-team/security-tracker/-/raw/master/data/CPE/list";
        var aliasesUrl = "https://salsa.debian.org/security-tracker-team/security-tracker/-/raw/master/data/CPE/aliases";

        var cpeList = client.sendGet(listUrl);
        Arrays.stream(cpeList.split("\n")).forEach(line -> {
            var info = line.split(";");
            var pkg  = info[0];
            var cpe  = info[1].replace("/", "2.3:");
            var purl = "pkg:deb/debian/" + pkg;
            map.put(cpe, purl);
        });

        var aliasesList = client.sendGet(aliasesUrl);
        var aliases = aliasesList.split("\n");
        for (int i = 0; i < aliases.length; i++) {
            var line = aliases[i];
            if (line.startsWith("cpe")) {
                var cpeGroup = new ArrayList<String>();
                while (line.startsWith("cpe")) {
                    cpeGroup.add(line.replace("/", "2.3:"));
                    i += 1;
                    line = aliases[i];
                }
                cpeGroup.forEach(cpeAlias -> {
                    if (map.containsKey(cpeAlias)) {
                        cpeGroup.forEach(cpe -> map.put(cpe, map.get(cpeAlias)));
                    }
                });
            }
        }

        return map;
    }

    private static HashMap<String, String> loadReposMapFromMemory(String path) {
        var map = new File(path);
        if (map.exists()) {
            try {
                var jsonString = FileUtils.readFileToString(map, StandardCharsets.UTF_8);
                return new Gson().fromJson(jsonString, new TypeToken<HashMap<String, String>>() {}.getType());
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
        return new HashMap<>();
    }

    /**
     * Initiates the cpe2purl map by intersecting the repos found corresponding to CPEs with the ecosystem mappings found.
     * @param cpeMap    - maps each CPE to the repo_url, where found
     * @param mavenMap  - maps each Maven PURL to the repo_url, where found
     * @param pypiMap   - maps each PyPI PURL to the repo_url, where found
     * @return - map between CPE and its repo_url, if an intersection if found
     */
    private HashMap<String, String> createCpe2PurlMap(HashMap<String, String> cpeMap,
                                                      HashMap<String, String> mavenMap,
                                                      HashMap<String, String> pypiMap,
                                                      HashMap<String, String> debianCpeMap) {
        var cpe2purl  = debianCpeMap;       // initialize to debian CPE list
        cpeMap.keySet().forEach(cpe -> {
            var repo = cpeMap.get(cpe);
            if (mavenMap.containsKey(repo)) cpe2purl.put(cpe, mavenMap.get(repo));
            if (pypiMap.containsKey(repo))  cpe2purl.put(cpe, pypiMap.get(repo));
        });
        return cpe2purl;
    }

    /**
     * Given a vulnerability, it manipulates it to either store or infer mappings.
     * @param v - Vulnerability object
     */
    public void inferPurls(Vulnerability v) {
        var baseRepo    = patchFinder.getBaseRepo(v);
        var baseCPEs    = v.getBaseCpes();
        var patchedDate = getPatchDateVulnerability(v);

        var hasPURLs    = v.getPurls().size() > 0;
        var hasCPEs     = baseCPEs != null && baseCPEs.size() > 0;
        var infoToInfer = baseRepo != null && (hasCPEs || patchedDate != null);

        var repo2purl = strategy.equals("both") || strategy.equals("repo2purl");
        var cpe2purl  = strategy.equals("both") || strategy.equals("cpe2purl");

        if ((infoToInfer || hasPURLs) && repo2purl) {
            repo2PurlInfer(v, patchedDate, baseRepo, baseCPEs);
        }

        if (hasCPEs && cpe2purl) {
            cpe2PurlInfer(v, patchedDate, baseCPEs);
        }
    }

    /**
     * REPO2PURL strategy implementation.
     * @param v - Vulnerability Object to infer/store information about
     * @param patchedDate - date in which the vulnerability was patched
     * @param baseRepo - base repo that was extracted from references
     */
    public void repo2PurlInfer(Vulnerability v,
                               DateTime patchedDate,
                               String baseRepo,
                               Set<String> cpes) {
        findPURLFromRepoMap(mavenMap, v, patchedDate, baseRepo, cpes);
        findPURLFromRepoMap(pypiMap,  v, patchedDate, baseRepo, cpes);
    }

    /**
     * CPE2PURL strategy implementation.
     * @param v - Vulnerability Object to infer/store information about.
     * @param patchedDate - date in which the vulnerability was patched.
     * @param cpes - set of base CPEs provided by NVD.
     */
    public void cpe2PurlInfer(Vulnerability v,
                              DateTime patchedDate,
                              Set<String> cpes) {
        // use cpe2purl only if repo2purl failed
        if (v.getPurls().size() == 0) {
            cpes.forEach(cpe -> {
                if (cpe2purl.containsKey(cpe)) {
                    var purl = cpe2purl.get(cpe);
                    var vulnerablePurls = versionRanger.getPurlsBeforeDate(purl, patchedDate);
                    vulnerablePurls.forEach(v::addPurl);
                }

                // special-treatment for Apache projects
                if (cpe.startsWith("cpe:2.3:a:apache:") && v.getPurls().size() == 0) {
                    var project = cpe.substring("cpe:2.3:a:apache:".length());
                    var basePurl = "pkg:maven/org.apache." + project + "/" + project;
                    var versions = versionRanger.getCPEVersions(v.getId()).get(cpe);
                    if (Objects.nonNull(versions)) {
                        versions.forEach(version -> v.addPurl(basePurl + "@" + version));
                    }
                    else {
                        logger.warn("Could not find versions for CPE: " + cpe);
                    }

                }
            });
        } else {
            var purlBase = getPurlBase(v);
            cpes.forEach(cpe -> cpe2purl.put(cpe, purlBase));
        }
    }

    /**
     * Helper method to inject stuff in the purl_maps and infer.
     * @param purlMap - map of the purls
     * @param v - Vulnerability Object
     * @param patchedDate - date of the patch
     * @param baseRepo - baseRepo extracted from the vulnerability
     * @param baseCPEs - CPEs extracted from NVD statement of the vulnerability.
     */
    public void findPURLFromRepoMap(HashMap<String, String> purlMap,
                                Vulnerability v,
                                DateTime patchedDate,
                                String baseRepo, Set<String> baseCPEs) {
        if (baseRepo == null)   return;

        if (v.getPurls().size() > 0) {
            purlMap.put(baseRepo, getPurlBase(v));
        }

        var basePurl = purlMap.get(baseRepo);
        if (basePurl == null)    return;
        if (v.getPurls().size() == 0 && baseCPEs != null) {
            baseCPEs.forEach(cpe -> {
                var versions = versionRanger.getCPEVersions(v.getId()).get(cpe);
                if (versions != null) {
                    versions.forEach(version -> v.addPurl(basePurl + "@" + version));
                }
            });
        }

        if (v.getPurls().size() == 0 && patchedDate != null) {
            var inferredPurls = versionRanger.getPurlsBeforeDate(basePurl, patchedDate);
            inferredPurls.forEach(v::addPurl);
        }

        if (v.getFirstPatchedPurls().size() == 0 && patchedDate != null) {
            var firstPatchedPurl = versionRanger.getFirstPurlAfterDate(basePurl, patchedDate);
            if (firstPatchedPurl != null) v.getFirstPatchedPurls().add(firstPatchedPurl);
        }
    }

    /**
     * Finds the patching date for the vulnerability.
     * Either the latest patch date or the published date of the vulnerability.
     * @param v - Vulnerability Object
     * @return DateTime
     */
    public DateTime getPatchDateVulnerability(Vulnerability v) {
        DateTime patchedDate = null;

        if (v.getPatches().size() > 0) {
            // Look for timestamp of the latest patch
            var dateWrapper = new Object(){ DateTime value; };
            dateWrapper.value = new DateTime(1950, 1, 1, 0, 0);
            v.getPatches().forEach(patch->{
                if (patch.getPatchDate() != null) {
                    DateTime date = formatter.parseDateTime(patch.getPatchDate());
                    if (date.isAfter(dateWrapper.value)) {
                        dateWrapper.value = date;
                    }
                }
            });
            patchedDate = dateWrapper.value;

        } else if (patchedDate == null) {
            if (v.getPublishedDate() == null)   return null;
            // Else: look for the published_date of the vulnerability
            patchedDate = formatter.parseDateTime(v.getPublishedDate());
        }

        return patchedDate;
    }

    /**
     * Retrieves the ecosystem and package name from the purls.
     * @param v - Vulnerability Object storing PURLs.
     * @return String
     */
    public String getPurlBase(Vulnerability v) {
        assert v.getPurls().size() > 0;
        var firstPurl = v.getPurls().iterator().next();
        var base = firstPurl.split("@")[0];
        assert base != null;
        return base;
    }
}
