/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package eu.fasten.vulnerabilityproducer.utils.mappers;

import com.google.gson.Gson;
import com.google.gson.reflect.TypeToken;
import eu.fasten.vulnerabilityproducer.utils.PatchFinder;
import eu.fasten.vulnerabilityproducer.utils.Vulnerability;
import org.apache.commons.io.FileUtils;
import org.joda.time.DateTime;
import org.joda.time.format.DateTimeFormat;
import org.joda.time.format.DateTimeFormatter;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.io.File;
import java.io.IOException;
import java.nio.charset.StandardCharsets;
import java.util.*;

public class PurlMapper {
    VersionRanger versionRanger;
    PatchFinder patchFinder;
    DateTimeFormatter formatter = DateTimeFormat.forPattern("yyyy-MM-dd");
    public HashMap<String, String> mavenMap;    // repo_url -> purl
    public HashMap<String, String> pypiMap;     // repo_url -> purl
    public HashMap<String, String> cpeMap;      // cpe_base -> repo_url
    public HashMap<String, String> cpe2purl;    // cpe_base -> purl
    public String strategy;
    private final Logger logger = LoggerFactory.getLogger(PurlMapper.class.getName());

    public PurlMapper(VersionRanger versionRanger,
                      PatchFinder patchFinder,
                      String pathToMaps,
                      String inferStrategy) {
        this.versionRanger = versionRanger;
        this.patchFinder   = patchFinder;
        this.strategy      = inferStrategy;
        this.mavenMap      = loadReposMapFromMemory(pathToMaps + "repo_map_maven.json");
        this.pypiMap       = loadReposMapFromMemory(pathToMaps + "repo_map_pypi.json");
        this.cpeMap        = loadReposMapFromMemory(pathToMaps + "cpe_map_repos.json");
        this.cpe2purl      = new HashMap<>();
    }

    private static HashMap<String, String> loadReposMapFromMemory(String path) {
        var map = new File(path);
        if (map.exists()) {
            try {
                var jsonString = FileUtils.readFileToString(map, StandardCharsets.UTF_8);
                return new Gson().fromJson(jsonString, new TypeToken<HashMap<String, String>>() {}.getType());
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
        return new HashMap<>();
    }

    /**
     * Given a vulnerability, it manipulates it to either store or infer mappings.
     * @param v - Vulnerability object
     */
    public void inferPurls(Vulnerability v) {
        var baseRepo    = patchFinder.getBaseRepo(v);
        var baseCPEs    = v.getBaseCpes();
        var patchedDate = getPatchDateVulnerability(v);

        var infoToInfer = patchedDate != null && (baseRepo != null || baseCPEs != null);
        var hasPURLs    = v.getPurls().size() > 0;
        var hasCPEs     = baseCPEs != null && baseCPEs.size() > 0;

        var repo2purl = strategy.equals("both") || strategy.equals("repo2purl");
        var cpe2purl  = strategy.equals("both") || strategy.equals("cpe2purl");

        if ((infoToInfer || hasPURLs) && repo2purl) {
            repo2PurlInfer(v, patchedDate, baseRepo, baseCPEs);
        }

        if (hasCPEs && cpe2purl) {
            cpe2PurlInfer(v, patchedDate, baseCPEs);
        }
    }

    /**
     * REPO2PURL strategy implementation.
     * @param v - Vulnerability Object to infer/store information about
     * @param patchedDate - date in which the vulnerability was patched
     * @param baseRepo - base repo that was extracted from references
     */
    public void repo2PurlInfer(Vulnerability v,
                               DateTime patchedDate,
                               String baseRepo,
                               Set<String> cpes) {
        // Look in the maps of the ecosystems
        findMatchedPurl(mavenMap, v, patchedDate, baseRepo);
        findMatchedPurl(pypiMap, v, patchedDate, baseRepo);

        // Look  in the cpe maps of repositories
        if (v.getPurls().size() == 0 &&
            cpes != null && cpes.size() > 0) {
            findPurlsFromCpes(v, cpes);
        }
    }

    /**
     * CPE2PURL strategy implementation.
     * @param v - Vulnerability Object to infer/store information about.
     * @param patchedDate - date in which the vulnerability was patched.
     * @param cpes - set of base CPEs provided by NVD.
     */
    public void cpe2PurlInfer(Vulnerability v,
                              DateTime patchedDate,
                              Set<String> cpes) {
        if (v.getPurls().size() == 0) {
            cpes.forEach(cpe -> {
                if (cpe2purl.containsKey(cpe)) {
                    var purl = cpe2purl.get(cpe);
                    var vulnerablePurls = versionRanger.getPurlsBeforeDate(purl, patchedDate);
                    vulnerablePurls.forEach(v::addPurl);
                }
            });
        } else {
            var purlBase = getPurlBase(v);
            cpes.forEach(cpe -> {
                cpe2purl.put(cpe, purlBase);
            });
        }
    }

    /**
     * Helper method to inject stuff in the purl_maps and infer.
     * @param purlMap - map of the purls
     * @param v - Vulnerability Object
     * @param patchedDate - date of the patch
     * @param baseRepo - baseRepo extracted from the vulnerability
     */
    public void findMatchedPurl(HashMap<String, String> purlMap,
                                Vulnerability v,
                                DateTime patchedDate,
                                String baseRepo) {
        // Try to infer purls if missing
        if (baseRepo == null)   return;
        if (v.getPurls().size() == 0 && patchedDate != null) {
            if (purlMap.get(baseRepo) != null) {
                var basePurl = purlMap.get(baseRepo);
                if (basePurl != null) {
                    var inferredPurls = versionRanger.getPurlsBeforeDate(basePurl, patchedDate);
                    inferredPurls.forEach(v::addPurl);
                }
            }
        } else {
            // Store purl mappings
            purlMap.put(baseRepo, getPurlBase(v));
        }

        // Try to infer firstPatchedVersion if missing
        if (v.getFirstPatchedPurls().size() == 0 && patchedDate != null) {
            var basePurl = purlMap.get(baseRepo);
            if (basePurl != null) {
                var firstPatchedPurl = versionRanger.getFirstPurlAfterDate(basePurl, patchedDate);
                if (firstPatchedPurl != null) v.getFirstPatchedPurls().add(firstPatchedPurl);
            }
        }
    }

    /**
     * Finds suitable PURLs from the mapping between CPEs and repository information.
     * @param vulnerability - Vulnerability Object to inject information.
     * @param cpes - base CPEs extracted and provided by NVD.
     */
    public void findPurlsFromCpes(Vulnerability vulnerability,
                                  Set<String> cpes) {
        cpes.forEach(cpe -> {
            if (cpeMap.containsKey(cpe)) {
                var repoUrl = cpeMap.get(cpe);
                if (mavenMap.containsKey(repoUrl)) {
                    var basePurl = mavenMap.get(repoUrl);
                    var versions = versionRanger.getCPEVersions(vulnerability.getId()).get(cpe);
                    if (versions != null) {
                        versions.forEach(version -> vulnerability.addPurl(basePurl + "@" + version));
                    }
                }
                if (pypiMap.containsKey(repoUrl)) {
                    var basePurl = pypiMap.get(repoUrl);
                    var versions = versionRanger.getCPEVersions(vulnerability.getId()).get(cpe);
                    if (versions != null) {
                        versions.forEach(version -> vulnerability.addPurl(basePurl + "@" + version));
                    }
                }
            }
        });

        // special treatment for Apache projects
        if (vulnerability.getPurls().size() == 0) {
            cpes.forEach(cpe -> {
                if (cpe.startsWith("cpe:2.3:a:apache:")) {
                    var project = cpe.substring("cpe:2.3:a:apache:".length());
                    var basePurl = "pkg:maven/org.apache." + project + "/" + project;
                    var versions = versionRanger.getCPEVersions(vulnerability.getId()).get(cpe);
                    if(Objects.nonNull(versions)) {
                        versions.forEach(version -> vulnerability.addPurl(basePurl + "@" + version));
                    }
                    else {
                        logger.warn("Could not find versions for CPE: " + cpe);
                    }

                }
            });
        }
    }

    /**
     * Finds the patching date for the vulnerability.
     * Either the latest patch date or the published date of the vulnerability.
     * @param v - Vulnerability Object
     * @return DateTime
     */
    public DateTime getPatchDateVulnerability(Vulnerability v) {
        DateTime patchedDate = null;

        if (v.getPatches().size() > 0) {
            // Look for timestamp of the latest patch
            var dateWrapper = new Object(){ DateTime value; };
            dateWrapper.value = new DateTime(1950, 1, 1, 0, 0);
            v.getPatches().forEach(patch->{
                if (patch.getPatchDate() != null) {
                    DateTime date = formatter.parseDateTime(patch.getPatchDate());
                    if (date.isAfter(dateWrapper.value)) {
                        dateWrapper.value = date;
                    }
                }
            });
            patchedDate = dateWrapper.value;

        } else if (patchedDate == null) {
            if (v.getPublishedDate() == null)   return null;
            // Else: look for the published_date of the vulnerability
            patchedDate = formatter.parseDateTime(v.getPublishedDate());
        }

        return patchedDate;
    }

    /**
     * Retrieves the ecosystem and package name from the purls.
     * @param v - Vulnerability Object storing PURLs.
     * @return String
     */
    public String getPurlBase(Vulnerability v) {
        assert v.getPurls().size() > 0;
        var firstPurl = v.getPurls().iterator().next();
        var base = firstPurl.split("@")[0];
        assert base != null;
        return base;
    }
}
