/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package eu.fasten.vulnerabilityproducer.utils.mappers;

import com.google.gson.Gson;
import com.google.gson.reflect.TypeToken;
import eu.fasten.vulnerabilityproducer.utils.PatchFinder;
import eu.fasten.vulnerabilityproducer.utils.Vulnerability;
import org.apache.commons.io.FileUtils;
import org.joda.time.DateTime;
import org.joda.time.format.DateTimeFormat;
import org.joda.time.format.DateTimeFormatter;

import java.io.File;
import java.io.IOException;
import java.nio.charset.StandardCharsets;
import java.util.*;

public class PurlMapper {
    VersionRanger versionRanger;
    PatchFinder patchFinder;
    DateTimeFormatter formatter = DateTimeFormat.forPattern("yyyy-MM-dd");
    public HashMap<String, String> mavenMap;    // repo_url -> purl
    public HashMap<String, String> pypiMap;     // repo_url -> purl
    public HashMap<String, String> cpeMap;      // cpe_base -> repo_url

    public PurlMapper(VersionRanger versionRanger, PatchFinder patchFinder, String pathToMaps) {
        this.versionRanger = versionRanger;
        this.patchFinder = patchFinder;
        this.mavenMap = loadReposMapFromMemory(pathToMaps + "repo_map_maven.json");
        this.pypiMap = loadReposMapFromMemory(pathToMaps + "repo_map_pypi.json");
        this.cpeMap = loadReposMapFromMemory(pathToMaps + "cpe_map_repos.json");
    }

    private static HashMap<String, String> loadReposMapFromMemory(String path) {
        var map = new File(path);
        String jsonString = null;
        if (map.exists()) {
            try {
                jsonString = FileUtils.readFileToString(map, StandardCharsets.UTF_8);
            } catch (IOException e) {
                e.printStackTrace();
            }
        }

        return new Gson().fromJson(jsonString, new TypeToken<HashMap<String, String>>() {}.getType());
    }

    /**
     * Given a vulnerability, it manipulates it to either store or infer mappings.
     * @param v - Vulnerability object
     */
    public void inferPurls(Vulnerability v) {
        var baseRepo = patchFinder.getBaseRepo(v);
        var patchedDate = getPatchDateVulnerability(v);

        findMatchedPurl(mavenMap, v, patchedDate, baseRepo);
        findMatchedPurl(pypiMap, v, patchedDate, baseRepo);

        if (v.getPurls().size() == 0) {
            findPurlsFromCpes(v);
        }
    }

    /**
     * Helper method to inject stuff in the purl_maps and infer.
     * @param purlMap - map of the purls
     * @param v - Vulnerability Object
     * @param patchedDate - date of the patch
     * @param baseRepo - baseRepo extracted from the vulnerability
     */
    public void findMatchedPurl(HashMap<String, String> purlMap,
                                Vulnerability v,
                                DateTime patchedDate,
                                String baseRepo) {
        // Try to infer purls if missing
        if (baseRepo == null)   return;
        if (v.getPurls().size() == 0 && patchedDate != null) {
            if (purlMap.get(baseRepo) != null) {
                var basePurl = purlMap.get(baseRepo);
                if (basePurl != null) {
                    var inferredPurls = versionRanger.getPurlsBeforeDate(basePurl, patchedDate);
                    inferredPurls.forEach(v::addPurl);
                }
            }
        } else {
            // Store purl mappings
            String purlBase = getPurlBase(v);
            purlMap.put(baseRepo, purlBase);
        }

        // Try to infer firstPatchedVersion if missing
        if (v.getFirstPatchedPurls().size() == 0 && patchedDate != null) {
            var basePurl = purlMap.get(baseRepo);
            if (basePurl != null) {
                var firstPatchedPurl = versionRanger.getFirstPurlAfterDate(basePurl, patchedDate);
                if (firstPatchedPurl != null) v.getFirstPatchedPurls().add(firstPatchedPurl);
            }
        }
    }

    /**
     * Finds the patching date for the vulnerability.
     * Either the latest patch date or the published date of the vulnerability.
     * @param v - Vulnerability Object
     * @return DateTime
     */
    public DateTime getPatchDateVulnerability(Vulnerability v) {
        DateTime patchedDate = null;

        if (v.getPatches().size() > 0) {
            // Look for timestamp of the latest patch
            var dateWrapper = new Object(){ DateTime value; };
            dateWrapper.value = new DateTime(1950, 1, 1, 0, 0);
            v.getPatches().forEach(patch->{
                if (patch.getPatchDate() != null) {
                    DateTime date = formatter.parseDateTime(patch.getPatchDate());
                    if (date.isAfter(dateWrapper.value)) {
                        dateWrapper.value = date;
                    }
                }
            });
            patchedDate = dateWrapper.value;

        } else if (patchedDate == null) {
            if (v.getPublishedDate() == null)   return null;
            // Else: look for the published_date of the vulnerability
            patchedDate = formatter.parseDateTime(v.getPublishedDate());
        }

        return patchedDate;
    }

    /**
     * Retrieves the ecosystem and package name from the purls.
     * @param v - Vulnerability Object storing PURLs.
     * @return String
     */
    public String getPurlBase(Vulnerability v) {
        assert v.getPurls().size() > 0;
        var firstPurl = v.getPurls().iterator().next();
        var base = firstPurl.split("@")[0];
        assert base != null;
        return base;
    }

    /**
     * Finds suitable PURLs corresponding to the
     * @param vulnerability - Vulnerability Object to inject information.
     */
    public void findPurlsFromCpes(Vulnerability vulnerability) {
        var cpes = vulnerability.getBaseCpes();
        cpes.forEach(cpe -> {
           if (cpeMap.containsKey(cpe)) {
               var repoUrl = cpeMap.get(cpe);
               if (mavenMap.containsKey(repoUrl)) {
                   var basePurl = mavenMap.get(repoUrl);
                   var versions = versionRanger.getCPEVersions(vulnerability.getId()).get(cpe);
                   versions.forEach(version -> vulnerability.addPurl(basePurl + "@" + version));
               }
               if (pypiMap.containsKey(repoUrl)) {
                   var basePurl = pypiMap.get(repoUrl);
                   var versions = versionRanger.getCPEVersions(vulnerability.getId()).get(cpe);
                   versions.forEach(version -> vulnerability.addPurl(basePurl + "@" + version));
               }
           }
        });

        if (vulnerability.getPurls().size() == 0) {
            cpes.forEach(cpe -> {
               if (cpe.startsWith("cpe:2.3:a:apache:")) {
                   var project = cpe.substring("cpe:2.3:a:apache:".length());
                   var basePurl = "pkg:maven/org.apache." + project + "/" + project;
                   var versions = versionRanger.getCPEVersions(vulnerability.getId()).get(cpe);
                   versions.forEach(version -> vulnerability.addPurl(basePurl + "@" + version));
               }
            });
        }
    }
}
