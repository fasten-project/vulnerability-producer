/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package eu.fasten.vulnerabilityproducer.utils.mappers;

import java.io.*;
import java.util.*;

import eu.fasten.vulnerabilityproducer.utils.connections.JavaHttpClient;
import kotlin.Pair;
import org.joda.time.DateTime;
import org.joda.time.format.DateTimeFormat;
import org.joda.time.format.DateTimeFormatter;
import org.joda.time.format.ISODateTimeFormat;
import org.json.JSONArray;
import org.json.JSONObject;
import org.jsoup.Jsoup;
import org.jsoup.select.Elements;

import java.util.stream.Collectors;

public class VersionRanger {

    JavaHttpClient client;
    // MAVEN encoding: pkg:maven/<group_id>/<artifact_id>
    // PYPI encoding: pkg:pypi/<package_name>
    // DEBIAN encoding: pkg:deb/debian/<package_name>
    public HashMap<String, List<Pair<String, DateTime>>> versionsMappings;
    public Comparator<Pair<String, DateTime>> versionSorter;

    /**
     * Constructor to inject the client
     *
     * @param client     - in order to perform requests
     * @param pathToJson - path to the JSON file to keep the data already gathered
     *                   e.g. "./src/main/resources/trackers/package_versions.json"
     */
    public VersionRanger(JavaHttpClient client, String pathToJson) {
        this.client = client;
        this.versionsMappings = loadVersionsFromJson(pathToJson);
        this.versionSorter = (o1, o2) -> {
            if (o1.getSecond() == null && o2.getSecond() == null) {
                return o1.getFirst().compareTo(o2.getFirst());
            }
            if (o1.getSecond() == null) {
                return -1;
            }
            if (o2.getSecond() == null) {
                return 1;
            }
            return o1.getSecond().compareTo(o2.getSecond());
        };
    }

    /**
     * Loads the versions already found from the JSON.
     *
     * @param path of the JSON file where the versions are stored
     * @return hashmap with the versions already stored
     */
    public HashMap<String, List<Pair<String, DateTime>>> loadVersionsFromJson(String path) {
        File file = new File(path);
        if (file.exists()) {
            try {
                FileInputStream fileIn = new FileInputStream(path);
                ObjectInputStream in = new ObjectInputStream(fileIn);
                var versions = (HashMap<String, List<Pair<String, DateTime>>>) in.readObject();
                in.close();
                fileIn.close();
                return versions;
            } catch (FileNotFoundException e) {
                e.printStackTrace();
            } catch (IOException e) {
                e.printStackTrace();
            } catch (ClassNotFoundException e) {
                e.printStackTrace();
            }
        }
        return new HashMap<>();
    }

    /**
     * Retrieves all available versions of a specific package.
     *
     * @param mvnPackage - String that identifies the package to retrieve versions from
     *                   The following format is supported: "pkg:maven/<group_id>/<artifact_id>"
     */
    public List<Pair<String, DateTime>> injectVersionsMavenPackage(String mvnPackage) {
        List<Pair<String, DateTime>> versions = new ArrayList<>();
        StringBuilder sb = new StringBuilder("https://repo1.maven.org/maven2/");
        var splitter = mvnPackage.split("/");
        var groupId = splitter[1].strip();
        var artifactId = splitter[2].strip();
        Arrays.stream(groupId.split("\\.")).forEach(x -> sb.append(x).append("/"));
        sb.append(artifactId + "");

        DateTimeFormatter formatter = DateTimeFormat.forPattern("yyyy-mm-dd");
        var url = sb.toString();
        var html = client.sendGet(url);
        if (html.contains("404 Not Found")) html = client.sendGet(url.substring(0, url.length() - 19) + "-clients");
        if (html.contains("404 Not Found")) return versions;

        var doc = Jsoup.parse(html);
        var content = doc.select("pre").first();
        Arrays.stream(content.toString().split("\n"))
                .filter(s -> s.trim().endsWith("-"))
                .forEach(s -> {
                    var version = s.substring(s.indexOf('"') + 1, s.indexOf('/'));
                    var dateString = s.split("\\s++")[3];
                    if (dateString.matches("\\d{4}-\\d{2}-\\d{2}")) {
                        var timestamp = formatter.parseDateTime(dateString);
                        versions.add(new Pair<>(version, timestamp));
                    }
                });
        Collections.sort(versions, versionSorter);
        versionsMappings.put(mvnPackage, versions);
        return versions;
    }

    /**
     * Retrieves all available versions of a specific package.
     *
     * @param pypiPackage - String that identifies the package to retrieve versions from
     *                    The following format is supported: "pkg:pypi/<package_name>"
     */
    public List<Pair<String, DateTime>> injectVersionsPyPiPackage(String pypiPackage) {
        var versions = new ArrayList<Pair<String, DateTime>>();
        var formatter = DateTimeFormat.forPattern("yyyy-mm-dd'T'HH:mm:ss");
        var pypiInfoLink = "https://pypi.org/pypi/" + pypiPackage.substring(9).strip() + "/json";

        var details = client.sendGet(pypiInfoLink);
        if (details.contains("We looked everywhere but couldn't find this page") || details.contains("404 Not Found")) {
            return versions;
        };

        var obj = new JSONObject(details);
        var releases = obj.getJSONObject("releases");
        releases.keySet().forEach(key -> {
            var info = releases.getJSONArray(key);
            if (info.length() == 0) versions.add(new Pair(key, null));
            else {
                var pkgInfo = (JSONObject) info.get(0);
                var timestamp = pkgInfo.get("upload_time") != null ? formatter.parseDateTime(pkgInfo.get("upload_time").toString()) : null;
                versions.add(new Pair(key, timestamp));
            }
        });

        Collections.sort(versions, versionSorter);
        versionsMappings.put(pypiPackage, versions);
        return versions;
    }

    /**
     * Retrieves all available versions of a specific package.
     *
     * @param debPackage - String that identifies the package to retrieve versions from
     *                   The following format is supported: "/deb/debian/<pkg_name>"
     */
    public List<String> injectVersionsHTMLDebianPackage(String debPackage) {
        org.jsoup.nodes.Document doc = null;
        try {
            // TODO: Switch to JSON with machine readable version --> faster
            String url = "https://snapshot.debian.org/package/" + debPackage.substring(15) + "/";
            String rawHTML = client.sendGet(url);
            doc = Jsoup.parse(rawHTML);
            Elements versionsList = doc.select("li a[href]");
            List<String> versions = new ArrayList<>();
            for (org.jsoup.nodes.Element version : versionsList) {
                versions.add(version.text());
            }
            versions = versions.subList(2, versions.size());
            // Reverse the list
            Collections.reverse(versions);
            return versions;
        } catch (Exception e) {
            e.printStackTrace();
        }
        return null;
    }

    /**
     * Retrieves all available versions of a specific package.
     *
     * @param debPackage - String that identifies the package to retrieve versions from
     *                   The following format is supported: "pkg:deb/debian/<pkg_name>"
     */
    public List<Pair<String, DateTime>> injectVersionsDebianPackage(String debPackage) {
        var versions = new ArrayList<Pair<String, DateTime>>();
        var url = "https://sources.debian.org/api/src/" + debPackage.substring(15) + "/";
        var rawJSON = client.sendGet(url);
        // Check if 404 or non-existing
        if (rawJSON == null ||
                rawJSON.contains("\"error\":404") ||
                rawJSON.contains("<!doctype html>"))  return versions;

        JSONObject obj = new JSONObject(rawJSON);
        JSONArray versionsArray = obj.getJSONArray("versions");

        for (int i = 0, size = versionsArray.length(); i < size; i++) {
            JSONObject versionObj = versionsArray.getJSONObject(i);
            List<Object> releases = ((JSONArray) versionObj.get("suites")).toList();
            if (releases.contains("buster")) {
                versions.add(new Pair(versionObj.get("version"), null));
            }
        }

        // Sort the list
        versions.sort(versionSorter);
        versionsMappings.put(debPackage, versions);
        return versions;
    }

    /**
     * Retrieves list of versions for the given GEM.
     * @param gem - pkg:gem/<gem_to_get>
     * @return list of pairs where each version id is met with a date of release
     */
    public List<Pair<String, DateTime>> injectVersionsRubyGem(String gem) {
        List<Pair<String, DateTime>> versions = new ArrayList<>();
        String url = "https://rubygems.org/api/v1/versions/" + gem.substring(8) + ".json";
        String rawJSON = client.sendGet(url);
        // Check if 404 or non-existing
        if (rawJSON == null ||
                rawJSON.contains("This rubygem could not be found."))  return versions;

        JSONArray versionsArray = new JSONArray(rawJSON);

        for (int i = 0; i < versionsArray.length(); i++) {
            var versionObj = versionsArray.getJSONObject(i);
            var version = versionObj.get("number").toString();
            var date = new DateTime(versionObj.get("created_at"));
            versions.add(new Pair<>(version, date));
        }

        // Sort the list
        versions.sort(versionSorter);
        versionsMappings.put(gem, versions);
        return versions;
    }

        /**
         * This method takes an encoded version range of a vulnerable range and all the versions of a package.
         * It returns a list of versions that are vulnerable
         *
         * @param encodedRangeVersions <=0.0.2 - all versions less or equal to 0.0.2 are vulnerable
         *                             <=1.4.7,1.4 - versions from 1.4 to 1.4.7 are vulnerable
         *                             ==2.1.4 - the exact version is vulnerable
         * @param allVersions          - list all versions of a package
         * @return a list of vulnerable versions
         */
    public List<String> getVulnerableVersionsYAML(List<String> encodedRangeVersions, List<String> allVersions) {
        List<String> vulnerableVersions = new ArrayList<>();
        if (allVersions == null) {
            return vulnerableVersions;
        }
        for (String encodedRange : encodedRangeVersions) {
            // Parse the first two characters, they should be either "<=" or "=="
            String operator = encodedRange.substring(0, 2);
            if (operator.equals("==")) {
                vulnerableVersions.add(encodedRange.substring(2));
            }
            if (operator.equals("<=")) {
                String endpointsRange = encodedRange.substring(2);
                String[] endpoints = endpointsRange.split(",");
                if (endpoints.length > 1) {
                    String startingFrom = endpoints[1];
                    String endingAt = endpoints[0];

                    int indexStart = allVersions.indexOf(startingFrom);
                    int indexEnd = allVersions.indexOf(endingAt);

                    if (indexStart >= 0 && indexEnd >= 0 && indexEnd > indexStart) {
                        for (int i = indexStart; i <= indexEnd; i++) {
                            vulnerableVersions.add(allVersions.get(i));
                        }
                    }
                } else {
                    String endingAt = endpoints[0];
                    int indexEnd = allVersions.indexOf(endingAt);
                    if (indexEnd >= 0) {
                        for (int i = 0; i <= indexEnd; i++) {
                            vulnerableVersions.add(allVersions.get(i));
                        }
                    }
                }
            }
        }
        return vulnerableVersions;
    }

    /**
     * Returns a vulnerable range of versions based on the encoding given.
     *
     * @param encodedRangeVersions
     * @param allVersions
     * @return
     */
    public List<String> getVulnerableVersionsJSON(String[] encodedRangeVersions, List<String> allVersions) {
        List<String> vulnerableVersions = new ArrayList<>();
        // 1 is for vulnerable and 0 for not vulnerable
        int[] affectedVersions = new int[allVersions.size()];
        for (String range : encodedRangeVersions) {
            String regex = "[0-9]";
            String operator = range.split(regex)[0].strip();
            String version = range.substring(operator.length()).strip();
            if (operator.equals("==") || operator.equals("=")) {
                if (allVersions.indexOf(version) >= 0) {
                    affectedVersions[allVersions.indexOf(version)] = 1;
                }
            }
            if (operator.equalsIgnoreCase("<=")) {
                int startIndex = allVersions.indexOf(version);
                if (startIndex >= 0) {
                    for (int i = 0; i <= startIndex; i++) {
                        affectedVersions[i] = 1;
                    }
                }
            }
            if (operator.equals("<")) {
                int startIndex = allVersions.indexOf(version) - 1;
                if (startIndex >= 0) {
                    for (int i = 0; i <= startIndex; i++) {
                        affectedVersions[i] = 1;
                    }
                }
            }
            if (operator.equals(">=")) {
                int startIndex = allVersions.indexOf(version);
                if (startIndex >= 0) {
                    for (int i = startIndex; i < affectedVersions.length; i++) {
                        affectedVersions[i] = 1;
                    }
                }
            }
            if (operator.equals(">")) {
                int startIndex = allVersions.indexOf(version) + 1;
                if (startIndex >= 0) {
                    for (int i = startIndex; i < affectedVersions.length; i++) {
                        affectedVersions[i] = 1;
                    }
                }
            }
        }
        for (int i = 0; i < affectedVersions.length; i++) {
            if (affectedVersions[i] == 1) {
                vulnerableVersions.add(allVersions.get(i));
            }
        }
        return vulnerableVersions;
    }

    /**
     * Returns a list of versions that are vulnerable.
     * OVAL only expresses less than version x
     * @param lessThanVersion - threshold versions below which the vulnerability propagates
     * @param versions - list of all the versions of the package
     * @return list of vulnerable versions
     */
    public List<String> getVulnerableVersionsOVAL(String lessThanVersion, List<String> versions) {
        var indexVulnerable = versions.indexOf(lessThanVersion);
        return indexVulnerable > 0 ? versions.subList(0, indexVulnerable) : new ArrayList<>();
    }

    /**
     *
     * @param gem
     * @param safeVersionRanges
     */
    public List<String> getVulnerablePURLsRuby(String gem, List<String> safeVersionRanges) {
        var safeVersions = new ArrayList<String>();
        var allVersions = getVersions("pkg:gem/" + gem);

        for (String range : safeVersionRanges) {
            switch(range.substring(0, 2)) {
                case "~>":
                    var safePrefix = range.substring(3, range.lastIndexOf("."));
                    allVersions.stream().filter(v -> v.startsWith(safePrefix)).forEach(safeVersions::add);
                    break;
                case ">=":
                    var versionStartEqual = allVersions.indexOf(range.substring(3));
                    if (versionStartEqual > 0) {
                        for (int i = versionStartEqual; i < allVersions.size(); i++) {
                            safeVersions.add(allVersions.get(i));
                        }
                    }
                    break;
                case "> ":
                    var versionStart = allVersions.indexOf(range.substring(2));
                    if (versionStart > 0) {
                        for (int i = versionStart + 1; i < allVersions.size(); i++) {
                            safeVersions.add(allVersions.get(i));
                        }
                    }
                    break;
                case "< ":
                    var versionsLessThan = allVersions.indexOf(range.substring(2));
                    if (versionsLessThan > 0) {
                        for (int i = versionsLessThan - 1; i >= 0; i--) {
                            safeVersions.add(allVersions.get(i));
                        }
                    }
                    break;
                case "<=":
                    var versionsLessThanEqual = allVersions.indexOf(range.substring(3));
                    if (versionsLessThanEqual > 0) {
                        for (int i = versionsLessThanEqual; i >= 0; i--) {
                            safeVersions.add(allVersions.get(i));
                        }
                    }
                    break;
                default:
                    // code block
            }
        }
        var vulnerableVersions = new ArrayList<>(allVersions);
        vulnerableVersions.removeAll(safeVersions);
        return vulnerableVersions.stream().map(v -> "pkg:gem/" + gem + "@" + v).collect(Collectors.toList());
    }

    /**
     * Given a base PURL and a date
     * @param basePurl - package coordinates
     * @param date - date to find purls before
     * @return - String list with all the purls found before the indicated date
     */
    public List<String> getPurlsBeforeDate(String basePurl, DateTime date) {
        if (date == null)   return new ArrayList<>();
        if (versionsMappings.get(basePurl) == null)
            this.getVersions(basePurl.substring(4));
        if (versionsMappings.get(basePurl) == null)  return new ArrayList<>();

        return versionsMappings.get(basePurl).stream()
                .filter(version -> version.getSecond().isBefore(date))
                .map(pair -> basePurl + "@" + pair.getFirst())
                .collect(Collectors.toList());
    }

    /**
     * Finds the first PURL after a given date.
     * @param basePurl - base PURL of the package
     * @param date - DateTime of the patch date
     * @return firstPatched PURL
     */
    public String getFirstPurlAfterDate(String basePurl, DateTime date) {
        if (date == null)   return null;
        if (versionsMappings.get(basePurl) == null)
            this.getVersions(basePurl.substring(4));
        if (versionsMappings.get(basePurl) == null)  return null;

        Pair<String, DateTime> firstPatchedVersion = null;

        for (Pair<String, DateTime> version : versionsMappings.get(basePurl)) {
            if (firstPatchedVersion == null) {
                if (version.getSecond().isAfter(date))
                    firstPatchedVersion = version;
            } else {
                if (version.getSecond().isAfter(date)
                        && version.getSecond().compareTo(firstPatchedVersion.getSecond()) < 0) {
                    firstPatchedVersion = version;
                }
            }
        }

        return firstPatchedVersion != null ? basePurl + "@" + firstPatchedVersion.getFirst() : null;
    }

    /**
     * Helper to build PURLs based on this specification: https://github.com/package-url/purl-spec
     * maven: /maven/<group_id>/<artifact_id>@version
     *
     * @param javaPgk            - object containing information about the package
     * @param vulnerableVersions - list of vulnerable versions
     * @return a set of purls
     */
    public List<String> buildPURLSMaven(YAMLHandler.JavaPgkMapper javaPgk, List<String> vulnerableVersions) {
        var purls = new ArrayList<String>();
        var groupId = javaPgk.groupId;
        var artifactId = javaPgk.artifactId;
        vulnerableVersions.forEach(v -> purls.add("pkg:maven/" + groupId + "/" + artifactId + "@" + v));
        return purls;
    }

    /**
     * Helper to build PURLs based on this specification: https://github.com/package-url/purl-spec
     * pypi: /pypi/<package_name>@version
     *
     * @param pythonPgk          - object containing information about the package
     * @param vulnerableVersions - list of vulnerable versions
     * @return a set of purls
     */
    public List<String> buildPURLSPypi(YAMLHandler.PythonPgkMapper pythonPgk, List<String> vulnerableVersions) {
        var purls = new ArrayList<String>();
        var packageName = pythonPgk.name;
        vulnerableVersions.forEach(v -> purls.add("pkg:pypi/" + packageName + "@" + v));
        return purls;
    }

    /**
     * Method returns versions of the package encoded in input.
     * If the versions were previously retrieved it uses those, otherwise retrieves them from source.
     *
     * @param pgk - encoding of the package to retrieve information from:
     *            maven: /maven/<group_id>/<artifact_id>
     *            pypi: /pypi/<package_name>
     *            debian: /deb/debian/<package_name>
     * @return list of versions of the package
     */
    public List<String> getVersions(String pgk) {
        if (versionsMappings.get(pgk) != null) {
            return versionsMappings.get(pgk).stream().map(Pair::getFirst).collect(Collectors.toList());
        }
        if (pgk.matches("pkg:maven/.*")) {
            return injectVersionsMavenPackage(pgk).stream().map(Pair::getFirst).collect(Collectors.toList());
        }
        if (pgk.matches("pkg:pypi/.*")) {
            return injectVersionsPyPiPackage(pgk).stream().map(Pair::getFirst).collect(Collectors.toList());
        }
        if (pgk.matches("pkg:deb/debian/.*")) {
            return injectVersionsDebianPackage(pgk).stream().map(Pair::getFirst).collect(Collectors.toList());
        }
        if (pgk.matches("pkg:gem/.*")) {
            return injectVersionsRubyGem(pgk).stream().map(Pair::getFirst).collect(Collectors.toList());
        }
        return null;
    }

    /**
     * @param pathToWrite - path to write the file to
     *                    Writes all the mappings gathered so far in the file packages.versions.
     *                    e.g. "./analyzer/vulnerability-plugin/src/main/resources/trackers/package_versions.json"
     */
    public void writeVersions(String pathToWrite) {
        try {
            FileOutputStream fileOut =
                    new FileOutputStream(pathToWrite);
            ObjectOutputStream out = new ObjectOutputStream(fileOut);
            out.writeObject(versionsMappings);
            out.close();
            fileOut.close();
        } catch (IOException i) {
            i.printStackTrace();
        }
    }

    /**
     * In the grand schema of the plugin, this method will be called before the daily update.
     * This allows to have all the versions up-to-date
     */
    public void updateMappings() {
        Set<String> keys = versionsMappings.keySet();
        for (String pgk : keys) {
            if (pgk.matches("pkg:maven/*")) {
                injectVersionsMavenPackage(pgk);
            }
            if (pgk.matches("pkg:pypi/*")) {
                injectVersionsPyPiPackage(pgk);
            }
            if (pgk.matches("pkg:deb/*")) {
                injectVersionsDebianPackage(pgk);
            }
        }
    }
}
