/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package eu.fasten.vulnerabilityproducer.utils.mappers;

import java.util.*;

import com.fasterxml.jackson.core.type.TypeReference;
import com.fasterxml.jackson.databind.ObjectMapper;
import eu.fasten.vulnerabilityproducer.utils.connections.JavaHttpClient;
import org.json.JSONArray;
import org.json.JSONObject;
import org.jsoup.Jsoup;
import org.jsoup.select.Elements;
import org.w3c.dom.*;
import org.xml.sax.InputSource;

import javax.xml.parsers.*;
import java.io.*;

public class VersionRanger {

    JavaHttpClient client;
    ObjectMapper mapper;
    // MAVEN encoding: pkg:maven/<group_id>/<artifact_id>
    // PYPI encoding: pkg:pypi/<package_name>
    // DEBIAN encoding: pkg:deb/debian/<package_name>
    public HashMap<String, List<String>> versionsMappings;

    /**
     * Constructor to inject the client
     *
     * @param client     - in order to perform requests
     * @param pathToJson - path to the JSON file to keep the data already gathered
     *                   e.g. "./src/main/resources/trackers/package_versions.json"
     */
    public VersionRanger(JavaHttpClient client, String pathToJson) {
        this.client = client;
        this.mapper = new ObjectMapper();
        this.versionsMappings = loadVersionsFromJson(pathToJson);
    }

    /**
     * Loads the versions already found from the JSON.
     *
     * @param path of the JSON file where the versions are stored
     * @return hashmap with the versions already stored
     */
    public HashMap<String, List<String>> loadVersionsFromJson(String path) {
        File versions = new File(path);
        if (versions.exists()) {
            try {
                return mapper.readValue(new File(
                        versions.getPath()), new TypeReference<HashMap<String, List<String>>>() {
                });
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
        return new HashMap<>();
    }

    /**
     * Retrieves all available versions of a specific package.
     *
     * @param mvnPackage - String that identifies the package to retrieve versions from
     *                   The following format is supported: "/maven/<group_id>/<artifact_id>"
     */
    public List<String> injectVersionsMavenPackage(String mvnPackage) {
        String[] splitter = mvnPackage.split("/");
        String groupId = splitter[2].strip();
        String artifactId = splitter[3].strip();
        String[] groupSplits = groupId.split("\\.");
        StringBuilder sb = new StringBuilder("https://repo1.maven.org/maven2/");
        for (String gsplit : groupSplits) {
            sb.append(gsplit + "/");
        }
        sb.append(artifactId + "/");
        sb.append("maven-metadata.xml");
        String mvnUrl = sb.toString();
        List<String> versions = new ArrayList<>();
        try {
            String details = client.sendGet(mvnUrl);
            if (details.contains("404 Not Found")) {
                // This works for some apache packages
                String clientsUrl = mvnUrl.substring(0, mvnUrl.length() - 19) + "-clients/maven-metadata.xml";
                details = client.sendGet(clientsUrl);
                if (details.contains("404 Not Found")) {
                    return null;
                }
            }
            DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();
            DocumentBuilder builder = factory.newDocumentBuilder();
            Document document = builder.parse(new InputSource(new StringReader(details)));
            Element root = document.getDocumentElement();
            NodeList versionsNodes = root.getElementsByTagName("version");
            for (int i = 0; i < versionsNodes.getLength(); i++) {
                String version = versionsNodes.item(i).getTextContent();
                versions.add(version);
            }
            versionsMappings.put(mvnPackage, versions);
            return versions;
        } catch (Exception e) {
            e.printStackTrace();
        }
        return null;
    }

    /**
     * Retrieves all available versions of a specific package.
     *
     * @param pypiPackage - String that identifies the package to retrieve versions from
     *                    The following format is supported: "/pypi/<package_name>"
     */
    public List<String> injectVersionsPyPiPackage(String pypiPackage) {
        String[] splitter = pypiPackage.split("/");
        List<String> versions = new ArrayList<>();
        String packageName = splitter[2].strip();
        try {
            String details = client.sendGet("https://pypi.org/pypi/" + packageName + "/json");
            if (details.contains("We looked everywhere but couldn't find this page") || details.contains("404 Not Found")) {
                return null;
            }
            JSONObject obj = new JSONObject(details);
            // TreeSet keeps versions sorted
            TreeSet<String> releases = new TreeSet(obj.getJSONObject("releases").keySet());
            for (String s : releases) {
                versions.add(s);
            }
            Collections.sort(versions);
            versionsMappings.put(pypiPackage, versions);
            return versions;
        } catch (Exception e) {
            e.printStackTrace();
        }
        return null;
    }

    /**
     * Retrieves all available versions of a specific package.
     *
     * @param debPackage - String that identifies the package to retrieve versions from
     *                   The following format is supported: "/deb/debian/<pkg_name>"
     */
    public List<String> injectVersionsHTMLDebianPackage(String debPackage) {
        org.jsoup.nodes.Document doc = null;
        try {
            // TODO: Switch to JSON with machine readable version --> faster
            String url = "https://snapshot.debian.org/package/" + debPackage.substring(12) + "/";
            String rawHTML = client.sendGet(url);
            doc = Jsoup.parse(rawHTML);
            Elements versionsList = doc.select("li a[href]");
            List<String> versions = new ArrayList<>();
            for (org.jsoup.nodes.Element version : versionsList) {
                versions.add(version.text());
            }
            versions = versions.subList(2, versions.size());
            // Reverse the list
            Collections.reverse(versions);
            versionsMappings.put(debPackage, versions);
            return versions;
        } catch (Exception e) {
            e.printStackTrace();
        }
        return null;
    }

    /**
     * Retrieves all available versions of a specific package.
     *
     * @param debPackage - String that identifies the package to retrieve versions from
     *                   The following format is supported: "/deb/debian/<pkg_name>"
     */
    public List<String> injectVersionsDebianPackage(String debPackage) {
        try {
            List<String> versions = new ArrayList<>();
            String url = "https://sources.debian.org/api/src/" + debPackage.substring(12) + "/";
            String rawJSON = client.sendGet(url);
            // Check if 404 or non-existing
            if (rawJSON.contains("\"error\":404"))  return versions;
            if (rawJSON.contains("<!doctype html>"))    return versions;

            JSONObject obj = new JSONObject(rawJSON);
            JSONArray versionsArray = obj.getJSONArray("versions");

            for (int i = 0, size = versionsArray.length(); i < size; i++) {
                JSONObject versionObj = versionsArray.getJSONObject(i);
                List<Object> releases = (List<Object>) ((JSONArray) versionObj.get("suites")).toList();
                if (releases.contains("buster")) {
                    versions.add((String) versionObj.get("version"));
                }
            }

            // Sort the list
            Collections.sort(versions);
            versionsMappings.put(debPackage, versions);
            return versions;
        } catch (Exception e) {
            e.printStackTrace();
        }
        return null;
    }

    /**
     * This method takes an encoded version range of a vulnerable range and all the versions of a package.
     * It returns a list of versions that are vulnerable
     *
     * @param encodedRangeVersions <=0.0.2 - all versions less or equal to 0.0.2 are vulnerable
     *                             <=1.4.7,1.4 - versions from 1.4 to 1.4.7 are vulnerable
     *                             ==2.1.4 - the exact version is vulnerable
     * @param allVersions          - list all versions of a package
     * @return a list of vulnerable versions
     */
    public List<String> getVulnerableVersionsYAML(List<String> encodedRangeVersions, List<String> allVersions) {
        List<String> vulnerableVersions = new ArrayList<>();
        if (allVersions == null) {
            return vulnerableVersions;
        }
        for (String encodedRange : encodedRangeVersions) {
            // Parse the first two characters, they should be either "<=" or "=="
            String operator = encodedRange.substring(0, 2);
            if (operator.equals("==")) {
                vulnerableVersions.add(encodedRange.substring(2));
            }
            if (operator.equals("<=")) {
                String endpointsRange = encodedRange.substring(2);
                String[] endpoints = endpointsRange.split(",");
                if (endpoints.length > 1) {
                    String startingFrom = endpoints[1];
                    String endingAt = endpoints[0];

                    int indexStart = allVersions.indexOf(startingFrom);
                    int indexEnd = allVersions.indexOf(endingAt);

                    if (indexStart >= 0 && indexEnd >= 0 && indexEnd > indexStart) {
                        for (int i = indexStart; i <= indexEnd; i++) {
                            vulnerableVersions.add(allVersions.get(i));
                        }
                    }
                } else {
                    String endingAt = endpoints[0];
                    int indexEnd = allVersions.indexOf(endingAt);
                    if (indexEnd >= 0) {
                        for (int i = 0; i <= indexEnd; i++) {
                            vulnerableVersions.add(allVersions.get(i));
                        }
                    }
                }
            }
        }
        return vulnerableVersions;
    }

    /**
     * Returns a vulnerable range of versions based on the encoding given.
     *
     * @param encodedRangeVersions
     * @param allVersions
     * @return
     */
    public List<String> getVulnerableVersionsJSON(String[] encodedRangeVersions, List<String> allVersions) {
        List<String> vulnerableVersions = new ArrayList<>();
        // 1 is for vulnerable and 0 for not vulnerable
        int[] affectedVersions = new int[allVersions.size()];
        for (String range : encodedRangeVersions) {
            String regex = "[0-9]";
            String operator = range.split(regex)[0].strip();
            String version = range.substring(operator.length()).strip();
            if (operator.equals("==") || operator.equals("=")) {
                if (allVersions.indexOf(version) >= 0) {
                    affectedVersions[allVersions.indexOf(version)] = 1;
                }
            }
            if (operator.equalsIgnoreCase("<=")) {
                int startIndex = allVersions.indexOf(version);
                if (startIndex >= 0) {
                    for (int i = 0; i <= startIndex; i++) {
                        affectedVersions[i] = 1;
                    }
                }
            }
            if (operator.equals("<")) {
                int startIndex = allVersions.indexOf(version) - 1;
                if (startIndex >= 0) {
                    for (int i = 0; i <= startIndex; i++) {
                        affectedVersions[i] = 1;
                    }
                }
            }
            if (operator.equals(">=")) {
                int startIndex = allVersions.indexOf(version);
                if (startIndex >= 0) {
                    for (int i = startIndex; i < affectedVersions.length; i++) {
                        affectedVersions[i] = 1;
                    }
                }
            }
            if (operator.equals(">")) {
                int startIndex = allVersions.indexOf(version) + 1;
                if (startIndex >= 0) {
                    for (int i = startIndex; i < affectedVersions.length; i++) {
                        affectedVersions[i] = 1;
                    }
                }
            }
        }
        for (int i = 0; i < affectedVersions.length; i++) {
            if (affectedVersions[i] == 1) {
                vulnerableVersions.add(allVersions.get(i));
            }
        }
        return vulnerableVersions;
    }

    /**
     * Returns a list of versions that are vulnerable.
     * OVAL only expresses less than version x
     * @param lessThanVersion - threshold versions below which the vulnerability propagates
     * @param versions - list of all the versions of the package
     * @return list of vulnerable versions
     */
    public List<String> getVulnerableVersionsOVAL(String lessThanVersion, List<String> versions) {
        List<String> dummy = new ArrayList<>();
        int indexVulnerable = versions.indexOf(lessThanVersion);
        if (indexVulnerable > 0) {
            return versions.subList(0, indexVulnerable);
        } else {
            return dummy;
        }
    }

    /**
     * Helper to build PURLs based on this specification: https://github.com/package-url/purl-spec
     * maven: /maven/<group_id>/<artifact_id>@version
     *
     * @param javaPgk            - object containing information about the package
     * @param vulnerableVersions - list of vulnerable versions
     * @return a set of purls
     */
    public HashSet<String> buildPURLSMaven(YAMLHandler.JavaPgkMapper javaPgk, List<String> vulnerableVersions) {
        HashSet<String> purls = new HashSet<>();
        String groupId = javaPgk.groupId;
        String artifactId = javaPgk.artifactId;
        for (String version : vulnerableVersions) {
            String purl = "pgk:maven/" + groupId + "/" + artifactId + "@" + version;
            purls.add(purl);
        }
        return purls;
    }

    /**
     * Helper to build PURLs based on this specification: https://github.com/package-url/purl-spec
     * pypi: /pypi/<package_name>@version
     *
     * @param pythonPgk          - object containing information about the package
     * @param vulnerableVersions - list of vulnerable versions
     * @return a set of purls
     */
    public HashSet<String> buildPURLSPypi(YAMLHandler.PythonPgkMapper pythonPgk, List<String> vulnerableVersions) {
        HashSet<String> purls = new HashSet<>();
        String packageName = pythonPgk.name;
        for (String version : vulnerableVersions) {
            String purl = "pgk:pypi/" + packageName + "@" + version;
            purls.add(purl);
        }
        return purls;
    }

    /**
     * Method returns versions of the package encoded in input.
     * If the versions were previously retrieved it uses those, otherwise retrieves them from source.
     *
     * @param pgk - encoding of the package to retrieve information from:
     *            maven: /maven/<group_id>/<artifact_id>
     *            pypi: /pypi/<package_name>
     *            debian: /deb/debian/<package_name>
     * @return list of versions of the package
     */
    public List<String> getVersions(String pgk) {
        if (versionsMappings.get(pgk) != null) {
            return versionsMappings.get(pgk);
        }
        if (pgk.matches("/maven/.*")) {
            return injectVersionsMavenPackage(pgk);
        }
        if (pgk.matches("/pypi/.*")) {
            return injectVersionsPyPiPackage(pgk);
        }
        if (pgk.matches("/deb/debian/.*")) {
            return injectVersionsDebianPackage(pgk);
        }
        return null;
    }

    /**
     * @param pathToWrite - path to write the file to
     *                    Writes all the mappings gathered so far in the file packages.versions.
     *                    e.g. "./analyzer/vulnerability-plugin/src/main/resources/trackers/package_versions.json"
     */
    public void writeVersions(String pathToWrite) {
        ObjectMapper mapper = new ObjectMapper();
        try {
            mapper.writeValue(new File(pathToWrite), versionsMappings);
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    /**
     * In the grand schema of the plugin, this method will be called before the daily update.
     * This allows to have all the versions up-to-date
     */
    public void updateMappings() {
        Set<String> keys = versionsMappings.keySet();
        for (String pgk : keys) {
            if (pgk.matches("/maven/*")) {
                injectVersionsMavenPackage(pgk);
            }
            if (pgk.matches("/pypi/*")) {
                injectVersionsPyPiPackage(pgk);
            }
            if (pgk.matches("/deb/*")) {
                injectVersionsDebianPackage(pgk);
            }
        }
    }
}
