package eu.fasten.vulnerabilityproducer.utils.parsers;

import eu.fasten.vulnerabilityproducer.utils.Vulnerability;
import eu.fasten.vulnerabilityproducer.utils.connections.JavaHttpClient;
import org.apache.commons.io.FilenameUtils;
import org.apache.commons.io.IOUtils;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.io.File;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.nio.file.Paths;
import java.util.Enumeration;
import java.util.HashMap;
import java.util.concurrent.ConcurrentHashMap;
import java.util.zip.ZipEntry;
import java.util.zip.ZipFile;

public class CVEFixesParser implements VulnerabilityParser {

    private final JavaHttpClient client;
    private final String mnt;
    private final String DBURL = "https://zenodo.org/record/4476564/files/CVEfixes_v1.0.0.zip?download=1";
    private final Logger logger = LoggerFactory.getLogger(ExtraParser.class.getName());

    public CVEFixesParser(JavaHttpClient client, String mnt) {
        this.client = client;
        this.mnt = mnt;
    }

    public ConcurrentHashMap<String, Vulnerability> injectDBFile() {
        var datasetFile = new File(mnt + "/datasets/CVE_Fixes_v1.0.0/");

        if (!datasetFile.exists()) {
            // Download the DB file and extract the zip file
            var dbFileInputStream =  client.getFile(DBURL);
            client.writeFile(datasetFile.getPath(), dbFileInputStream);
            logger.info("Extracting the dataset's zip file");
             unzipDBFile(datasetFile);
        }
        else {
            logger.info("Found an extracted version of the CVEFixes dataset on the disk");
        }
        return extractCVEs(datasetFile);
    }

    private ConcurrentHashMap<String, Vulnerability> extractCVEs(File datasetFile) {
        ConcurrentHashMap<String, Vulnerability> vulnerabilities = new ConcurrentHashMap<>();
        try {
            var rawCves = NVDParser.parseCVEZip(new File(Paths.get(datasetFile.getPath(), "CVEfixes-1.0.1", "Data", "nvd-2021-06-09.jsonl.gz").toString()));
            rawCves.parallelStream().forEach((c) -> {
                Vulnerability v = NVDParser.parseVulnerability(c);
                vulnerabilities.put(v.getId(), v);
            });
            logger.info("Extracted CVEs from the CVEFixes dataset");
            return vulnerabilities;
        } catch (IOException e) {
            e.printStackTrace();
        }
        return vulnerabilities;
    }

    private void unzipDBFile(File file) {
        try (ZipFile zipFile = new ZipFile(file)) {
            Enumeration<? extends ZipEntry> entries = zipFile.entries();
            while (entries.hasMoreElements()) {
                ZipEntry entry = entries.nextElement();
                File entryDest = new File(FilenameUtils.removeExtension(file.getPath()), entry.getName());
                if (entry.isDirectory()) {
                    entryDest.mkdirs();
                } else {
                    entryDest.getParentFile().mkdirs();
                    try (InputStream in = zipFile.getInputStream(entry);
                         OutputStream out = new FileOutputStream(entryDest)) {
                        IOUtils.copy(in, out);
                    }
                }
            }
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    @Override
    public HashMap<String, Vulnerability> getVulnerabilities(boolean updatesOnly) {
        return new HashMap<>(injectDBFile());
    }
}
