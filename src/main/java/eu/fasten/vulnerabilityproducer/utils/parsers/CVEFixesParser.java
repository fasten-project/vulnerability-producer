package eu.fasten.vulnerabilityproducer.utils.parsers;

import eu.fasten.vulnerabilityproducer.utils.Vulnerability;
import eu.fasten.vulnerabilityproducer.utils.connections.JavaHttpClient;
import org.apache.commons.io.IOUtils;
import org.owasp.dependencycheck.utils.DownloadFailedException;
import org.owasp.dependencycheck.utils.Downloader;
import org.owasp.dependencycheck.utils.ResourceNotFoundException;
import org.owasp.dependencycheck.utils.Settings;
import org.owasp.dependencycheck.utils.TooManyRequestsException;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.io.File;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.net.MalformedURLException;
import java.net.URL;
import java.nio.file.Paths;
import java.util.Enumeration;
import java.util.HashMap;
import java.util.Properties;
import java.util.concurrent.ConcurrentHashMap;
import java.util.zip.ZipEntry;
import java.util.zip.ZipFile;

public class CVEFixesParser implements VulnerabilityParser {

    private final JavaHttpClient client;
    private final String mnt;
    // CVEFixes is licensed under CCA 4.0
    // https://zenodo.org/record/4476564
    private final String DBURL = "https://lima.ewi.tudelft.nl/vuln_data/CVEfixes_v1.0.0.zip";
    private final Logger logger = LoggerFactory.getLogger(CVEFixesParser.class.getName());
    private final Downloader downloader = new Downloader(new Settings(new Properties()));

    public CVEFixesParser(JavaHttpClient client, String mnt) {
        this.client = client;
        this.mnt = mnt;
    }

    public ConcurrentHashMap<String, Vulnerability> injectDBFile() {
        var datasetFolder = new File(mnt + "/datasets/CVEfixes_v1.0.0/");
        var datasetFile = new File(mnt + "/datasets/CVEfixes_v1.0.0.zip");

        if (!datasetFolder.exists()) {
            // Download the DB file and extract the zip file
            logger.info("Downloading the CVEFixes dataset...");
            try {
                downloader.fetchFile(new URL(DBURL), datasetFile);
            } catch (DownloadFailedException | TooManyRequestsException | ResourceNotFoundException | MalformedURLException e) {
                e.printStackTrace();
                throw new RuntimeException("Could not download the CVEFixes dataset" + e);
            }
            logger.info("Extracting the dataset's zip file");
            unzipDBFile(datasetFile);
            datasetFile.delete();
        }
        else {
            logger.info("Found an extracted version of the CVEFixes dataset on the disk");
        }
        return extractCVEs(datasetFolder);
    }

    private ConcurrentHashMap<String, Vulnerability> extractCVEs(File datasetFile) {
        ConcurrentHashMap<String, Vulnerability> vulnerabilities = new ConcurrentHashMap<>();
        try {
            var rawCves = NVDParser.parseCVEZip(new File(Paths.get(datasetFile.getPath(), "Data", "nvd-2021-06-09.jsonl.gz").toString()));
            rawCves.parallelStream().forEach((c) -> {
                Vulnerability v = NVDParser.parseVulnerability(c);
                vulnerabilities.put(v.getId(), v);
            });
            logger.info("Extracted CVEs from the CVEFixes dataset");
            return vulnerabilities;
        } catch (IOException e) {
            e.printStackTrace();
        }
        return vulnerabilities;
    }

    private void unzipDBFile(File file) {
        try (ZipFile zipFile = new ZipFile(file)) {
            Enumeration<? extends ZipEntry> entries = zipFile.entries();
            while (entries.hasMoreElements()) {
                ZipEntry entry = entries.nextElement();
                File entryDest = new File(file.getParentFile(), entry.getName());
                if (entry.isDirectory()) {
                    entryDest.mkdirs();
                } else {
                    entryDest.getParentFile().mkdirs();
                    try (InputStream in = zipFile.getInputStream(entry);
                         OutputStream out = new FileOutputStream(entryDest)) {
                        IOUtils.copy(in, out);
                    }
                }
            }
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    @Override
    public HashMap<String, Vulnerability> getVulnerabilities(boolean updatesOnly) {
        return new HashMap<>(injectDBFile());
    }
}
