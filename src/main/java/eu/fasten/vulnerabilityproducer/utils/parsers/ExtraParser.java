/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package eu.fasten.vulnerabilityproducer.utils.parsers;

import com.opencsv.CSVReader;
import eu.fasten.vulnerabilityproducer.utils.Vulnerability;
import eu.fasten.vulnerabilityproducer.utils.connections.GitHelper;
import eu.fasten.vulnerabilityproducer.utils.connections.JavaHttpClient;
import eu.fasten.vulnerabilityproducer.utils.mappers.Severity;
import eu.fasten.vulnerabilityproducer.utils.mappers.VersionRanger;
import eu.fasten.vulnerabilityproducer.utils.mappers.YAMLHandler;

import org.json.JSONArray;
import org.json.JSONObject;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.yaml.snakeyaml.Yaml;
import org.yaml.snakeyaml.constructor.Constructor;
import org.apache.commons.io.FileUtils;

import java.io.*;
import java.nio.charset.StandardCharsets;
import java.nio.file.DirectoryStream;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.*;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

public class ExtraParser implements VulnerabilityParser {

    private HashMap<String, Vulnerability> vulnerabilities;
    private JavaHttpClient client;
    private VersionRanger versionRanger;
    private GitHelper gitHelper;
    private final Logger logger = LoggerFactory.getLogger(ExtraParser.class.getName());

    /**
     * The same client is injected in both ExtraParser and the VersionRanger.
     * This will help with Mocking when testing later.
     *
     * @param client - JavaHttpClient
     */
    public ExtraParser(JavaHttpClient client, VersionRanger versionRanger) {
        this.vulnerabilities = new HashMap<>();
        this.versionRanger = versionRanger;
        this.client = client;
        this.gitHelper = new GitHelper();
    }

    public VersionRanger getVersionRanger() {
        return versionRanger;
    }

    public HashMap<String, Vulnerability> getVulnerabilitiesInMemory() {
        return vulnerabilities;
    }

    public void setGitHelper(GitHelper gitHelper) {
        this.gitHelper = gitHelper;
    }

    /**
     * Injects information in the dictionary from the dataset provided by pyupio on Github.
     * Find more information here: https://github.com/pyupio/safety-db
     * The JSON Feed is updated monthly.
     */
    public void injectFromSafetyDB() {
        try {
            String insecureJson = client.sendGet("https://raw.githubusercontent.com/pyupio/safety-db/master/data/insecure_full.json");

            JSONObject jsonObject = new JSONObject(insecureJson.trim());
            Iterator<String> keys = jsonObject.keys();

            while (keys.hasNext()) {
                String key = keys.next();
                JSONArray listVulns = (JSONArray) jsonObject.get(key);
                Iterator<Object> vulnIterator = listVulns.iterator();
                while (vulnIterator.hasNext()) {
                    JSONObject vulnObject = (JSONObject) vulnIterator.next();
                    var cveIds = vulnObject.get("cve");
                    if (!cveIds.toString().equals("null")) {
                        // There are multiple CVE-IDs
                        if (cveIds.toString().contains(",")) {
                            String[] cves = cveIds.toString().split(",\\s?");
                            for (String cve : cves) {
                                Vulnerability parsedVuln = injectInfoHelper(key, cve, vulnObject);
                                insertVulnerability(parsedVuln);
                            }
                        } else {
                            // There is only one CVE-ID
                            var cveId = cveIds;
                            Vulnerability parsedVuln = injectInfoHelper(key, cveId.toString(), vulnObject);
                            insertVulnerability(parsedVuln);
                        }
                    } else {
                        // There is only PyUp-id
                        String pyupId = (String) vulnObject.get("id");
                        Vulnerability parsedVuln = injectInfoHelper(key, pyupId, vulnObject);
                        insertVulnerability(parsedVuln);
                    }
                }
            }
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    /**
     * Looks for a vulnerability that was already in the map.
     * If found, it updates it, else puts a new entry.
     *
     * @param v - Vulnerability to insert in the map.
     */
    private void insertVulnerability(Vulnerability v) {
        logger.info("Parsed Vulnerability with ID - " + v.getId());
        if (vulnerabilities.get(v.getId()) == null) {
            vulnerabilities.put(v.getId(), v);
        } else {
            Vulnerability existing = vulnerabilities.get(v.getId());
            existing.merge(v);
            vulnerabilities.put(v.getId(), existing);
        }
    }

    /**
     * Takes a CVE-ID and a JSONObject from safetydb specification and injects information in the dictionary.
     *
     * @param packageName - name of the package to retrieve vulnerable versions from.
     * @param id          - id of the vulnerability
     * @param vulnObject  - JSON Object containing the information related to the package and its vulnerabilities.
     */
    private Vulnerability injectInfoHelper(String packageName, String id, JSONObject vulnObject) {
        Vulnerability v = new Vulnerability(id);
        v.setDescription((String) vulnObject.get("advisory"));
        List<String> versionsPgk = versionRanger.getVersions("/pypi/" + packageName);
        String[] ranges = vulnObject.get("v").toString().split(",");
        if (versionsPgk != null) {
            List<String> vulnerableVersions = versionRanger.getVulnerableVersionsJSON(ranges, versionsPgk);
            for (String vulnerableVersion : vulnerableVersions) {
                v.addPurl("pgk:pypi/" + packageName + "@" + vulnerableVersion);
            }
        }
        return v;
    }

    /**
     * This method can pull information from https://github.com/fabric8-analytics/cvedb
     * and https://github.com/victims/victims-cve-db
     * The bot that creates PRs is by far the best mapper between NVD and package coordinates.
     * Unfortunately, the repo is not very maintained and that means PRs are not merged so often.
     * Example of inputs:
     * https://github.com/victims/victims-cve-db.git
     * https://github.com/fabric8-analytics/cvedb.git
     */
    public void injectYAMLSource(String repoUrl) {
        String repoName = repoUrl.split("/")[4].split("\\.")[0];
        String cloneDirectoryPath = "./src/main/resources/datasets/" + repoName;
        File checkDirAlreadyExists = new File(cloneDirectoryPath);
        if (checkDirAlreadyExists.exists()) {
            try {
                FileUtils.deleteDirectory(new File(cloneDirectoryPath));
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
        // Step 1: Clone the repo
        gitHelper.cloneRepo(repoUrl, cloneDirectoryPath, null);
        // Step 2: Parse the information in the repo
        parseYAMLInformation(cloneDirectoryPath);
    }

    /**
     * Helper function to Parse YAML format information
     *
     * @param cloneDirectoryPath
     */
    public void parseYAMLInformation(String cloneDirectoryPath) {
        // Parse Java Database
        Yaml javaYaml = new Yaml(new Constructor(YAMLHandler.JavaVulnMapper.class));
        String[] years = new File(cloneDirectoryPath + "/database/java").list();
        for (String year : years) {
            try {
                String pathToYearDir = cloneDirectoryPath + "/database/java/" + year;
                Set<String> files = listFilesUsingDirectoryStream(pathToYearDir);
                for (String file : files) {
                    logger.info("Parsing java statement file " + file + " from year " + year);
                    String content = Files.readString(Paths.get(pathToYearDir + "/" + file));
                    YAMLHandler.JavaVulnMapper javaPgk = javaYaml.load(content);
                    // Check if you already have versions from the VersionRanger
                    List<String> versionsPgk = versionRanger.getVersions("/maven/" +
                            javaPgk.affected.get(0).groupId + "/" +
                            javaPgk.affected.get(0).artifactId);
                    // Find vulnerable versions and create purls in the mappings
                    List<String> vulnerableVersions = versionRanger.getVulnerableVersionsYAML(javaPgk.affected.get(0).version, versionsPgk);
                    HashSet<String> vulnerablePURL = versionRanger.buildPURLSMaven(javaPgk.affected.get(0), vulnerableVersions);
                    Vulnerability v = YAMLHandler.buildJavaVulnerabilityFromYaml(javaPgk, vulnerablePURL);
                    insertVulnerability(v);
                }
            } catch (IOException e) {
                System.out.println("Could not list any files for year: " + year);
            }
        }
        // Parse Python Database
        Yaml pythonYaml = new Yaml(new Constructor(YAMLHandler.PythonVulnMapper.class));
        String[] yearsPython = new File(cloneDirectoryPath + "/database/python").list();
        for (String year : yearsPython) {
            try {
                String pathToYearDir = cloneDirectoryPath + "/database/python/" + year;
                Set<String> files = listFilesUsingDirectoryStream(pathToYearDir);
                for (String file : files) {
                    logger.info("Parsing python statement file " + file + " from year " + year);
                    String content = Files.readString(Paths.get(pathToYearDir + "/" + file));
                    YAMLHandler.PythonVulnMapper pythonPgk = pythonYaml.load(content);
                    // Check if you already have versions from the VersionRanger
                    List<String> versionsPgk = versionRanger.getVersions("/pypi/" + pythonPgk.affected.get(0).name);
                    // Find vulnerable versions and create purls in the mappings
                    List<String> vulnerableVersions = versionRanger.getVulnerableVersionsYAML(pythonPgk.affected.get(0).version, versionsPgk);
                    HashSet<String> vulnerablePURL = versionRanger.buildPURLSPypi(pythonPgk.affected.get(0), vulnerableVersions);
                    Vulnerability v = YAMLHandler.buildPythonVulnerabilityFromYaml(pythonPgk, vulnerablePURL);
                    insertVulnerability(v);
                }
            } catch (IOException e) {
                System.out.println("Could not list any files for year: " + year);
            }
        }
    }

    /**
     * Helper function to get all the files in a directory.
     *
     * @param dir path to the directory to list files
     * @return Set of Strings where each string is a file name of a YAML file with a vulnerability
     * @throws IOException
     */
    public Set<String> listFilesUsingDirectoryStream(String dir) throws IOException {
        Set<String> fileList = new HashSet<>();
        try (DirectoryStream<Path> stream = Files.newDirectoryStream(Paths.get(dir))) {
            for (Path path : stream) {
                if (!Files.isDirectory(path)) {
                    if (!path.getFileName().toString().equals(".gitkeep")) {
                        fileList.add(path.getFileName()
                                .toString());
                    }
                }
            }
        } catch (IOException e) {
            e.printStackTrace();
        }
        return fileList;
    }

    /**
     * Parses all the additional files in the resources/datasets folder.
     * https://github.com/SAP/project-kb/blob/master/MSR2019/dataset/vulas_db_msr2019_release.csv
     */
    public void injectMSR2019SAP() {
        try {
            String extraCommitsCsv = client.sendGet("https://raw.githubusercontent.com/SAP/project-kb/master/MSR2019/dataset/vulas_db_msr2019_release.csv");
            try {
                CSVReader reader = new CSVReader(new StringReader(extraCommitsCsv));
                String[] line;
                while ((line = reader.readNext()) != null) {
                    String cveId = line[0];
                    String commitUrl = line[1] + "/commit/" + line[2];
                    Vulnerability v = new Vulnerability(cveId);
                    v.addPatchLink(commitUrl);
                    insertVulnerability(v);
                }
            } catch (IOException e) {
                e.printStackTrace();
            }
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    /**
     * Injects the information contained in the project-kb repo on GH.
     */
    public void injectSAPProjectKb(String cloneDir) {
        // Step 1: Clone the repo
        var repoUrl = "https://github.com/SAP/project-kb.git";
        String cloneDirectoryPath = cloneDir + "/project-kb";
        File checkDirAlreadyExists = new File(cloneDirectoryPath);
        if (checkDirAlreadyExists.exists()) {
            try {
                FileUtils.deleteDirectory(new File(cloneDirectoryPath));
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
        try {
            cloneDirectoryPath = gitHelper.cloneRepo(repoUrl,
                    cloneDirectoryPath,
                    "origin/vulnerability-data");

            // Step 3: Get all the directories in the statements dir
            File[] directories = new File(cloneDirectoryPath + "/statements").listFiles(File::isDirectory);
            Yaml yaml = new Yaml(new Constructor(YAMLHandler.SAPVulnMapper.class));
            for (File cveDir : directories) {
                // Read the statement yaml and parse it
                logger.info("Parsing statement file for " + cveDir.getName());
                String content = Files.readString(Paths.get(cveDir.getPath() + "/statement.yaml"));
                YAMLHandler.SAPVulnMapper vulnStatement = yaml.load(content);
                // Step 4: Inject all the statements
                insertVulnerability(vulnStatement.translateFromStatement());
            }
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    /**
     * This method injects into the vulnerabilities of the ExtraParser.
     * Taking information from the MSR2020 dataset collection.
     * @param datasetPath - String of the path to look where to download/read data
     * "./src/main/resources/datasets/all_c_cpp_release2.0.csv"
     */
    public void injectMSR2020CPP(String datasetPath) {
        File datasetFile = new File(datasetPath);
        String data = null;
        if (datasetFile.exists()) {
            try {
                data = FileUtils.readFileToString(datasetFile, StandardCharsets.UTF_8);
                logger.info("Found MSR2020 CPP dataset from memory");
            } catch (IOException e) {
                logger.error("Error while loading MSR2020 CPP file from memory");
                e.printStackTrace();
            }
        } else {
            // Download raw content
            try {
                logger.info("Downloading raw CSV file from MSR2020");
                data = client.sendGet("https://raw.githubusercontent.com/ZeoVan/MSR_20_Code_vulnerability_CSV_Dataset/master/all_c_cpp_release2.0.csv");
                try (PrintWriter out = new PrintWriter(datasetPath)) {
                    if (data != null) {
                        logger.info("Writing dataset to memory");
                        out.write(data);
                    }
                } catch (FileNotFoundException e) {
                    logger.error("Error while writing the dataset to memory");
                    e.printStackTrace();
                }
            } catch (Exception e) {
                e.printStackTrace();
            }
        }

        int counter = 0;

        // Parse the data
        String[] splits = data.split("\n\\d{1,4},");
        for (String s : splits) {
            Vulnerability v = parseMSR2020Blob(s);
            if (v != null) {
                insertVulnerability(v);
                if (v.getPatchLinks().size() > 0)   counter += 1;
            }
        }
        logger.info("Found a total of " + counter + " vulnerability in the CPP dataset from MSR2020");
    }

    /**
     * Parses the blob of information from the dataset.
     * @param s - String containing the information to be parsed.
     * @return - Vulnerability Object, null if no patch link is found
     */
    public Vulnerability parseMSR2020Blob(String s) {
        // Extract the information of each of the splits
        String[] halves = s.split("\"\\{\"\"sha\"\":");
        String[] firstPart = halves[0].split(",");
        if (firstPart[2].startsWith("CVE")) {
            var cveId = firstPart[2];
            var severity = firstPart[5];
            var date = firstPart[8];
            var stringBlob = String.join(",", Arrays.copyOfRange(firstPart, 9, firstPart.length - 1));
            stringBlob = stringBlob.substring(0, Math.min(1000, stringBlob.length()));
            Matcher matcher = Pattern.compile("https://github\\.com/.*/.*/commit/.*,").matcher(stringBlob);
            String patchLink = null;
            while (matcher.find()) {
                patchLink = matcher.group().split(",")[0];
            }
            Vulnerability v = new Vulnerability(cveId);
            v.setPublishedDate(date);
            v.addPatchLink(patchLink);
            v.setSeverity(Severity.translate(severity));
            return v;
        } else {
            return null;
        }
    }

    /**
     * Looks at old and new ones and returns a hashmap of the changed or new ones parsed.
     *
     * @param oldVulnerabilities - map of old vulnerabilities
     * @param newVulnerabilities - map of new vulnerabilities containing (also) old
     * @return difference of the two
     */
    public HashMap<String, Vulnerability> getUpdatedVulnerabilities(HashMap<String, Vulnerability> oldVulnerabilities,
                                                                     HashMap<String, Vulnerability> newVulnerabilities) {
        Iterator<String> iter = newVulnerabilities.keySet().iterator();

        while (iter.hasNext()) {
            String id = iter.next();
            if (oldVulnerabilities.get(id) != null) {
                if (oldVulnerabilities.get(id).equals(newVulnerabilities.get(id))) {
                    iter.remove();
                }
            }
        }

        logger.info("Parsed " + newVulnerabilities.size() + " from ExtraSources");
        return newVulnerabilities;
    }

    /**
     * Method that injects everything and returns the HashMap with the Vulnerabilities.
     *
     * @return hashmap of vulnerabilities
     */
    public HashMap<String, Vulnerability> getVulnerabilities() {
        logger.info("Parsing database from Safety-DB");
        injectFromSafetyDB();
        logger.info("Injecting extra commits from MSR2019 - SAP Dataset");
        injectMSR2019SAP();
        logger.info("Injecting statements from project-kb - SAP Research");
        injectSAPProjectKb("./src/main/resources/datasets");
        logger.info("Injecting extra commits from MSR2020 - CPP Dataset");
        injectMSR2020CPP("./src/main/resources/datasets/all_c_cpp_release2.0.csv");
        logger.info("Parsing database from cvedb");
        injectYAMLSource("https://github.com/edoardolanzini/cvedb.git");
        logger.info("Parsing database from victims-cve-db");
        injectYAMLSource("https://github.com/victims/victims-cve-db.git");
        logger.info("Parsing database from ruby-advisory-db");
        injectRubyAdvisory("./src/main/resources/datasets");
        logger.info("Parsed " + vulnerabilities.size() + " vulnerabilities from Extra Sources");
        return vulnerabilities;
    }

    public void injectRubyAdvisory(String cloneDir) {
        var repoUrl = "https://github.com/rubysec/ruby-advisory-db";
        var cloneDirectoryPath = cloneDir + "/ruby-advisory-db";
        var checkDirAlreadyExists = new File(cloneDirectoryPath);
        if (checkDirAlreadyExists.exists()) {
            try {
                FileUtils.deleteDirectory(new File(cloneDirectoryPath));
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
        try {
            cloneDirectoryPath = gitHelper.cloneRepo(repoUrl,
                    cloneDirectoryPath, null);

            var directories = new File(cloneDirectoryPath + "/gems").listFiles(File::isDirectory);
            var yaml = new Yaml(new Constructor(YAMLHandler.RubyAdvisoryMapper.class));
            assert directories != null;
            for (File gem : directories) {
                logger.info("Parsing statements for GEM: " + gem.getName());
                var statements = listFilesUsingDirectoryStream(gem.getPath());
                for (String statement : statements) {
                    var content = Files.readString(Paths.get(gem.getPath() + "/" + statement));
                    YAMLHandler.RubyAdvisoryMapper vulnStatement = yaml.load(content);
                    insertVulnerability(vulnStatement.translateFromStatement(versionRanger));
                }
            }
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    public HashMap<String, Vulnerability> getUpdates() {
        HashMap<String, Vulnerability> oldVulnerabilities = (HashMap<String, Vulnerability>) vulnerabilities.clone();
        logger.info("Parsing database from Safety-DB");
        injectFromSafetyDB();
        logger.info("Parsing database from cvedb");
        injectYAMLSource("https://github.com/edoardolanzini/cvedb.git");
        logger.info("Parsing database from victims-cve-db");
        injectYAMLSource("https://github.com/victims/victims-cve-db.git");
        return getUpdatedVulnerabilities(oldVulnerabilities, vulnerabilities);
    }
}