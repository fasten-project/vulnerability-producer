/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package eu.fasten.vulnerabilityproducer.utils.parsers;

import com.opencsv.CSVReader;
import eu.fasten.vulnerabilityproducer.utils.Vulnerability;
import eu.fasten.vulnerabilityproducer.utils.connections.GitHelper;
import eu.fasten.vulnerabilityproducer.utils.connections.JavaHttpClient;
import eu.fasten.vulnerabilityproducer.utils.mappers.Severity;
import eu.fasten.vulnerabilityproducer.utils.mappers.VersionRanger;
import eu.fasten.vulnerabilityproducer.utils.mappers.YAMLHandler;
import eu.fasten.vulnerabilityproducer.utils.mappers.YAMLHandler.SAPVulnMapper;
import org.apache.commons.io.FileUtils;
import org.json.JSONObject;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.yaml.snakeyaml.Yaml;
import org.yaml.snakeyaml.constructor.Constructor;
import org.yaml.snakeyaml.error.YAMLException;

import java.io.File;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.io.PrintWriter;
import java.io.StringReader;
import java.nio.charset.StandardCharsets;
import java.nio.file.DirectoryStream;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.List;
import java.util.Objects;
import java.util.Set;
import java.util.concurrent.Callable;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.Executors;
import java.util.regex.Pattern;

public class ExtraParser implements VulnerabilityParser {

    private final ConcurrentHashMap<String, Vulnerability> vulnerabilities;
    private final JavaHttpClient client;
    private final VersionRanger versionRanger;
    private GitHelper gitHelper;
    private final String mnt;
    private final Logger logger = LoggerFactory.getLogger(ExtraParser.class.getName());
    private final int noParseWorkers = 6;

    /**
     * The same client is injected in both ExtraParser and the VersionRanger.
     * This will help with Mocking when testing later.
     *
     * @param client - JavaHttpClient
     */
    public ExtraParser(JavaHttpClient client, VersionRanger versionRanger, String mnt) {
        this.vulnerabilities = new ConcurrentHashMap<>();
        this.versionRanger = versionRanger;
        this.client = client;
        this.mnt = mnt;
        this.gitHelper = new GitHelper();
    }

    public VersionRanger getVersionRanger() {
        return versionRanger;
    }

    public HashMap<String, Vulnerability> getVulnerabilitiesInMemory() {
        return new HashMap<>(vulnerabilities);
    }

    public void setGitHelper(GitHelper gitHelper) {
        this.gitHelper = gitHelper;
    }

    /**
     * Injects information in the dictionary from the dataset provided by pyupio on Github.
     * Find more information here: https://github.com/pyupio/safety-db
     * The JSON Feed is updated monthly.
     */
    public void injectFromSafetyDB() {
        try {
            var insecureJson = client.sendGet("https://raw.githubusercontent.com/pyupio/safety-db/master/data/insecure_full.json");

            var jsonObject = new JSONObject(insecureJson.trim());
            Iterator<String> keys = jsonObject.keys();
            var insecureVulns = new HashMap<String, JSONObject>();

            while (keys.hasNext()) {
                var key = keys.next();
                var listVulns = jsonObject.optJSONArray(key);
                if(Objects.nonNull(listVulns)) {
                    for (Object listVuln : listVulns) {
                        var vulnObject = (JSONObject) listVuln;
                        insecureVulns.put(key, vulnObject);
                    }
                }
            }

            insecureVulns.keySet().parallelStream().forEach((v) -> {parseJSONVulnObj(v, insecureVulns.get(v));});

        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    private void parseJSONVulnObj(String key, JSONObject vulnObject) {
        var cveIds = vulnObject.get("cve");
        if (!cveIds.toString().equals("null")) {
            // There are multiple CVE-IDs
            if (cveIds.toString().contains(",")) {
                var cves = cveIds.toString().split(",\\s?");
                Arrays.stream(cves).forEach(cve -> insertVulnerability(injectInfoHelper(key, cve, vulnObject)));
            } else {
                // There is only one CVE-ID
                insertVulnerability(injectInfoHelper(key, cveIds.toString(), vulnObject));
            }
        } else {
            // There is only PyUp-id
            var pyupId = (String) vulnObject.get("id");
            insertVulnerability(injectInfoHelper(key, pyupId, vulnObject));
        }
    }

    /**
     * Looks for a vulnerability that was already in the map.
     * If found, it updates it, else puts a new entry.
     *
     * @param v - Vulnerability to insert in the map.
     */
    private void insertVulnerability(Vulnerability v) {
        logger.info("Parsed Vulnerability with ID - " + v.getId());
        if (vulnerabilities.get(v.getId()) == null) {
            vulnerabilities.put(v.getId(), v);
        } else {
            Vulnerability existing = vulnerabilities.get(v.getId());
            existing.merge(v);
            vulnerabilities.put(v.getId(), existing);
        }
    }

    /**
     * Takes a CVE-ID and a JSONObject from safetydb specification and injects information in the dictionary.
     *
     * @param packageName - name of the package to retrieve vulnerable versions from.
     * @param id          - id of the vulnerability
     * @param vulnObject  - JSON Object containing the information related to the package and its vulnerabilities.
     */
    private Vulnerability injectInfoHelper(String packageName, String id, JSONObject vulnObject) {
        var v = new Vulnerability(id);
        v.setDescription((String) vulnObject.get("advisory"));
        var versionsPgk = versionRanger.getVersions("pkg:pypi/" + packageName);
        if (versionsPgk != null) {
            var specs = vulnObject.getJSONArray("specs");
            var ranges = new ArrayList<String>();
            for(int i = 0; i < specs.length(); i++) {
                ranges.add(specs.getString(i));
            }
            var vulnerableVersions = new ArrayList<String>();
            for(var range : ranges) {
                vulnerableVersions.addAll(versionRanger.getVulnerableVersionsJSON(range, versionsPgk));
            }
            vulnerableVersions.forEach(x -> v.addPurl("pkg:pypi/" + packageName + "@" + x));
        }
        return v;
    }

    /**
     * This method can pull information from https://github.com/fabric8-analytics/cvedb
     * and https://github.com/victims/victims-cve-db
     * The bot that creates PRs is by far the best mapper between NVD and package coordinates.
     * Unfortunately, the repo is not very maintained and that means PRs are not merged so often.
     * Example of inputs:
     * https://github.com/victims/victims-cve-db.git
     * https://github.com/fabric8-analytics/cvedb.git
     */
    public void injectYAMLSource(String repoUrl) {
        var repoName = repoUrl.split("/")[4].split("\\.")[0];
        var cloneDirectoryPath = mnt + "/datasets/" + repoName;
        var checkDirAlreadyExists = new File(cloneDirectoryPath);
        if (!checkDirAlreadyExists.exists()) {
            gitHelper.cloneRepo(repoUrl, cloneDirectoryPath, null);
        }
        parseYAMLInformation(cloneDirectoryPath);
    }

    public void parseYAMLInformation(String cloneDirectoryPath) {
        var years = new File(cloneDirectoryPath + "/database/java").list();
        for (String year : years) {
            parseJavaYamlSource(cloneDirectoryPath, year);
        }

        var yearsPython = new File(cloneDirectoryPath + "/database/python").list();
        for (String year : yearsPython) {
            parsePythonYamlSource(cloneDirectoryPath, year);
        }
    }

    public void parseJavaYamlSource(String cloneDirectoryPath, String year) {
        var javaYaml = new Yaml(new Constructor(YAMLHandler.JavaVulnMapper.class));
        try {
            var pathToYearDir = cloneDirectoryPath + "/database/java/" + year;
            var files = listFilesUsingDirectoryStream(pathToYearDir);
            for (String file : files) {
                logger.info("Parsing java statement file " + file + " from year " + year);
                var content = Files.readString(Paths.get(pathToYearDir + "/" + file));
                YAMLHandler.JavaVulnMapper javaPgk = javaYaml.load(content);
                // Check if you already have versions from the VersionRanger
                var versionsPgk = versionRanger.getVersions("pkg:maven/" +
                        javaPgk.affected.get(0).groupId + "/" +
                        javaPgk.affected.get(0).artifactId);
                // Find vulnerable versions and create purls in the mappings
                var vulnerableVersions = versionRanger.getVulnerableVersionsYAML(javaPgk.affected.get(0).version, versionsPgk);
                var vulnerablePURL = versionRanger.buildPURLSMaven(javaPgk.affected.get(0), vulnerableVersions);
                var v = YAMLHandler.buildJavaVulnerabilityFromYaml(javaPgk, vulnerablePURL);
                insertVulnerability(v);
            }
        } catch (IOException e) {
            System.out.println("Could not list any files for year: " + year);
        }
    }

    /**
     * Parses Python YAML statements.
     * @param cloneDirectoryPath - path to statements
     * @param year - folder name
     */
    public void parsePythonYamlSource(String cloneDirectoryPath, String year) {
        var pythonYaml = new Yaml(new Constructor(YAMLHandler.PythonVulnMapper.class));
        try {
            var pathToYearDir = cloneDirectoryPath + "/database/python/" + year;
            var files = listFilesUsingDirectoryStream(pathToYearDir);
            for (String file : files) {
                logger.info("Parsing python statement file " + file + " from year " + year);
                var content = Files.readString(Paths.get(pathToYearDir + "/" + file));
                YAMLHandler.PythonVulnMapper pythonPgk = pythonYaml.load(content);
                // Check if you already have versions from the VersionRanger
                var versionsPgk = versionRanger.getVersions("pkg:pypi/" + pythonPgk.affected.get(0).name);
                // Find vulnerable versions and create purls in the mappings
                var vulnerableVersions = versionRanger.getVulnerableVersionsYAML(pythonPgk.affected.get(0).version, versionsPgk);
                var vulnerablePURL = versionRanger.buildPURLSPypi(pythonPgk.affected.get(0), vulnerableVersions);
                var v = YAMLHandler.buildPythonVulnerabilityFromYaml(pythonPgk, vulnerablePURL);
                insertVulnerability(v);
            }
        } catch (IOException e) {
            System.out.println("Could not list any files for year: " + year);
        }
    }

    /**
     * Helper function to get all the files in a directory.
     *
     * @param dir path to the directory to list files
     * @return Set of Strings where each string is a file name of a YAML file with a vulnerability
     * @throws IOException
     */
    public Set<String> listFilesUsingDirectoryStream(String dir) throws IOException {
        var fileList = new HashSet<String>();
        try (DirectoryStream<Path> stream = Files.newDirectoryStream(Paths.get(dir))) {
            for (Path path : stream) {
                if (!Files.isDirectory(path)) {
                    if (!path.getFileName().toString().equals(".gitkeep")) {
                        fileList.add(path.getFileName()
                                .toString());
                    }
                }
            }
        } catch (IOException e) {
            e.printStackTrace();
        }
        return fileList;
    }

    /**
     * Parses all the additional files in the resources/datasets folder.
     * https://github.com/SAP/project-kb/blob/master/MSR2019/dataset/vulas_db_msr2019_release.csv
     */
    public void injectMSR2019SAP() {
        try {
            var extraCommitsCsv = client.sendGet("https://raw.githubusercontent.com/SAP/project-kb/master/MSR2019/dataset/vulas_db_msr2019_release.csv");
            try {
                var reader = new CSVReader(new StringReader(extraCommitsCsv));
                String[] line;
                while ((line = reader.readNext()) != null) {
                    var cveId = line[0];
                    var commitUrl = line[1] + "/commit/" + line[2];
                    var v = new Vulnerability(cveId);
                    v.addPatchLink(commitUrl);
                    insertVulnerability(v);
                }
            } catch (IOException e) {
                e.printStackTrace();
            }
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    /**
     * Injects the information contained in the project-kb repo on GH.
     */
    public void injectSAPProjectKb(String cloneDir) {
        // Step 1: Clone the repo
        var repoUrl = "https://github.com/SAP/project-kb.git";
        var cloneDirectoryPath = cloneDir + "/project-kb";
        var checkDirAlreadyExists = new File(cloneDirectoryPath);
        if (!checkDirAlreadyExists.exists()) {
            cloneDirectoryPath = gitHelper.cloneRepo(repoUrl,
                    cloneDirectoryPath,
                    "origin/vulnerability-data");
        }
        try {
            var directories = new File(cloneDirectoryPath + "/statements").listFiles(File::isDirectory);
            var yaml = new Yaml(new Constructor(YAMLHandler.SAPVulnMapper.class));
            for (File cveDir : directories) {
                logger.info("Parsing statement file for " + cveDir.getName());
                var content = Files.readString(Paths.get(cveDir.getPath() + "/statement.yaml"));
                try {
                    var v = ((SAPVulnMapper) yaml.load(content)).translateFromStatement();
                    if (v.getPurls().size() > 0) versionRanger.sortVulnerabilityPurls(v);
                    insertVulnerability(v);
                } catch (YAMLException e) {
                    logger.error("Could not import statement " + cveDir.getName());
                }
            }
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    /**
     * This method injects into the vulnerabilities of the ExtraParser.
     * Taking information from the MSR2020 dataset collection.
     * @param datasetPath - String of the path to look where to download/read data
     * "./src/main/resources/datasets/all_c_cpp_release2.0.csv"
     */
    public void injectMSR2020CPP(String datasetPath) {
        var datasetFile = new File(datasetPath);
        String data = null;
        if (datasetFile.exists()) {
            try {
                data = FileUtils.readFileToString(datasetFile, StandardCharsets.UTF_8);
                logger.info("Found MSR2020 CPP dataset from memory");
            } catch (IOException e) {
                logger.error("Error while loading MSR2020 CPP file from memory");
                e.printStackTrace();
            }
        } else {
            // Download raw content
            try {
                logger.info("Downloading raw CSV file from MSR2020");
                data = client.sendGet("https://raw.githubusercontent.com/ZeoVan/MSR_20_Code_vulnerability_CSV_Dataset/master/all_c_cpp_release2.0.csv");
                try (PrintWriter out = new PrintWriter(datasetPath)) {
                    if (data != null) {
                        logger.info("Writing dataset to memory");
                        out.write(data);
                    }
                } catch (FileNotFoundException e) {
                    logger.error("Error while writing the dataset to memory");
                    e.printStackTrace();
                }
            } catch (Exception e) {
                e.printStackTrace();
            }
        }

        int counter = 0;

        // Parse the data
        var splits = data.split("\n\\d{1,4},");
        for (String s : splits) {
            var v = parseMSR2020Blob(s);
            if (v != null) {
                insertVulnerability(v);
                if (v.getPatchLinks().size() > 0)   counter += 1;
            }
        }
        logger.info("Found a total of " + counter + " vulnerability in the CPP dataset from MSR2020");
    }

    /**
     * Parses the blob of information from the dataset.
     * @param s - String containing the information to be parsed.
     * @return - Vulnerability Object, null if no patch link is found
     */
    public Vulnerability parseMSR2020Blob(String s) {
        // Extract the information of each of the splits
        var halves = s.split("\"\\{\"\"sha\"\":");
        var firstPart = halves[0].split(",");
        if (firstPart[2].startsWith("CVE")) {
            var cveId = firstPart[2];
            var severity = firstPart[5];
            var date = firstPart[8];
            var stringBlob = String.join(",", Arrays.copyOfRange(firstPart, 9, firstPart.length - 1));
            stringBlob = stringBlob.substring(0, Math.min(1000, stringBlob.length()));
            var matcher = Pattern.compile("https://github\\.com/.*/.*/commit/.*,").matcher(stringBlob);
            String patchLink = null;
            while (matcher.find()) {
                patchLink = matcher.group().split(",")[0];
            }
            var v = new Vulnerability(cveId);
            v.setPublishedDate(date);
            v.addPatchLink(patchLink);
            v.setSeverity(Severity.translate(severity));
            return v;
        } else {
            return null;
        }
    }

    /**
     * Parses information from ruby-advisory.
     * @param cloneDir - directory to clone the advisory db to
     */
    public void injectRubyAdvisory(String cloneDir) {
        var repoUrl = "https://github.com/rubysec/ruby-advisory-db";
        var cloneDirectoryPath = cloneDir + "/ruby-advisory-db";
        var checkDirAlreadyExists = new File(cloneDirectoryPath);
        if (checkDirAlreadyExists.exists()) {
            try {
                FileUtils.deleteDirectory(new File(cloneDirectoryPath));
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
        try {
            cloneDirectoryPath = gitHelper.cloneRepo(repoUrl,
                    cloneDirectoryPath, null);

            var directories = new File(cloneDirectoryPath + "/gems").listFiles(File::isDirectory);
            var yaml = new Yaml(new Constructor(YAMLHandler.RubyAdvisoryMapper.class));
            assert directories != null;
            for (File gem : directories) {
                logger.info("Parsing statements for GEM: " + gem.getName());
                var statements = listFilesUsingDirectoryStream(gem.getPath());
                for (String statement : statements) {
                    var content = Files.readString(Paths.get(gem.getPath() + "/" + statement));
                    YAMLHandler.RubyAdvisoryMapper vulnStatement = yaml.load(content);
                    insertVulnerability(vulnStatement.translateFromStatement(versionRanger));
                }
            }
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    /**
     * Looks at old and new ones and returns a hashmap of the changed or new ones parsed.
     *
     * @param oldVulnerabilities - map of old vulnerabilities
     * @param newVulnerabilities - map of new vulnerabilities containing (also) old
     * @return difference of the two
     */
    public HashMap<String, Vulnerability> getUpdatedVulnerabilities(HashMap<String, Vulnerability> oldVulnerabilities,
                                                                     HashMap<String, Vulnerability> newVulnerabilities) {
        var iter = newVulnerabilities.keySet().iterator();

        while (iter.hasNext()) {
            String id = iter.next();
            if (oldVulnerabilities.get(id) != null) {
                if (oldVulnerabilities.get(id).equals(newVulnerabilities.get(id))) {
                    iter.remove();
                }
            }
        }

        logger.info("Parsed " + newVulnerabilities.size() + " from ExtraSources");
        return newVulnerabilities;
    }

    /**
     * Method that injects everything and returns the HashMap with the Vulnerabilities.
     *
     * @return hashmap of vulnerabilities
     */
    @Override
    public HashMap<String, Vulnerability> getVulnerabilities(boolean updatesOnly) {
        if(updatesOnly) return getUpdates();
        var executor = Executors.newFixedThreadPool(noParseWorkers);
        List<Callable<Object>> parsingTasks = new ArrayList<>();
        parsingTasks.add(() -> {
            logger.info("Parsing database from Safety-DB");
            injectFromSafetyDB();
            return null;
        });
        parsingTasks.add(() -> {
            logger.info("Injecting extra commits from MSR2019 - SAP Dataset");
            injectMSR2019SAP();
            return null;
        });
        parsingTasks.add(() -> {
            logger.info("Injecting statements from project-kb - SAP Research");
            injectSAPProjectKb(mnt + "/datasets");
            return null;
        });
        parsingTasks.add(() -> {
            logger.info("Injecting extra commits from MSR2020 - CPP Dataset");
            injectMSR2020CPP(mnt + "/datasets/all_c_cpp_release2.0.csv");
            return null;
        });
        parsingTasks.add(() -> {
            logger.info("Parsing database from cvedb");
            injectYAMLSource("https://github.com/edoardolanzini/cvedb.git");
            return null;
        });
        parsingTasks.add(() -> {
            logger.info("Parsing database from victims-cve-db");
            injectYAMLSource("https://github.com/victims/victims-cve-db.git");
            return null;
        });
        try {
            executor.invokeAll(parsingTasks);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        // Wait for the vulnerability parsers to finish their task.
        executor.shutdown();
        logger.info("Parsed " + vulnerabilities.size() + " vulnerabilities from Extra Sources");
        return new HashMap<>(vulnerabilities);
    }

    private HashMap<String, Vulnerability> getUpdates() {
        var oldVulnerabilities = new HashMap<>(vulnerabilities);
        logger.info("Parsing database from Safety-DB");
        injectFromSafetyDB();
        logger.info("Parsing database from cvedb");
        injectYAMLSource("https://github.com/edoardolanzini/cvedb.git");
        logger.info("Parsing database from victims-cve-db");
        injectYAMLSource("https://github.com/victims/victims-cve-db.git");
        return getUpdatedVulnerabilities(oldVulnerabilities, new HashMap<>(vulnerabilities));
    }
}