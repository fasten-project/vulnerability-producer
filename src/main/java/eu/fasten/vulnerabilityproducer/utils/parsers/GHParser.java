/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package eu.fasten.vulnerabilityproducer.utils.parsers;

import com.fasterxml.jackson.databind.ObjectMapper;
import eu.fasten.vulnerabilityproducer.utils.Vulnerability;
import eu.fasten.vulnerabilityproducer.utils.connections.JavaHttpClient;
import eu.fasten.vulnerabilityproducer.utils.mappers.JSONHandler;
import eu.fasten.vulnerabilityproducer.utils.mappers.VersionRanger;
import org.apache.commons.io.FileUtils;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.io.File;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.io.PrintWriter;
import java.nio.charset.StandardCharsets;
import java.util.HashMap;
import java.util.List;

public class GHParser implements VulnerabilityParser {

    private final JavaHttpClient client;
    private final ObjectMapper objectMapper;
    private final VersionRanger versionRanger;
    private final String token;
    private String cursor;
    private final String pathToCursor;
    private static final Logger logger = LoggerFactory.getLogger(GHParser.class.getName());

    public GHParser(JavaHttpClient client, String token, VersionRanger versionRanger, String pathToCursor) {
        this.cursor = loadCursor(pathToCursor);
        this.pathToCursor = pathToCursor;
        this.token = token;
        this.client = client;
        this.versionRanger = versionRanger;
        this.objectMapper = new ObjectMapper();
    }

    public void setCursor(String cursor) {
        this.cursor = cursor;
    }

    /**
     * Loads the cursor.txt to pick up where it left off
     *
     * @param pathToCursor - File path to cursor.txt file
     * @return null if cursor.txt is not stored else the cursor.txt
     */
    private String loadCursor(String pathToCursor) {
        logger.info("Loading GH cursor from file");
        File cursorFile = new File(pathToCursor);
        String cursor = null;
        if (cursorFile.exists()) {
            try {
                cursor = FileUtils.readFileToString(cursorFile, StandardCharsets.UTF_8);
                logger.info("Found cursor: " + cursor);
            } catch (IOException e) {
                logger.error("Error while loading GitHub API cursor.txt at start");
                e.printStackTrace();
            }
        }
        return cursor;
    }

    public VersionRanger getVersionRanger() {
        return versionRanger;
    }

    /**
     * Builds a query for GraphQL API setting a cursor.txt if supplied
     *
     * @param cursor - cursor.txt provided by GH API
     * @return raw response from GH API
     */
    public String buildQuery(String cursor) {
        String secondLine;
        if (cursor != null) {
            secondLine = "  securityAdvisories(first: 100, after: \"" + cursor + "\") {\n";
        } else {
            secondLine = "  securityAdvisories(first: 100) {\n";
        }
        return "query {\n" + secondLine +
                "    nodes {\n" +
                "      description\n" +
                "      identifiers {\n" +
                "        type\n" +
                "        value\n" +
                "      }\n" +
                "      severity\n" +
                "      references {\n" +
                "        url\n" +
                "      }\n" +
                "      vulnerabilities(first: 10) {\n" +
                "        nodes {\n" +
                "          package {\n" +
                "            ecosystem\n" +
                "            name\n" +
                "          }\n" +
                "          vulnerableVersionRange\n" +
                "          firstPatchedVersion {\n" +
                "            identifier\n" +
                "          }\n" +
                "        }\n" +
                "      }\n" +
                "    }\n" +
                "    pageInfo {\n" +
                "      endCursor\n" +
                "      hasNextPage\n" +
                "    }\n" +
                "  }\n" +
                "}";
    }

    /**
     * Parses the response from GH API and injects the information in the list of dependencies
     *
     * @param response        from GH that includes enough information to build a Vulnerability Object
     * @param vulnerabilities hashmap to inject vulnerabilities into
     */
    public void parseGHResponse(JSONHandler.GHResponse response, HashMap<String, Vulnerability> vulnerabilities) {
        for (JSONHandler.GHAdvisory advisory : response.getData().getSecurityAdvisories().getNodes()) {
            logger.info("Parsing information of Vulnerability with ID - " + advisory.getAdvisoryId());
            var v = new Vulnerability(advisory.getAdvisoryId());
            v.setSeverity(advisory.getSeverity());
            v.setDescription(advisory.getDescription());
            advisory.getReferences().forEach(ref -> v.addReference(ref.getUrl()));

            for (JSONHandler.GHNodes node : advisory.getVulnerabilities().getNodes()) {
                var ecosystem = node.ghPackage.ecosystem;
                String pgkIdentifier = null;
                if (ecosystem.equals("PIP")) {
                    pgkIdentifier = "pkg:pypi/" + node.getGhPackage().name;
                }
                if (ecosystem.equals("MAVEN")) {
                    var coordinates = node.getGhPackage().getName().split(":");
                    if (coordinates.length > 1) {
                        pgkIdentifier = "pkg:maven/" + coordinates[0] + "/" + coordinates[1];
                    } else {
                        String[] splits = coordinates[0].split("\\.");
                        pgkIdentifier = "pkg:maven/" + coordinates[0] + "/" + splits[splits.length - 1];
                    }
                }
                if (pgkIdentifier != null) {
                    List<String> allVersions = versionRanger.getVersions(pgkIdentifier);
                    if (allVersions != null) {
                        var vulnerableVersions = versionRanger.getVulnerableVersionsJSON(node.vulnerableVersionRange, allVersions);
                        for (String version : vulnerableVersions) {
                            v.addPurl(pgkIdentifier + "@" + version);
                        }
                    }

                    if (node.firstPatchedVersion != null)
                        v.addFirstPatchedPurl(pgkIdentifier + "@" + node.firstPatchedVersion.identifier);
                }
            }
            // Add the vulnerability to the Hash Map
            vulnerabilities.put(v.getId(), v);
        }
    }

    /**
     * Parser the GH Advisories listings and later merges with NVD Data
     *
     * @return List of Vulnerabilities
     */
    @Override
    public HashMap<String, Vulnerability> getVulnerabilities() {
        HashMap<String, Vulnerability> vulnerabilities = new HashMap<>();
        JSONHandler.GHResponse response = null;

        // Step 1: Make the first request without any cursor.txt
        String queryWithoutCursor = buildQuery(this.cursor);
        var values = new HashMap<String, String>();
        values.put("query", queryWithoutCursor);
        try {
            String result = client.sendPost("https://api.github.com/graphql", token, values);
            response = objectMapper.readValue(result, JSONHandler.GHResponse.class);
            parseGHResponse(response, vulnerabilities);
        } catch (Exception e) {
            e.printStackTrace();
        }

        // Step 2: Integrate the request with the cursor.txt and parse the data
        while (response.getData().getSecurityAdvisories().getPageInfo().hasNextPage) {
            this.cursor = response.getData().getSecurityAdvisories().getPageInfo().endCursor;
            String queryWithCursor = buildQuery(this.cursor);
            values.put("query", queryWithCursor);
            try {
                String result = client.sendPost("https://api.github.com/graphql", token, values);
                response = objectMapper.readValue(result, JSONHandler.GHResponse.class);
                parseGHResponse(response, vulnerabilities);
            } catch (Exception e) {
                e.printStackTrace();
            }
        }

        // Step 3: Save cursor.txt to file in case of shutdown
        try (PrintWriter out = new PrintWriter(pathToCursor)) {
            if (cursor != null) {
                logger.info("Writing cursor to file to pick up where we left off");
                out.write(cursor);
                out.flush();
            }
        } catch (FileNotFoundException e) {
            logger.error("Error while updating the cursor.txt tracker file");
            e.printStackTrace();
        }

        logger.info("Parsed " + vulnerabilities.size() + " vulnerabilities from GitHub Advisories");
        return vulnerabilities;
    }

    /**
     * This method retrieves updates once a day from GH.
     * Since the cursor.txt is a field of the class, it is resilient.
     *
     * @return hashmap of vulnerabilities
     */
    @Override
    public HashMap<String, Vulnerability> getUpdates() {
        logger.info("Pulling updates from GitHub Advisories");
        return getVulnerabilities();
    }
}
