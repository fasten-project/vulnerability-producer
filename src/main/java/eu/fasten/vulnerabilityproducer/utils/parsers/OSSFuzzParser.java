/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package eu.fasten.vulnerabilityproducer.utils.parsers;

import eu.fasten.vulnerabilityproducer.utils.*;
import eu.fasten.vulnerabilityproducer.utils.connections.*;
import eu.fasten.vulnerabilityproducer.utils.mappers.YAMLHandler.*;
import org.slf4j.*;
import org.yaml.snakeyaml.*;
import org.yaml.snakeyaml.constructor.*;

import java.io.*;
import java.nio.file.*;
import java.util.*;

public class OSSFuzzParser implements VulnerabilityParser {

    private GitHelper gitHelper;
    private String mnt;
    private String repoUrl = "https://github.com/google/oss-fuzz-vulns.git";
    private final Logger logger = LoggerFactory.getLogger(OSSFuzzParser.class.getName());

    /**
     * Parser for oss-fuzz-vulns.
     * @param mnt - path to mnt
     */
    public OSSFuzzParser(String mnt) {
        this.mnt = mnt;
        this.gitHelper = new GitHelper();
    }

    public void setGitHelper(GitHelper gitHelper) {
        this.gitHelper = gitHelper;
    }

    @Override
    public HashMap<String, Vulnerability> getVulnerabilities() {
        // Clone the repo to mnt
        var vulnerabilities = new HashMap<String, Vulnerability>();
        var cloneDirectoryPath = mnt + "/datasets/oss-fuzz-vulns/";
        gitHelper.cloneRepo(repoUrl,
                cloneDirectoryPath,
                null);
        //  Parse statements with YAML
        var directories = new File(cloneDirectoryPath + "vulns/").listFiles(File::isDirectory);
        var yaml = new Yaml(new Constructor(OSSFuzzMapper.class));
        var counter = 0;

        for (File directory : directories) {
            var vulnStatements = directory.listFiles((d, name) -> name.endsWith(".yaml"));
            for (File statement : vulnStatements) {
                try {
                    var content = Files.readString(Paths.get(statement.getPath()));
                    content = content.replace("package:\n", "packageAffected:\n");
                    var vulnOSSFuzz = (OSSFuzzMapper) yaml.load(content);
                    var vuln = translateFromOSSFuzz(vulnOSSFuzz);
                    vulnerabilities.put(vuln.getId(), vuln);
                    counter += 1;
                } catch (IOException e) {
                    logger.error("Could not parse " + statement.getPath());
                }
            }
        }

        logger.info("Parsed " + counter + " vulnerabilities from oss-fuzz-vulns");
        return vulnerabilities;
    }

    /**
     * Helper to translate between OSSFuzz statements and Vulnerability Objects
     * @param vulnOSSFuzz - OSSFuzz statement object
     * @return vulnerability object
     */
    private Vulnerability translateFromOSSFuzz(OSSFuzzMapper vulnOSSFuzz) {
        var v = new Vulnerability();
        v.setId(vulnOSSFuzz.id);
        v.setPublishedDate(vulnOSSFuzz.published.split("T")[0]);
        v.setLastModifiedDate(vulnOSSFuzz.modified.split("T")[0]);
        v.setDescription(vulnOSSFuzz.summary + "\n" + vulnOSSFuzz.details);
        v.setSeverity(vulnOSSFuzz.severity);

        vulnOSSFuzz.affects.ranges.forEach(range -> {
            if (range.type.equals("GIT") && range.fixed != null) {
                if (range.repo.startsWith("git://")) {
                    var repo = "https://" + range.repo.substring(6).split("/")[0];
                    var project = range.repo.substring(6).split("/")[1];
                    var patchBase = repo + "?p=" + project + ";a=commit;h=";
                    for (String commit : range.fixed.split(":")) {
                        v.addPatchLink(patchBase + commit);
                    }
                } else if (range.repo.startsWith("https://github") | range.repo.startsWith("https://gitlab")) {
                    var repo = range.repo.endsWith(".git") ? range.repo.substring(0, range.repo.length() - 4) : range.repo;
                    for (String commit : range.fixed.split(":")) {
                        v.addPatchLink(repo + "/commit/" + commit);
                    }
                } else {
                    var repo = range.repo;
                    repo = handleSpecialCases(repo);

                    for (String commit : range.fixed.split(":")) {
                        if (repo.contains("github.com/qemu/qemu"))
                            v.addPatchLink(repo + "/commit/" + commit);
                        else
                            v.addPatchLink(repo + "/commit/?id=" + commit);
                    }
                }
            }
        });

        var ecosystem = vulnOSSFuzz.packageAffected.ecosystem;
        String basePurl = null;
        if (ecosystem.equals("OSS-Fuzz"))   basePurl = "pkg:deb/debian/" + vulnOSSFuzz.packageAffected.name;
        if (ecosystem.equals("PyPI"))   basePurl = "pkg:pypi/" + vulnOSSFuzz.packageAffected.name;
        if (basePurl != null && vulnOSSFuzz.affects.versions != null) {
            for (String version : vulnOSSFuzz.affects.versions) v.addPurl(basePurl + "@" + version);
        }
        vulnOSSFuzz.references.forEach(ref -> v.addReference(ref.url));

        return v;
    }

    /**
     * Edge cases found through manual inspection.
     * @param repo - initial repo string
     * @return repo string changed for special cases
     */
    private String handleSpecialCases(String repo) {
        if (repo.contains("git.savannah.gnu.org"))
            repo = repo.replace("/git/", "/cgit/");
        if (repo.contains("git.qemu.org"))
            repo = repo.replace("git.qemu.org/git/qemu.git", "github.com/qemu/qemu");
        return repo;
    }

    @Override
    public HashMap<String, Vulnerability> getUpdates() {
        return getVulnerabilities();
    }
}
