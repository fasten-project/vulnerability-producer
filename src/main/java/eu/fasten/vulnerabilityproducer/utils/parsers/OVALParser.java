/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package eu.fasten.vulnerabilityproducer.utils.parsers;

import eu.fasten.vulnerabilityproducer.utils.Vulnerability;
import eu.fasten.vulnerabilityproducer.utils.connections.JavaHttpClient;
import eu.fasten.vulnerabilityproducer.utils.mappers.VersionRanger;
import me.tongfei.progressbar.ProgressBar;
import org.apache.commons.lang3.tuple.ImmutablePair;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.w3c.dom.Document;
import org.w3c.dom.Element;
import org.w3c.dom.Node;
import org.w3c.dom.NodeList;
import org.xml.sax.SAXException;

import javax.xml.parsers.DocumentBuilder;
import javax.xml.parsers.DocumentBuilderFactory;
import javax.xml.parsers.ParserConfigurationException;
import java.io.ByteArrayInputStream;
import java.io.IOException;
import java.io.InputStream;
import java.util.HashMap;
import java.util.List;
import java.util.Objects;

/**
 * This parser handles all OVAL imports.
 */
public class OVALParser implements VulnerabilityParser {

    private final HashMap<String, Vulnerability> vulnerabilities;
    private final JavaHttpClient client;
    private final VersionRanger versionRanger;
    private final Logger logger = LoggerFactory.getLogger(OVALParser.class.getName());

    /**
     * The same client is injected in both OVALParser and the VersionRanger.
     * This will help with Mocking when testing later.
     *
     * @param client - JavaHttpClient
     */
    public OVALParser(JavaHttpClient client, VersionRanger versionRanger) {
        this.vulnerabilities = new HashMap<>();
        this.versionRanger = versionRanger;
        this.client = client;
    }

    /**
     * Small helper to look up what is in memory
     * @return - map of vulnerabilities
     */
    public HashMap<String, Vulnerability> getVulnerabilitiesInMemory() {
        return vulnerabilities;
    }

    /**
     * The main source of information to get vulnerabilities is Debian.
     * Here is the link to the XML file:
     */
    @Override
    public HashMap<String, Vulnerability> getVulnerabilities(boolean updatesOnly) {
        // Download Buster OVAL XML file
        String ovalXML = null;
        try {
            logger.info("Downloading Buster OVAL from Debian Security Website");
            ovalXML = client.sendGet("https://www.debian.org/security/oval/oval-definitions-buster.xml");
        } catch (Exception e) {
            logger.error("Cannot downloaded Buster OVAL from Debian Security Website");
            e.printStackTrace();
        }
        // Read the XML file
        DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();
        DocumentBuilder builder;
        Document document = null;
        try {
            builder = factory.newDocumentBuilder();
            InputStream is = new ByteArrayInputStream(Objects.requireNonNull(ovalXML).getBytes());
            document = builder.parse(is);
        } catch (ParserConfigurationException e) {
            logger.error("Error while parsing the OVAL xml file - ParserConfigException");
            e.printStackTrace();
        } catch (SAXException e) {
            logger.error("Error while parsing the OVAL xml file - SAXException");
            e.printStackTrace();
        } catch (IOException e) {
            logger.error("Error while parsing the OVAL xml file - IOException");
            e.printStackTrace();
        }

        // Normalize XML Structure
        Objects.requireNonNull(document).getDocumentElement().normalize();

        // Prepare placeholders for all the information to gather
        HashMap<String, ImmutablePair<String, String>> ovalTestMap = new HashMap<>();
        HashMap<String, String> ovalObjectMap = new HashMap<>();
        HashMap<String, String> ovalStateMap = new HashMap<>();

        // Parse all OvalTests and put them into a HashMap
        NodeList ovalTests = document.getElementsByTagName("dpkginfo_test");

        for (int i = 0; i < ovalTests.getLength(); i++) {
            Node node = ovalTests.item(i);
            Element eElement = (Element) node;
            Element object = (Element) eElement.getElementsByTagName("object").item(0);
            Element state = (Element) eElement.getElementsByTagName("state").item(0);

            String testId = eElement.getAttribute("id");
            String objectRef = object.getAttribute("object_ref");
            String stateRef = state.getAttribute("state_ref");

            ovalTestMap.put(testId, new ImmutablePair<>(objectRef, stateRef));
        }

        // Parse all OvalObjects and put them into a HashMap
        NodeList ovalObjects = document.getElementsByTagName("dpkginfo_object");

        for (int i = 0; i < ovalObjects.getLength(); i++) {
            Node node = ovalObjects.item(i);
            Element eElement = (Element) node;
            Element object = (Element) eElement.getElementsByTagName("name").item(0);
            String objectId = eElement.getAttribute("id");
            String objectName = object.getTextContent();

            ovalObjectMap.put(objectId, objectName);
        }

        // Parse all OvalStates and put them into a HashMap
        NodeList ovalStates = document.getElementsByTagName("dpkginfo_state");

        for (int i = 0; i < ovalStates.getLength(); i++) {
            Node node = ovalStates.item(i);
            Element eElement = (Element) node;
            Element version = (Element) eElement.getElementsByTagName("evr").item(0);
            String stateId = eElement.getAttribute("id");
            String stateVersions = version.getTextContent();

            ovalStateMap.put(stateId, stateVersions);
        }

        // Parse all OvalDefinitions and create vulnerability objects
        NodeList nList = document.getElementsByTagName("definition");

        try (ProgressBar pb = new ProgressBar("OVALParser", nList.getLength())) {
            for (int i = 0; i < nList.getLength(); i++) {
                Node node = nList.item(i);
                Element eElement = (Element) node;
                Vulnerability vulnOVAL = new Vulnerability(getCveId(eElement));
                String date;
                String description;
                if (eElement.getElementsByTagName("debian").getLength() > 0) {
                    if (eElement.getElementsByTagName("date").getLength() > 0) {
                        date = eElement.getElementsByTagName("date").item(0).getTextContent();
                        vulnOVAL.setPublishedDate(date);
                    }
                    if (eElement.getElementsByTagName("moreinfo").getLength() > 0) {
                        description = eElement.getElementsByTagName("moreinfo").item(0).getTextContent();
                        vulnOVAL.setDescription(description);
                    }
                }
                // Grab all test_ref in criterion
                NodeList criteriaList = eElement.getElementsByTagName("criterion");
                for (int j = 0; j < criteriaList.getLength(); j++) {
                    Element criteria = (Element) criteriaList.item(j);
                    String testRef = criteria.getAttribute("test_ref");
                    // ovalTests 1 and 2 contain info about architecture and distro
                    if (!testRef.equals("oval:org.debian.oval:tst:1") &&
                            !testRef.equals("oval:org.debian.oval:tst:2")) {
                        ImmutablePair<String, String> ovalTestInfo = ovalTestMap.get(testRef);
                        String productName = ovalObjectMap.get(ovalTestInfo.left).split(" ")[0];
                        String lessThanVersion = ovalStateMap.get(ovalTestInfo.right).substring(2);
                        if (productName.length() > 0 && lessThanVersion.length() > 0) {
                            // Build version range that includes the vulnerable versions
                            List<String> allVersions = versionRanger.getVersions("pkg:deb/debian/" + productName);
                            List<String> vulnerableVersions = versionRanger.getVulnerableVersionsOVAL(lessThanVersion,
                                    allVersions);
                            for (String v : vulnerableVersions) {
                                // For now, we only handle buster distro
                                vulnOVAL.addPurl("pkg:deb/debian/" + productName + "@" + v + "?distro=buster");
                            }
                        }
                    }
                    vulnerabilities.put(vulnOVAL.getId(), vulnOVAL);
                }
                pb.step();
            }
        }
        return vulnerabilities;
    }

    private String getCveId(Element eElement) {
        var titleElem = eElement.getElementsByTagName("title").item(0).getTextContent();
        var cveId = titleElem;
        var splitTitle = titleElem.split(" ");
        if(splitTitle.length > 1) {
            cveId = splitTitle[0];
        }
        return cveId;
    }
}
