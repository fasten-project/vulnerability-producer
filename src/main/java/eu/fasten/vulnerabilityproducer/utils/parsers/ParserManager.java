/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package eu.fasten.vulnerabilityproducer.utils.parsers;

import com.mongodb.client.MongoDatabase;
import eu.fasten.vulnerabilityproducer.db.NitriteController;
import eu.fasten.vulnerabilityproducer.utils.PatchFinder;
import eu.fasten.vulnerabilityproducer.utils.Vulnerability;
import eu.fasten.vulnerabilityproducer.utils.connections.JavaHttpClient;
import eu.fasten.vulnerabilityproducer.utils.mappers.VersionRanger;
import org.apache.commons.io.FileUtils;
import org.jooq.tools.json.JSONParser;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.io.File;
import java.io.IOException;
import java.util.*;
import java.util.concurrent.TimeUnit;

/**
 * The responsibility of the ParserManager is to gather Vulnerabilities from all the parsers.
 * Combine them together, merging what is necessary and the handing them over to the PatchFarmer to enrich
 * every single vulnerability with information about patches specifically.
 */
public class ParserManager {
    private ExtraParser extraParser;
    private GHParser ghParser;
    private String ghToken;
    private NVDParser nvdParser;
    private OVALParser ovalParser;
    private PatchFinder patchFinder;
    private VersionRanger versionRanger;
    private NitriteController nitriteController;
    private final Logger logger = LoggerFactory.getLogger(ParserManager.class.getName());

    private String pathToVersions = "./src/main/resources/trackers/package_versions.json";
    private String pathToGHCursor = "./src/main/resources/trackers/cursor.txt";

    public ParserManager(JavaHttpClient client,
                         MongoDatabase mongoDatabase,
                         NitriteController nitriteController) {
        this.ghToken = System.getenv("FASTEN_GHTOKEN");
        this.versionRanger = new VersionRanger(client, pathToVersions);
        this.extraParser = new ExtraParser(client, versionRanger);
        this.ovalParser = new OVALParser(client, versionRanger);
        this.ghParser = new GHParser(client, ghToken, versionRanger, pathToGHCursor);
        this.nvdParser = new NVDParser(new JSONParser(), client);
        this.patchFinder = new PatchFinder(mongoDatabase, client);
        this.nitriteController = nitriteController;
    }

    public void setGhToken(String ghToken) {
        this.ghToken = ghToken;
    }

    /**
     * Combines the results of all the parsers.
     *
     * @return set of vulnerability objects containing all the information found.
     */
    public HashSet<Vulnerability> getVulnerabilitiesFromParsers() {
        logger.info("Gathering vulnerabilities from GitHub Advisories");
        HashMap<String, Vulnerability> mapFromGH = ghParser.getVulnerabilities();
        logger.info("Gathering vulnerabilities from Extra Sources");
        HashMap<String, Vulnerability> mapFromExtraSources = extraParser.getVulnerabilities();
        logger.info("Gathering vulnerabilities from NVD");
        HashMap<String, Vulnerability> mapFromNVD = nvdParser.getVulnerabilities();
        logger.info("Gathering vulnerabilities from Debian OVAL");
        HashMap<String, Vulnerability> mapFromOVAL = ovalParser.getVulnerabilities();

        logger.info("Merging all the pulled vulnerabilities");
        // Put all maps from parsers into a list to pass it on
        List<HashMap<String, Vulnerability>> maps = new ArrayList<>();
        maps.add(mapFromNVD);
        maps.add(mapFromExtraSources);
        maps.add(mapFromGH);
        maps.add(mapFromOVAL);
        HashSet<Vulnerability> vulnerabilities = mergeMapsOfVulnerabilities(maps);

        logger.info("Injecting information about Patches");
        for (Vulnerability v : vulnerabilities) {
            // Adding patch information
            patchFinder.parseReferences(v, nitriteController);
            // Storing the file to statements
            File file = new File("/Users/Edo/Desktop/statements/" + v.getId() + ".json");
            try {
                FileUtils.writeStringToFile(file, v.toJson());
            } catch (IOException e) {
                e.printStackTrace();
            }
        }

        filterNewEntries(vulnerabilities);

        return vulnerabilities;
    }


    /**
     * Get updates from all the different parsers and return them.
     *
     * @return set of vulnerabilities, including new ones and changed ones.
     */
    public HashSet<Vulnerability> getUpdatesFromParsers() {
        logger.info("Updating Versions of Packages");
        versionRanger.updateMappings();

        logger.info("Gathering updates from GitHub Advisories");
        HashMap<String, Vulnerability> mapFromGH = ghParser.getUpdates();
        logger.info("Gathering updates from Extra Sources");
        HashMap<String, Vulnerability> mapFromExtraSources = extraParser.getUpdates();
        logger.info("Gathering updates from NVD");
        HashMap<String, Vulnerability> mapFromNVD = nvdParser.getUpdates();
        logger.info("Gathering updates from OVAL");
        HashMap<String, Vulnerability> mapFromOVAL = ovalParser.getUpdates();

        logger.info("Merging all the pulled updates");
        // Put all maps from parsers into a list to pass it on
        List<HashMap<String, Vulnerability>> maps = new ArrayList<>();
        maps.add(mapFromNVD);
        maps.add(mapFromExtraSources);
        maps.add(mapFromGH);
        maps.add(mapFromOVAL);
        HashSet<Vulnerability> vulnerabilities = mergeMapsOfVulnerabilities(maps);

        logger.info("Parsing references of all vulnerabilities to inject patches information");
        for (Vulnerability v : vulnerabilities) {
            logger.info("Parsing references from Vulnerability with ID: " + v.getId());
            patchFinder.parseReferences(v, nitriteController);
        }

        logger.info("Filtering if entries are new using Nitrite Controller");
        filterNewEntries(vulnerabilities);

        return vulnerabilities;
    }

    /**
     * For each of the entries in the set, checks Nitrite for the entry.
     * If the entry is found AND it's equals, it is discarded.
     *
     * @param vulnerabilities - cleaned containing only new ones.
     */
    private void filterNewEntries(HashSet<Vulnerability> vulnerabilities) {
        for (Vulnerability v : vulnerabilities) {
            Optional<Vulnerability> queryFromNC = nitriteController.findVulnerabilityEntry(v.getId());
            if (!queryFromNC.isEmpty()) {
                if (queryFromNC.get().equals(v)) {
                    vulnerabilities.remove(v);
                }
            }
        }
    }


    /**
     * Given a list of vulnerability objects, it merges all of the objects.
     * @param maps - List of hashmaps mapping ID to Vulnerability objects
     * @return set of vulnerabilities
     */
    private HashSet<Vulnerability> mergeMapsOfVulnerabilities(List<HashMap<String, Vulnerability>> maps) {
        HashMap<String, Vulnerability> mapMerger = new HashMap<>();
        for (HashMap<String, Vulnerability> map : maps) {
            for (String vulnerabilityId : map.keySet()) {
                if (mapMerger.containsKey(vulnerabilityId)) {
                    Vulnerability v1 = mapMerger.get(vulnerabilityId);
                    v1.merge(map.get(vulnerabilityId));
                    mapMerger.put(vulnerabilityId, v1);
                } else {
                    mapMerger.put(vulnerabilityId, map.get(vulnerabilityId));
                }
            }
        }
        HashSet<Vulnerability> vulnerabilities = new HashSet<>(mapMerger.values());
        return vulnerabilities;
    }


    /**
     * Helper function for the vulnerability Plugin to inject the sleep behaviour.
     * This way, when mocking the parser, you can just skip over the wait.
     */
    public void sleep() {
        try {
            TimeUnit.DAYS.sleep(1);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }

    /**
     * Helper method to inject parsers and test the merging of the three sources.
     *
     * @param nvdParser   - NVDParser
     * @param ghParser    - GHParser
     * @param extraParser - ExtraParser
     * @param patchFinder - PatchFarmer
     */
    public void injectParsers(NVDParser nvdParser,
                              GHParser ghParser,
                              ExtraParser extraParser,
                              OVALParser ovalParser,
                              PatchFinder patchFinder) {
        this.nvdParser = nvdParser;
        this.ghParser = ghParser;
        this.extraParser = extraParser;
        this.ovalParser = ovalParser;
        this.patchFinder = patchFinder;
    }
}
