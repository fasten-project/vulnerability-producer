/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package eu.fasten.vulnerabilityproducer.utils.patches;

import com.github.difflib.unifieddiff.*;
import eu.fasten.vulnerabilityproducer.utils.*;

import java.io.*;
import java.nio.charset.*;
import java.util.ArrayList;
import java.util.HashSet;

/**
 * Contains the different utilities used to handle diffs coming from different sources.
 */
public class DiffParser {

    /**
     * Use java-diff-utils to extract diffs information and create patch objects.
     * @param unifiedDiff - Unified diff string to parse.
     * @return set of Patches
     */
    public static HashSet<Patch> getPatchesFromUnifiedDiff(String unifiedDiff) throws IOException {
        var stream = new ByteArrayInputStream(unifiedDiff.getBytes(StandardCharsets.UTF_8));
        var diffs  = UnifiedDiffReader.parseUnifiedDiff(stream);

        var patches = new HashSet<Patch>();
        diffs.getFiles().forEach(f -> {
            var fileName = f.getFromFile();
            if (!fileName.equals("/dev/null")) {    // checks if file is new
                f.getPatch().getDeltas().forEach(delta -> {
                    var originalChanges = new ArrayList<>(delta.getSource().getChangePosition());
                    var newChanges = new ArrayList<>(delta.getTarget().getChangePosition());
                    var p = new Patch(fileName, originalChanges, newChanges, null, null);
                    patches.add(p);
                });
            }
        });

        return patches;
    }

    /**
     * Custom method to use patches from GitHub API v3.
     * Since they do not adhere to Unified diff convention,
     * we stick a dummy header to enable java-diff-utils to parse it.
     * Later we replace this info with the proper filename.
     * @param diff - patch string
     * @return set of patches
     */
    public static HashSet<Patch> getPatchesFromGitHubDiff(String diff, String filename) throws IOException {
        var diffWithHeader = "--- a/foo\n+++ b/foo\n" + diff;
        var stream = new ByteArrayInputStream(diffWithHeader.getBytes(StandardCharsets.UTF_8));
        var diffs  = UnifiedDiffReader.parseUnifiedDiff(stream);

        var patches = new HashSet<Patch>();
        diffs.getFiles().forEach(f -> {
            f.getPatch().getDeltas().forEach(delta -> {
                var originalChanges = new ArrayList<>(delta.getSource().getChangePosition());
                var newChanges = new ArrayList<>(delta.getTarget().getChangePosition());
                var p = new Patch(filename, originalChanges, newChanges, null, null);
                insertPatch(patches, p);
            });
        });

        return patches;
    }

    /**
     * Merges Patches for the same file info a single Patch.
     * @param patches - set of Patches
     * @param p - patch to insert into the set
     */
    private static void insertPatch(HashSet<Patch> patches, Patch p) {
        for (Patch patch : patches) {
            if (patch.getFileName().equals(p.getFileName())) {
                patch.mergeWithOther(p);
                return;
            }
        }
        patches.add(p);
    }
}
