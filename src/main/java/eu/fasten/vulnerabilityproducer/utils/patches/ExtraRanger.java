/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package eu.fasten.vulnerabilityproducer.utils.patches;

import eu.fasten.vulnerabilityproducer.utils.PatchFinder;
import eu.fasten.vulnerabilityproducer.utils.Vulnerability;
import eu.fasten.vulnerabilityproducer.utils.Vulnerability.*;
import eu.fasten.vulnerabilityproducer.utils.connections.JavaHttpClient;
import org.joda.time.DateTime;
import org.joda.time.format.ISODateTimeFormat;
import org.jooq.tools.json.JSONParser;
import org.jsoup.Jsoup;
import org.jsoup.nodes.Element;
import org.jsoup.select.Elements;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.util.HashSet;

public class ExtraRanger extends GenericRanger {
    private final Logger logger = LoggerFactory.getLogger(ExtraRanger.class.getName());

    public ExtraRanger(JavaHttpClient httpClient, JSONParser jsonParser) {
        super(httpClient, jsonParser);
    }

    /**
     * Injects patch info for Git Tracker links to commits.
     * @param ref - link to a commit that uses cgit
     * @return - set of patches
     */
    public HashSet<Patch> parseGitTrackerCommit(String ref) {
        logger.info("Parsing Git tracker commit with URL: " + ref);
        var patches = new HashSet<Patch>();
        try {
            if (ref.matches("http(s)?://.*git\\..*\\.(org|com)/.*/commit/(\\?id=)?[a-zA-Z_0-9]++")) {
                var linkToDiff = ref.replaceFirst("/commit/", "/rawdiff/");
                var raw = httpClient.sendGet(linkToDiff);
                patches = DiffParser.getPatchesFromDiffs(raw);
            } else if (ref.contains(";a=commitdiff;")) {
                var linkToDiff = ref.replace("a=commitdiff", "a=commitdiff_plain");
                var raw = httpClient.sendGet(linkToDiff);
                patches = DiffParser.getPatchesFromDiffs(raw);
            }
        } catch (Exception e) {
            logger.error("Could not parse " + ref + " for Git Tracker");
        }
        // TODO: Encode patch as vcs_url
        patches.forEach(p -> p.setPatchUrl(ref));
        return patches;
    }

    /**
     * Injects patch info from Apache SVN revision link.
     * @param ref - link to a revision
     * @return - set of patches
     */
    public HashSet<Patch> parseApacheSVNRevision(String ref) {
        logger.info("Parsing Apache SVN revision with URL: " + ref);
        var patches = new HashSet<Patch>();
        var baseURL = "https://svn.apache.org";
        var revisionHTML = httpClient.sendGet(ref);
        var doc   = Jsoup.parse(revisionHTML);
        var links = doc.select("a[title=\"View Diff\"]");
        for (Element link : links) {
            try {
                var patchLink = baseURL + link.attr("href") + "&view=patch";
                var diff = httpClient.sendGet(patchLink);
                var patched_files = DiffParser.getPatchesFromDiffs(diff);
                patches.addAll(patched_files);
            } catch (Exception e) {
                logger.error("Cannot parse the diff for SVN Revision: " + ref);
            }
        }
        // TODO: Encode patch as vcs_url
        patches.forEach(p -> p.setPatchUrl(ref));
        return patches;
    }

    /**
     * Injects information taking it from a thread in the mailing list
     * The information is into the messages exchanged. Looks for patch links and parses them.
     * @param ref - link to a mailing thread
     * @return - set of patches
     */
    public HashSet<Patch> parseApacheMailThread(String ref) {
        logger.info("Parsing Mailing Thread with URL: " + ref);
        var patches = new HashSet<Patch>();
        var linkToApiCall = ref.replace("thread.html", "api/source.lua");
        var threadRaw = httpClient.sendGet(linkToApiCall);
        if (threadRaw != null && threadRaw.contains("Content-Type: text/plain;")) {
            threadRaw = threadRaw.split("Content-Type: text/plain;")[1]
                    .split("Content-Type: text/html;")[0];
            var potentialPatches = PatchFinder.findPatchLinks(threadRaw);
            for (String pp : potentialPatches) {
                if (!pp.equals(ref)) {
                    var out = PatchFinder.parseReference(pp);
                    if (out != null) patches.addAll(out);
                }
            }
        }
        return patches;
    }

    /**
     * Parses Mercurial Revision extracting patches.
     * @param ref - ref to mercurial revision
     * @return set of patches found
     */
    public HashSet<Patch> parseMercurialRevision(String ref) {
        logger.info("Parsing Mercurial Revision with URL: " + ref);
        var patches   = new HashSet<Patch>();
        var patchLink = ref.replace("rev", "raw-rev");
        try {
            var content   = httpClient.sendGet(patchLink);
            if (content.contains("error: unknown revision")) return null;
            var date = getDateFromMercurialRevision(content);
            patches.addAll((DiffParser.getPatchesFromDiffs(content)));
            patches.forEach(p -> {
                p.setPatchDate(date);
                p.setPatchUrl(ref);
            });
        } catch (Exception e) {
            logger.error("Could not parse HG Revision" + ref );
        }
        return patches;
    }

    /**
     * Extracts the date from a Mercurial revision.
     * Find information here: https://www.mercurial-scm.org/doc/hg.1.html#date-formats
     * @param patch - String patch
     * @return String date in ISOFormat if found
     */
    public String getDateFromMercurialRevision(String patch) {
        var splits = patch.split("# Date ");
        if (splits.length < 1)  return null;
        var date = splits[1].split("\\s")[0];
        if (!date.matches("\\d++"))   return null;
        return new DateTime(Long.parseLong(date)*1000l).toString(ISODateTimeFormat.date());
    }
}
