package eu.fasten.vulnerabilityproducer.utils.patches;

import eu.fasten.vulnerabilityproducer.utils.PatchFinder;
import eu.fasten.vulnerabilityproducer.utils.Vulnerability;
import eu.fasten.vulnerabilityproducer.utils.connections.JavaHttpClient;
import org.joda.time.DateTime;
import org.joda.time.format.ISODateTimeFormat;
import org.jooq.tools.json.JSONParser;
import org.jsoup.Jsoup;
import org.jsoup.nodes.Element;
import org.jsoup.select.Elements;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.util.HashSet;

public class ExtraRanger extends GenericRanger {
    private final Logger logger = LoggerFactory.getLogger(ExtraRanger.class.getName());

    public ExtraRanger(JavaHttpClient httpClient, JSONParser jsonParser) {
        super(httpClient, jsonParser);
    }

    /**
     * Injects patch info for Git Tracker links to commits.
     * @param ref - link to a commit that uses cgit
     * @return - set of patches
     */
    public HashSet<Vulnerability.Patch> parseGitTrackerCommit(String ref) {
        logger.info("Parsing Git tracker commit with URL: " + ref);
        var patches = new HashSet<Vulnerability.Patch>();
        try {
            if (ref.matches("http(s)?://.*git\\..*\\.(org|com)/.*/commit/(\\?id=)?[a-zA-Z_0-9]++")) {
                var linkToDiff = ref.replaceFirst("/commit/", "/rawdiff/");
                var raw = httpClient.sendGet(linkToDiff);
                patches = DiffParser.getPatchesFromDiffs(raw);
            } else if (ref.contains(";a=commitdiff;")) {
                var linkToDiff = ref.replace(";a=commitdiff;", ";a=commitdiff_plain;");
                var raw = httpClient.sendGet(linkToDiff);
                patches = DiffParser.getPatchesFromDiffs(raw);
            }
        } catch (Exception e) {
            logger.error("Could not parse " + ref + " for Git Tracker");
            return patches;
        }
        return patches;
    }

    /**
     * Injects patch info from Apache SVN revision link.
     * @param ref - link to a revision
     * @return - set of patches
     */
    public HashSet<Vulnerability.Patch> parseApacheSVNRevision(String ref) {
        logger.info("Parsing Apache SVN revision with URL: " + ref);
        HashSet<Vulnerability.Patch> patches = new HashSet<>();
        String baseURL = "https://svn.apache.org";
        org.jsoup.nodes.Document doc = null;
        String revisionHTML = httpClient.sendGet(ref);
        doc = Jsoup.parse(revisionHTML);
        Elements links = doc.select("a[title=\"View Diff\"]");
        for (Element link : links) {
            var patchLink = baseURL + link.attr("href") + "&view=patch";
            var diff = httpClient.sendGet(patchLink);
            try {
                var patched_files = DiffParser.getPatchesFromDiffs(diff);
                patches.addAll(patched_files);
            } catch (Exception e) {
                logger.error("Cannot parse the diff for SVN Revision, sorry");
            }
        }
        return patches;
    }

    /**
     * Injects information taking it from a thread in the mailing list
     * The information is into the messages exchanged. Looks for patch links and parses them.
     * @param ref - link to a mailing thread
     * @return - set of patches
     */
    public HashSet<Vulnerability.Patch> parseApacheMailThread(String ref) {
        logger.info("Parsing Mailing Thread with URL: " + ref);
        HashSet<Vulnerability.Patch> patches = new HashSet<>();
        var linkToApiCall = ref.replace("thread.html", "api/source.lua");
        var threadRaw = httpClient.sendGet(linkToApiCall);
        if (threadRaw != null && threadRaw.contains("Content-Type: text/plain;")) {
            // Strip only the content of it
            threadRaw = threadRaw.split("Content-Type: text/plain;")[1]
                    .split("Content-Type: text/html;")[0];
            var potentialPatches = PatchFinder.findPatchLinks(threadRaw);
            for (String pp : potentialPatches) {
                // Checks for circular dep.
                if (pp != ref) {
                    var out = PatchFinder.parseReference(pp);
                    if (out != null) {
                        patches.addAll(out);
                    }
                }
            }
        }
        return patches;
    }

    /**
     * Parses Mercurial Revision extracting patches.
     * @param ref - ref to mercurial revision
     * @return set of patches found
     */
    public HashSet<Vulnerability.Patch> parseMercurialRevision(String ref) {
        logger.info("Parsing Mercurial Revision with URL: " + ref);
        ref = ref.replace("rev", "raw-rev");
        var content = httpClient.sendGet(ref);
        if (content.contains("error: unknown revision")) {
            return null;
        }
        var date = getDateFromMercurialRevision(content);
        try {
            var patches = new HashSet<>(DiffParser.getPatchesFromDiffs(content));
            patches.forEach(p -> p.setPatchDate(date));
            return patches;
        } catch (Exception e) {
            logger.error("Could not parse HG Revision" + ref );
            return null;
        }
    }

    /**
     * Extracts the date from a Mercurial revision.
     * Find information here: https://www.mercurial-scm.org/doc/hg.1.html#date-formats
     * @param patch - String patch
     * @return String date in ISOFormat if found
     */
    public String getDateFromMercurialRevision(String patch) {
        var splits = patch.split("# Date ");
        if (splits.length < 1)  return null;
        var date = splits[1].split("\\s")[0];
        if (!date.matches("\\d++"))   return null;
        return new DateTime(Long.parseLong(date)*1000l).toString(ISODateTimeFormat.date());
    }
}
