/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package eu.fasten.vulnerabilityproducer.utils.patches;

import com.mongodb.client.FindIterable;
import com.mongodb.client.MongoCollection;
import com.mongodb.client.MongoDatabase;
import eu.fasten.vulnerabilityproducer.utils.PatchFinder;
import eu.fasten.vulnerabilityproducer.utils.Vulnerability;
import eu.fasten.vulnerabilityproducer.utils.Vulnerability.*;
import eu.fasten.vulnerabilityproducer.utils.connections.GitHubAPI;
import eu.fasten.vulnerabilityproducer.utils.connections.JavaHttpClient;
import org.bson.Document;
import org.bson.conversions.Bson;
import org.joda.time.DateTime;
import org.joda.time.format.ISODateTimeFormat;
import org.jooq.tools.json.JSONObject;
import org.jooq.tools.json.JSONParser;
import org.jooq.tools.json.ParseException;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.util.HashSet;
import java.util.List;

import static com.mongodb.client.model.Filters.and;
import static com.mongodb.client.model.Filters.eq;

public class GitHubRanger extends GenericRanger{
    GitHubAPI gitHubAPI;
    public static MongoCollection<Document> mongoCommitsCollection;
    public static MongoCollection<Document> mongoPullRequestsCollection;
    public static MongoCollection<Document> mongoIssuesCollection;
    public Boolean ghTorrentAvailable = false;
    private final Logger logger = LoggerFactory.getLogger(GitHubRanger.class.getName());

    /**
     * GitHub Ranger constructor with GHTorrent as well.
     * @param httpClient - client to send HTTP requests.
     * @param db - MongoDatabase instance, GHTorrent
     */
    public GitHubRanger(JavaHttpClient httpClient,
                        MongoDatabase db,
                        String gitHubToken,
                        JSONParser jsonParser) {
        super(httpClient, jsonParser);
        this.gitHubAPI = new GitHubAPI(httpClient, gitHubToken, jsonParser);
        if (db != null) {
            mongoCommitsCollection = db.getCollection("commits");
            mongoPullRequestsCollection = db.getCollection("pull_requests");
            mongoIssuesCollection = db.getCollection("issues");
            this.ghTorrentAvailable = true;
        }
    }

    /**
     * Extracts information from Pull Request links.
     * First queries GHTorrent and if nothing is found use Github API
     *
     * @param pr            github link to the pull request
     * @return
     */
    public HashSet<Vulnerability.Patch> parseGHPullRequest(String pr) {
        if (pr.endsWith("/files"))  pr = pr.substring(0, pr.length() - 6);
        if (pr.endsWith("/commits"))  pr = pr.substring(0, pr.length() - 8);

        logger.info("Parsing pull request with URL: " + pr);
        var vp = new HashSet<Patch>();
        var infoPatch = pr.split("/");
        var repoOwner = infoPatch[3];
        var repoName = infoPatch[4];
        var prNumber = infoPatch[6];

        String jsonBody = null;
        if (ghTorrentAvailable) {
            // Query GHTorrent to find the corresponding Pull Request
            Bson filter = and(eq("repo", repoName),
                    eq("owner", repoOwner),
                    eq("number", prNumber));
            var mongoElement = mongoPullRequestsCollection.find(filter);
            if (mongoElement.first() != null) {
                jsonBody = mongoElement.first().toJson();
            }
        }

        if (jsonBody == null) {
            var apiLink = "https://api.github.com/repos/" + repoOwner + "/" + repoName + "/pulls/" + prNumber;
            jsonBody = httpClient.sendGet(apiLink);
            if (jsonBody.contains("\"message\": \"Not Found\"")) {
                return vp;
            }
        }

        // Look for a merge_commit_sha and use the parseCommit function
        // Parse the result and extract data
        Object obj = null;
        try {
            obj = jsonParser.parse(jsonBody);
        } catch (ParseException e) {
            e.printStackTrace();
        }
        var payload = (JSONObject) obj;
        if (payload.get("merge_commit_sha") != null) {
            // There is a commit we can parse
            var mergeCommitSHA = (String) payload.get("merge_commit_sha");
            var urlCommit = "https://github.com/" + repoOwner + "/" + repoName + "/commit/" + mergeCommitSHA;
            vp = this.parseGHCommit(urlCommit);
        }
        return vp;
    }

    /**
     * Method parses Github issues links found in the vulnerability references.
     *
     * @param issue         - link of the issue e.g. https://github.com/restlet/restlet-framework-java/issues/774
     *                      <p>
     *                      The script looks for a pull_request field in the json corresponding to the issue.
     *                      "pull_request": {
     *                      "url": "https://api.github.com/repos/python/cpython/pulls/32",
     *                      "html_url": "https://github.com/python/cpython/pull/32",
     *                      "diff_url": "https://github.com/python/cpython/pull/32.diff",
     *                      "patch_url": "https://github.com/python/cpython/pull/32.patch"
     *                      }
     * @return
     */
    public HashSet<Vulnerability.Patch> parseGHIssue(String issue) {
        logger.info("Parsing issue with URL: " + issue);
        // Validation URL and eventual cleanup
        if (issue.contains("#")) {
            issue = issue.split("#")[0];
            logger.info("Issue URL cleaned: " + issue);
        }

        var vp = new HashSet<Vulnerability.Patch>();
        var refs = new HashSet<String>();
        // Extract information from the patch and create API Link
        var infoPatch = issue.split("/");
        var repoOwner = infoPatch[3];
        var repoName = infoPatch[4];
        var issueNumber = infoPatch[6];

        String jsonBody = null;
        if (ghTorrentAvailable) {
            var mongoElement = mongoIssuesCollection.find(and(eq("repo", repoName),
                    eq("owner", repoOwner), eq("number", issueNumber)));
            if (mongoElement.first() != null) {
                jsonBody = mongoElement.first().toJson();
            }
        }

        if (jsonBody == null) {
            var apiLink = "https://api.github.com/repos/" + repoOwner + "/" + repoName + "/issues/" + issueNumber;
            jsonBody = httpClient.sendGet(apiLink);
            if (jsonBody.contains("\"message\": \"Not Found\"")) {
                return vp;
            }
        }

        // Look for a pull_request and use the parsePullRequest function
        // Parse the result and extract data
        Object obj = null;
        try {
            obj = jsonParser.parse(jsonBody);
        } catch (ParseException e) {
            e.printStackTrace();
        }
        var payload = (JSONObject) obj;
        if (payload.get("pull_request") != null) {
            // There is a commit we can parse
            var pullRequest = (JSONObject) payload.get("pull_request");
            var urlPullRequest = (String) pullRequest.get("html_url");
            vp = this.parseGHPullRequest(urlPullRequest);
        } else {
            // Extra checks to get more information out of it
            // PRs mentioning issues
            var prsMentionIssue = gitHubAPI.getPRsMentioningIssue(repoOwner, repoName, issueNumber);
            if (prsMentionIssue.size() > 0) {
                logger.info("Found " + prsMentionIssue.size() + " PRs mentioning issue from "
                        + repoOwner + "/" + repoName + "#" + issueNumber);

                for (String prCommit : prsMentionIssue) {
                    var pp = PatchFinder.parseReference(prCommit);
                    if (pp != null) vp.addAll(pp); refs.add(prCommit);
                }
            }


            // Get commit closing the issue
            var commitsClosingIssue = gitHubAPI.getCommitClosingIssue(repoOwner, repoName, issueNumber);
            if (commitsClosingIssue != null && !refs.contains(commitsClosingIssue)) {
                logger.info("Found " + commitsClosingIssue + " closing "
                        + repoOwner + "/" + repoName + "#" + issueNumber);
                var pp = PatchFinder.parseReference(commitsClosingIssue);
                if (pp != null) vp.addAll(pp);
            }

            // Get commits that reference issue
            var commitsReferencingIssue = gitHubAPI.getCommitsReferencingIssue(repoOwner,
                    repoName, issueNumber);
            if (commitsReferencingIssue.size() > 0) {
                logger.info("Found " + commitsReferencingIssue.size() + " commits referencing issue "
                        + repoOwner + "/" + repoName + "#" + issueNumber);

                for (String url : commitsReferencingIssue) {
                    if (refs.contains(url)) continue;
                    var commitInfo = PatchFinder.parseReference(url);
                    if (commitInfo != null) vp.addAll(commitInfo);
                }
            }

            // Get comments and look for references
            var potentialReferences = gitHubAPI.getReferencesInIssueComments(repoOwner,
                    repoName, issueNumber);
            if (potentialReferences.size() > 0) {
                logger.info("Found " + potentialReferences.size() + " references in comments of issue "
                        + repoOwner + "/" + repoName + "#" + issueNumber);

                for (String url : potentialReferences) {
                    if (refs.contains(url)  || url.equals(issue)) continue;
                    var potentialPatches = PatchFinder.parseReference(url);
                    if (potentialPatches != null) vp.addAll(potentialPatches);
                }
            }
        }
        return vp;
    }

    /**
     * Parses patch links to git commits using GitHub API v3.
     * Extracts the following information:
     * - files changed
     * - methods affected
     * - days it took to fix
     *
     * @param patchLink     URL to the git commit
     */
    public HashSet<Vulnerability.Patch> parseGHCommit(String patchLink) {
        // Validation URL and eventual cleanup
        patchLink = patchLink.split("#")[0].split("\\?")[0];

        logger.info("Parsing commit with URL: " + patchLink);
        var vp = new HashSet<Patch>();
        var infoPatch = patchLink.split("/");
        var commitHash = infoPatch[6];

        String jsonBody = null;
        if (ghTorrentAvailable) {
            FindIterable<Document> mongoElement = mongoCommitsCollection.find(eq("sha", commitHash));
            if (mongoElement.first() != null) {
                jsonBody = mongoElement.first().toJson();
            }
        }

        // If GHTorrent does not find it, query Github API
        if (jsonBody == null) {
            var repoOwner = infoPatch[3];
            var repoName = infoPatch[4];
            var apiLink = "https://api.github.com/repos/" + repoOwner + "/" + repoName + "/commits/" + commitHash;
            jsonBody = httpClient.sendGet(apiLink);
            if (jsonBody.contains("\"message\":\"Not Found\"") || jsonBody.contains("\"message\":\"No commit found for SHA")
            || jsonBody.contains("\"message\":\"Git Repository is empty.\"")) {
                return vp;
            }
        }

        // Parse the result and extract data
        Object obj = null;
        try {
            obj = jsonParser.parse(jsonBody);
        } catch (ParseException e) {
            e.printStackTrace();
        }
        var payload = (JSONObject) obj;
        var commit = (JSONObject) payload.get("commit");
        var author = (JSONObject) commit.get("author");
        var date = new DateTime(author.get("date")).toString(ISODateTimeFormat.date());
        var files = (List<Object>) payload.get("files");
        for (Object file : files) {
            var fileObj = (JSONObject) file;
            var filenameChanged = (String) fileObj.get("filename");
            if (filenameChanged.endsWith(".patch") || filenameChanged.endsWith(".diff")) continue;
            if (fileObj.get("patch") != null) {
                try {
                    var hunks = DiffParser.getPatchHunks(fileObj.get("patch").toString());
                    if (hunks.size() > 0) {
                        var p = new Patch(filenameChanged, date, hunks);
                        vp.add(p);
                    }
                } catch (Exception e) {
                    logger.error("Could not parse the diff for " + filenameChanged + " in GH Commit " + patchLink);
                }
            }
        }
        return vp;
    }
}
