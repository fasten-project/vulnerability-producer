/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package eu.fasten.vulnerabilityproducer.utils.patches;

import com.github.difflib.unifieddiff.UnifiedDiffParserException;
import com.mongodb.client.MongoCollection;
import com.mongodb.client.MongoDatabase;
import eu.fasten.vulnerabilityproducer.utils.Patch;
import eu.fasten.vulnerabilityproducer.utils.PatchFinder;
import eu.fasten.vulnerabilityproducer.utils.connections.GitHubAPI;
import eu.fasten.vulnerabilityproducer.utils.connections.JavaHttpClient;
import org.bson.Document;
import org.bson.conversions.Bson;
import org.joda.time.DateTime;
import org.joda.time.format.ISODateTimeFormat;
import org.jooq.tools.json.JSONObject;
import org.jooq.tools.json.JSONParser;
import org.jooq.tools.json.ParseException;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.util.HashSet;
import java.util.List;

import static com.mongodb.client.model.Filters.and;
import static com.mongodb.client.model.Filters.eq;

public class GitHubRanger extends GenericRanger{
    public GitHubAPI gitHubAPI;
    public static MongoCollection<Document> mongoCommitsCollection;
    public static MongoCollection<Document> mongoPullRequestsCollection;
    public static MongoCollection<Document> mongoIssuesCollection;
    public Boolean ghTorrentAvailable = false;
    private final Logger logger = LoggerFactory.getLogger(GitHubRanger.class.getName());

    /**
     * GitHub Ranger constructor with GHTorrent as well.
     * @param httpClient - client to send HTTP requests.
     * @param db - MongoDatabase instance, GHTorrent
     */
    public GitHubRanger(JavaHttpClient httpClient,
                        MongoDatabase db,
                        String gitHubToken,
                        JSONParser jsonParser) {
        super(httpClient, jsonParser);
        this.gitHubAPI = new GitHubAPI(httpClient, gitHubToken, jsonParser);
        if (db != null) {
            mongoCommitsCollection = db.getCollection("commits");
            mongoPullRequestsCollection = db.getCollection("pull_requests");
            mongoIssuesCollection = db.getCollection("issues");
            this.ghTorrentAvailable = true;
        }
    }

    /**
     * Extracts information from Pull Request links.
     * First queries GHTorrent and if nothing is found use Github API
     *
     * @param pr            github link to the pull request
     * @return              set of patches
     */
    public HashSet<Patch> parseGHPullRequest(String pr) {
        if (pr.endsWith("/files"))  pr = pr.substring(0, pr.length() - 6);
        if (pr.endsWith("/commits"))  pr = pr.substring(0, pr.length() - 8);

        logger.info("Parsing pull request with URL: " + pr);
        var vp = new HashSet<Patch>();
        var infoPatch = pr.split("/");
        var repoOwner = infoPatch[3];
        var repoName = infoPatch[4];
        var prNumber = infoPatch[6];

        String jsonBody = null;
        if (ghTorrentAvailable) {
            Bson filter = and(eq("repo", repoName),
                    eq("owner", repoOwner),
                    eq("number", prNumber));
            var mongoElement = mongoPullRequestsCollection.find(filter);
            if (mongoElement.first() != null) {
                jsonBody = mongoElement.first().toJson();
            }
        }

        if (jsonBody == null) {
            jsonBody = gitHubAPI.getPR(repoOwner, repoName, prNumber);
            if (jsonBody.isEmpty() || jsonBody.contains("\"message\": \"Not Found\"")) {
                return vp;
            }
        }

        Object obj = null;
        try {
            obj = jsonParser.parse(jsonBody);
        } catch (ParseException e) {
            logger.error(String.valueOf(e));
        }
        var payload = (JSONObject) obj;
        if (payload.get("merge_commit_sha") != null) {
            var mergeCommitSHA = (String) payload.get("merge_commit_sha");
            var urlCommit = "https://github.com/" + repoOwner + "/" + repoName + "/commit/" + mergeCommitSHA;
            vp = this.parseGHCommit(urlCommit);
        }
        return vp;
    }

    /**
     * Method parses Github issues links found in the vulnerability references.
     *
     * @param issue Link to a GitHub issue to parse
     * @return set of patches
     */
    public HashSet<Patch> parseGHIssue(String issue) {
        logger.info("Parsing issue with URL: " + issue);
        issue = issue.split("#")[0];

        var vp   = new HashSet<Patch>();
        var refs = new HashSet<String>();
        var infoPatch   = issue.split("/");
        var repoOwner   = infoPatch[3];
        var repoName    = infoPatch[4];
        var issueNumber = infoPatch[6];

        String jsonBody = null;
        if (ghTorrentAvailable) {
            var mongoElement = mongoIssuesCollection.find(and(eq("repo", repoName),
                    eq("owner", repoOwner), eq("number", issueNumber)));
            if (mongoElement.first() != null) {
                jsonBody = mongoElement.first().toJson();
            }
        }

        if (jsonBody == null) {
            jsonBody = gitHubAPI.getIssue(repoOwner, repoName, issueNumber);
            if (jsonBody.isEmpty() || jsonBody.contains("\"message\": \"Not Found\"")) {
                return vp;
            }
        }

        Object obj = null;
        try {
            obj = jsonParser.parse(jsonBody);
        } catch (ParseException e) {
            logger.error(String.valueOf(e));
        }
        var payload = (JSONObject) obj;
        if (payload.get("pull_request") != null) {
            var pullRequest = (JSONObject) payload.get("pull_request");
            var urlPullRequest = (String) pullRequest.get("html_url");
            vp = this.parseGHPullRequest(urlPullRequest);
        } else {
            var prsMentionIssue = gitHubAPI.getPRsMentioningIssue(repoOwner, repoName, issueNumber);
            if (prsMentionIssue.size() > 0) {
                logger.info("Found " + prsMentionIssue.size() + " PRs mentioning issue from "
                        + repoOwner + "/" + repoName + "#" + issueNumber);

                for (String prCommit : prsMentionIssue) {
                    var pp = PatchFinder.parseReference(prCommit);
                    if (pp != null) vp.addAll(pp); refs.add(prCommit);
                }
            }

            var commitsClosingIssue = gitHubAPI.getCommitClosingIssue(repoOwner, repoName, issueNumber);
            if (commitsClosingIssue != null && !refs.contains(commitsClosingIssue)) {
                logger.info("Found " + commitsClosingIssue + " closing "
                        + repoOwner + "/" + repoName + "#" + issueNumber);
                var pp = PatchFinder.parseReference(commitsClosingIssue);
                if (pp != null) vp.addAll(pp);
            }

            var commitsReferencingIssue = gitHubAPI.getCommitsReferencingIssue(repoOwner, repoName, issueNumber);
            if (commitsReferencingIssue.size() > 0) {
                logger.info("Found " + commitsReferencingIssue.size() + " commits referencing issue "
                        + repoOwner + "/" + repoName + "#" + issueNumber);

                for (String url : commitsReferencingIssue) {
                    if (refs.contains(url)) continue;
                    var commitInfo = PatchFinder.parseReference(url);
                    if (commitInfo != null) vp.addAll(commitInfo);
                }
            }

            var potentialReferences = gitHubAPI.getReferencesInIssueComments(repoOwner, repoName, issueNumber);
            if (potentialReferences.size() > 0) {
                logger.info("Found " + potentialReferences.size() + " references in comments of issue "
                        + repoOwner + "/" + repoName + "#" + issueNumber);

                for (String url : potentialReferences) {
                    if (refs.contains(url)  || url.equals(issue)) continue;
                    var potentialPatches = PatchFinder.parseReference(url);
                    if (potentialPatches != null) vp.addAll(potentialPatches);
                }
            }
        }
        return vp;
    }

    /**
     * Parses patch links to git commits using GitHub API v3.
     * Extracts the following information:
     * - files changed
     * - methods affected
     * - days it took to fix
     *
     * @param patchLink     URL to the git commit
     */
    public HashSet<Patch> parseGHCommit(String patchLink) {
        patchLink = patchLink.split("#")[0].split("\\?")[0];

        logger.info("Parsing commit with URL: " + patchLink);
        var vp = new HashSet<Patch>();
        var infoPatch = patchLink.split("/");
        var repoOwner = infoPatch[3];
        var repoName = infoPatch[4];
        var commitHash = infoPatch[6];

        String jsonBody = null;
        if (ghTorrentAvailable) {
            var mongoElement = mongoCommitsCollection.find(eq("sha", commitHash));
            if (mongoElement.first() != null) {
                jsonBody = mongoElement.first().toJson();
            }
        }

        if (jsonBody == null) {
            jsonBody = gitHubAPI.getCommit(repoOwner, repoName, commitHash);
            if (jsonBody.isEmpty()
            || jsonBody.contains("\"message\":\"Not Found\"")
            || jsonBody.contains("\"message\":\"No commit found for SHA")
            || jsonBody.contains("\"message\":\"Git Repository is empty.\"")) {
                return vp;
            }
        }

        Object obj = null;
        try {
            obj = jsonParser.parse(jsonBody);
        } catch (ParseException e) {
            logger.error(String.valueOf(e));
        }
        var payload = (JSONObject) obj;
        var commit = (JSONObject) payload.get("commit");
        var author = (JSONObject) commit.get("author");
        var date = new DateTime(author.get("date")).toString(ISODateTimeFormat.date());
        var files = (List<Object>) payload.get("files");
        for (Object file : files) {
            var fileObj = (JSONObject) file;
            var filenameChanged = (String) fileObj.get("filename");
            if (fileObj.get("patch") != null) {
                try {
                    var patches = DiffParser.getPatchesFromGitHubDiff(fileObj.get("patch").toString(), filenameChanged);
                    if (patches.size() == 0)   continue;
                    patchLink = "git://github.com/" + repoOwner + "/" + repoName + "@" + commitHash;
                    var finalPatchLink = patchLink;
                    patches.forEach(p -> {
                        p.setPatchDate(date);
                        p.setPatchUrl(finalPatchLink);
                    });
                    vp.addAll(patches);
                } catch (UnifiedDiffParserException e) {
                    logger.error("Could not parse diff for " + patchLink);
                }
            }
        }
        return vp;
    }
}
