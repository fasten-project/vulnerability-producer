/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package eu.fasten.vulnerabilityproducer.utils.patches;

import com.mongodb.client.FindIterable;
import com.mongodb.client.MongoCollection;
import com.mongodb.client.MongoDatabase;
import eu.fasten.vulnerabilityproducer.utils.PatchFinder;
import eu.fasten.vulnerabilityproducer.utils.Vulnerability;
import eu.fasten.vulnerabilityproducer.utils.connections.GitHubAPI;
import eu.fasten.vulnerabilityproducer.utils.connections.JavaHttpClient;
import org.bson.Document;
import org.bson.conversions.Bson;
import org.joda.time.DateTime;
import org.joda.time.format.ISODateTimeFormat;
import org.jooq.tools.json.JSONObject;
import org.jooq.tools.json.JSONParser;
import org.jooq.tools.json.ParseException;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.util.HashSet;
import java.util.List;

import static com.mongodb.client.model.Filters.and;
import static com.mongodb.client.model.Filters.eq;

public class GitHubRanger extends GenericRanger{
    GitHubAPI gitHubAPI;
    public static MongoCollection<Document> mongoCommitsCollection;
    public static MongoCollection<Document> mongoPullRequestsCollection;
    public static MongoCollection<Document> mongoIssuesCollection;
    private final Logger logger = LoggerFactory.getLogger(GitHubRanger.class.getName());

    /**
     *
     * @param httpClient
     * @param db
     */
    public GitHubRanger(JavaHttpClient httpClient,
                        MongoDatabase db,
                        String gitHubToken,
                        JSONParser jsonParser) {
        super(httpClient, jsonParser);
        this.gitHubAPI = new GitHubAPI(httpClient, gitHubToken, jsonParser);
        mongoCommitsCollection = db.getCollection("commits");
        mongoPullRequestsCollection = db.getCollection("pull_requests");
        mongoIssuesCollection = db.getCollection("issues");
    }

    /**
     * Extracts information from Pull Request links.
     * First queries GHTorrent and if nothing is found use Github API
     *
     * @param pr            github link to the pull request
     * @return
     */
    public HashSet<Vulnerability.Patch> parseGHPullRequest(String pr) {
        if (pr.endsWith("/files"))  pr = pr.substring(0, pr.length() - 6);
        if (pr.endsWith("/commits"))  pr = pr.substring(0, pr.length() - 8);

        logger.info("Parsing pull request with URL: " + pr);
        String jsonBody = null;
        HashSet<Vulnerability.Patch> vp = new HashSet<>();
        // Extract information from the patch and create API Link
        String[] infoPatch = pr.split("/");
        String repoOwner = infoPatch[3];
        String repoName = infoPatch[4];
        String prNumber = infoPatch[6];
        // Query GHTorrent to find the corresponding Pull Request
        Bson filter = and(eq("repo", repoName),
                eq("owner", repoOwner),
                eq("number", prNumber));
        FindIterable<Document> mongoElement = mongoPullRequestsCollection.find(filter);
        if (mongoElement.first() != null) {
            jsonBody = mongoElement.first().toJson();
        }

        // If GhTorrent does not find it, query Github API
        if (jsonBody == null) {
            String apiLink = "https://api.github.com/repos/" + repoOwner + "/" + repoName + "/pulls/" + prNumber;
            // Send GET request
            jsonBody = httpClient.sendGet(apiLink);
            if (jsonBody.contains("\"message\": \"Not Found\"")) {
                return vp;
            }
            // TODO: If it was not on GHTorrent, write it in there (?)
        }

        // Look for a merge_commit_sha and use the parseCommit function
        // Parse the result and extract data
        Object obj = null;
        try {
            obj = jsonParser.parse(jsonBody);
        } catch (ParseException e) {
            e.printStackTrace();
        }
        JSONObject payload = (JSONObject) obj;
        if (payload.get("merge_commit_sha") != null) {
            // There is a commit we can parse
            String mergeCommitSHA = (String) payload.get("merge_commit_sha");
            String urlCommit = "https://github.com/" + repoOwner + "/" + repoName + "/commit/" + mergeCommitSHA;
            vp = this.parseGHCommit(urlCommit);
        }
        return vp;
    }

    /**
     * Method parses Github issues links found in the vulnerability references.
     *
     * @param issue         - link of the issue e.g. https://github.com/restlet/restlet-framework-java/issues/774
     *                      <p>
     *                      The script looks for a pull_request field in the json corresponding to the issue.
     *                      "pull_request": {
     *                      "url": "https://api.github.com/repos/python/cpython/pulls/32",
     *                      "html_url": "https://github.com/python/cpython/pull/32",
     *                      "diff_url": "https://github.com/python/cpython/pull/32.diff",
     *                      "patch_url": "https://github.com/python/cpython/pull/32.patch"
     *                      }
     * @return
     */
    public HashSet<Vulnerability.Patch> parseGHIssue(String issue) {
        logger.info("Parsing issue with URL: " + issue);
        // Validation URL and eventual cleanup
        if (issue.contains("#")) {
            issue = issue.split("#")[0];
            logger.info("Issue URL cleaned: " + issue);
        }

        String jsonBody = null;
        var vp = new HashSet<Vulnerability.Patch>();
        var refs = new HashSet<String>();
        // Extract information from the patch and create API Link
        var infoPatch = issue.split("/");
        var repoOwner = infoPatch[3];
        var repoName = infoPatch[4];
        var issueNumber = infoPatch[6];
        // Query GHTorrent to find the corresponding Pull Request
        var mongoElement = mongoIssuesCollection.find(and(eq("repo", repoName),
                eq("owner", repoOwner), eq("number", issueNumber)));
        if (mongoElement.first() != null) {
            jsonBody = mongoElement.first().toJson();
        }
        // If GhTorrent does not find it, query Github API
        if (jsonBody == null) {
            var apiLink = "https://api.github.com/repos/" + repoOwner + "/" + repoName + "/issues/" + issueNumber;
            // Send GET request
            jsonBody = httpClient.sendGet(apiLink);
            if (jsonBody.contains("\"message\": \"Not Found\"")) {
                return vp;
            }
            // TODO: If it was not on GHTorrent, write it in there (?)
        }

        // Look for a pull_request and use the parsePullRequest function
        // Parse the result and extract data
        Object obj = null;
        try {
            obj = jsonParser.parse(jsonBody);
        } catch (ParseException e) {
            e.printStackTrace();
        }
        var payload = (JSONObject) obj;
        if (payload.get("pull_request") != null) {
            // There is a commit we can parse
            var pullRequest = (JSONObject) payload.get("pull_request");
            var urlPullRequest = (String) pullRequest.get("html_url");
            vp = this.parseGHPullRequest(urlPullRequest);
        } else {
            // Extra checks to get more information out of it
            // PRs mentioning issues
            var prsMentionIssue = gitHubAPI.getPRsMentioningIssue(repoOwner, repoName, issueNumber);
            if (prsMentionIssue.size() > 0) {
                logger.info("Found " + prsMentionIssue.size() + " PRs mentioning issue from "
                        + repoOwner + "/" + repoName + "#" + issueNumber);

                for (String prCommit : prsMentionIssue) {
                    var pp = PatchFinder.parseReference(prCommit);
                    if (pp != null) vp.addAll(pp); refs.add(prCommit);
                }
            }


            // Get commit closing the issue
            var commitsClosingIssue = gitHubAPI.getCommitClosingIssue(repoOwner, repoName, issueNumber);
            if (commitsClosingIssue != null && !refs.contains(commitsClosingIssue)) {
                logger.info("Found " + commitsClosingIssue + " closing "
                        + repoOwner + "/" + repoName + "#" + issueNumber);
                var pp = PatchFinder.parseReference(commitsClosingIssue);
                if (pp != null) vp.addAll(pp);
            }

            // Get commits that reference issue
            var commitsReferencingIssue = gitHubAPI.getCommitsReferencingIssue(repoOwner,
                    repoName, issueNumber);
            if (commitsReferencingIssue.size() > 0) {
                logger.info("Found " + commitsReferencingIssue.size() + " commits referencing issue "
                        + repoOwner + "/" + repoName + "#" + issueNumber);

                for (String url : commitsReferencingIssue) {
                    if (refs.contains(url)) continue;
                    var commitInfo = PatchFinder.parseReference(url);
                    if (commitInfo != null) vp.addAll(commitInfo);
                }
            }

            // Get comments and look for references
            var potentialReferences = gitHubAPI.getReferencesInIssueComments(repoOwner,
                    repoName, issueNumber);
            if (potentialReferences.size() > 0) {
                logger.info("Found " + potentialReferences.size() + " references in comments of issue "
                        + repoOwner + "/" + repoName + "#" + issueNumber);

                for (String url : potentialReferences) {
                    if (refs.contains(url)  || url.equals(issue)) continue;
                    var potentialPatches = PatchFinder.parseReference(url);
                    if (potentialPatches != null) vp.addAll(potentialPatches);
                }
            }
        }
        return vp;
    }

    /**
     * Parses patch links to git commits using GitHub API v3.
     * Extracts the following information:
     * - files changed
     * - methods affected
     * - days it took to fix
     *
     * @param patchLink     URL to the git commit
     */
    public HashSet<Vulnerability.Patch> parseGHCommit(String patchLink) {
        // Validation URL and eventual cleanup
        patchLink = patchLink.split("#")[0].split("\\?")[0];

        logger.info("Parsing commit with URL: " + patchLink);
        String jsonBody = null;
        HashSet<Vulnerability.Patch> vp = new HashSet<>();
        // Extract information from the patch and create API Link
        String[] infoPatch = patchLink.split("/");
        String commitHash = infoPatch[6];
        // Query GHTorrent with the hash of the commit
        FindIterable<Document> mongoElement = mongoCommitsCollection.find(eq("sha", commitHash));
        if (mongoElement.first() != null) {
            jsonBody = mongoElement.first().toJson();
        }

        // If GHTorrent does not find it, query Github API
        if (jsonBody == null) {
            String repoOwner = infoPatch[3];
            String repoName = infoPatch[4];
            String apiLink = "https://api.github.com/repos/" + repoOwner + "/" + repoName + "/commits/" + commitHash;
            // Send GET request
            jsonBody = httpClient.sendGet(apiLink);
            if (jsonBody.contains("\"message\":\"Not Found\"") || jsonBody.contains("\"message\":\"No commit found for SHA")) {
                return vp;
            }
        }

        // Parse the result and extract data
        Object obj = null;
        try {
            obj = jsonParser.parse(jsonBody);
        } catch (ParseException e) {
            e.printStackTrace();
        }
        JSONObject payload = (JSONObject) obj;
        JSONObject commit = (JSONObject) payload.get("commit");
        JSONObject author = (JSONObject) commit.get("author");
        String date = new DateTime(author.get("date")).toString(ISODateTimeFormat.date());
        List<Object> files = (List<Object>) payload.get("files");
        for (Object file : files) {
            JSONObject fileObj = (JSONObject) file;
            String filenameChanged = (String) fileObj.get("filename");
            if (fileObj.get("patch") != null) {
                List<Integer> hunks = DiffParser.getPatchHunks(fileObj.get("patch").toString());
                Vulnerability.Patch p = new Vulnerability.Patch(filenameChanged, date, hunks);
                vp.add(p);
            }
        }
        return vp;
    }
}
