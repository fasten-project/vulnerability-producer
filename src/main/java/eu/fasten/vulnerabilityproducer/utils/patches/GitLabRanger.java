/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package eu.fasten.vulnerabilityproducer.utils.patches;

import eu.fasten.vulnerabilityproducer.utils.*;
import eu.fasten.vulnerabilityproducer.utils.Vulnerability.*;
import eu.fasten.vulnerabilityproducer.utils.connections.JavaHttpClient;
import org.joda.time.DateTime;
import org.joda.time.format.ISODateTimeFormat;
import org.jooq.tools.json.JSONArray;
import org.jooq.tools.json.JSONObject;
import org.jooq.tools.json.JSONParser;
import org.jooq.tools.json.ParseException;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.util.HashSet;

public class GitLabRanger extends GenericRanger {
    private final Logger logger = LoggerFactory.getLogger(GitLabRanger.class.getName());

    public GitLabRanger(JavaHttpClient httpClient, JSONParser jsonParser) {
        super(httpClient, jsonParser);
    }

    /**
     * Parses link from a GitLab commit.
     * Add .diff to the link to extract the raw diff of the file.
     *
     * @param ref - commit link
     * @return - Set of Patches
     */
    public HashSet<Patch> parseGLCommit(String ref) {
        logger.info("Parsing GitLab commit with URL: " + ref);
        var patches = new HashSet<Patch>();
        var values  = ref.split("/");
        var base = values[2];
        var org  = values[3];
        var project   = values[4];
        var commitSha = values[7];
        var projectId = getGitLabProjectId(base, org, project);
        var linkToCommit = "https://" + base + "/api/v4/projects/"+ projectId +"/repository/commits/" + commitSha;
        var commitJson   = httpClient.sendGet(linkToCommit);
        if (commitJson.contains("404 Commit Not Found"))    return patches;

        try {
            var payload = (JSONObject) jsonParser.parse(commitJson);
            var date = new DateTime(payload.get("created_at")).toString(ISODateTimeFormat.date());
            var linkToDiff = payload.get("web_url") + ".diff";
            var rawDiff = httpClient.sendGet(linkToDiff);
            patches = DiffParser.getPatchesFromUnifiedDiff(rawDiff);
            var vcsPatch = "git://" + base + "/" + org + "/" + project + "@" + commitSha;
            patches.forEach(patch -> {
                patch.setPatchDate(date);
                patch.setPatchUrl(vcsPatch);
            });
        } catch (Exception e) {
            logger.error("Could not parse GitLab commit: " + ref);
        }
        return patches;
    }

    /**
     * Parses a GitLab issue in order to extract patches.
     * Looks for related_merge_requests connected to the issues.
     * For each of those retrieves the merging commit diff.
     * @param ref - String reference for the issue
     * @return - Set of Patches
     */
    public HashSet<Patch> parseGLIssue(String ref) {
        logger.info("Parsing GitLab issue with URL: " + ref);
        var values  = ref.split("/");
        var base    = values[2];
        var org     = values[3];
        var project = values[4];
        var issuesNumber = ref.split("/")[7];
        var projectId    = getGitLabProjectId(base, org, project);
        var patches = new HashSet<Patch>();
        var linkMrs = "https://" + base + "/api/v4/projects/"+ projectId +
                      "/issues/" + issuesNumber + "/related_merge_requests";
        var mrJson  = httpClient.sendGet(linkMrs);
        try {
            var payload = (JSONArray) jsonParser.parse(mrJson);
            for (Object element : payload) {
                var mr  = (JSONObject) element;
                String sha = null;
                if (mr.get("sha") != null)              sha = mr.get("sha").toString();
                if (mr.get("merge_commit_sha") != null) sha = mr.get("merge_commit_sha").toString();
                if (sha != null) {
                    var date = new DateTime(mr.get("merged_at")).toString(ISODateTimeFormat.date());
                    var linkToDiff = "https://" + base + "/" + org + "/" + project + "/-/"
                                   + "commit/" + sha + ".diff";
                    var rawDiff = httpClient.sendGet(linkToDiff);
                    var fixingPatches = DiffParser.getPatchesFromUnifiedDiff(rawDiff);
                    fixingPatches.forEach(patch -> {
                        patch.setPatchDate(date);
                        patch.setPatchUrl(ref);
                    });
                    patches.addAll(fixingPatches);
                }
            }
        } catch (Exception e) {
            logger.error("Could not parse GitLab issue: " + ref);
        }
        return patches;
    }

    /**
     * Parses a GitLab merge request to extract patches.
     * Looks for the merge_commit_sha.
     * Extracts diffs of this commit.
     * @param ref - String reference for the merge_request
     * @return - Set of Patches
     */
    public HashSet<Patch> parseGLMergeRequest(String ref) {
        logger.info("Parsing GitLab merge request with URL: " + ref);
        var patches   = new HashSet<Patch>();
        var values    = ref.split("/");
        var base      = values[2];
        var org       = values[3];
        var project   = values[4];
        var mrNumber  = values[7];
        var projectId = getGitLabProjectId(base, org, project);
        var linkToMr  = "https://" + base + "/api/v4/projects/"+ projectId +"/merge_requests/" + mrNumber;
        var mrJson = httpClient.sendGet(linkToMr);
        if (mrJson.contains("404 Not Found"))    return patches;

        try {
            var payload = (JSONObject) jsonParser.parse(mrJson);
            var date = new DateTime(payload.get("merged_at")).toString(ISODateTimeFormat.date());
            var linkToDiff = "https://" + base + "/" + org + "/" + project + "/-/commit/";
            if (payload.get("merge_commit_sha") != null)                      linkToDiff += (payload.get("merge_commit_sha") + ".diff");
            if (!linkToDiff.endsWith(".diff") && payload.get("sha") != null)  linkToDiff += (payload.get("sha") + ".diff");

            if (linkToDiff.endsWith(".diff")) {
                var rawDiff = httpClient.sendGet(linkToDiff);
                patches = DiffParser.getPatchesFromUnifiedDiff(rawDiff);
                patches.forEach(patch -> {
                    patch.setPatchDate(date);
                    patch.setPatchUrl(ref);
                });
            }
        } catch (Exception e) {
            logger.error("Could not parse GitLab MR: " + ref);
        }
        return patches;
    }

    /**
     * Finds the project-ID for a GitLab project.
     * @param org - Organization name
     * @param project - Project
     * @return
     */
    private Long getGitLabProjectId(String base, String org, String project) {
        var url = "https://" + base +"/api/v4/projects/" + org + "%2F" + project;
        var projectInfo = httpClient.sendGet(url);
        if (projectInfo.contains("404 Project Not Found"))  return null;
        try {
            var payload = (JSONObject) jsonParser.parse(projectInfo);
            return payload.get("id") != null ? (Long) payload.get("id") : null;
        } catch (ParseException e) {
            e.printStackTrace();
        }
        return null;
    }
}
