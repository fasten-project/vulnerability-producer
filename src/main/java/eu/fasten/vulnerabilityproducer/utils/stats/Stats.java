/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package eu.fasten.vulnerabilityproducer.utils.stats;

import eu.fasten.vulnerabilityproducer.utils.Vulnerability;
import net.steppschuh.markdowngenerator.table.Table;
import net.steppschuh.markdowngenerator.text.heading.Heading;
import org.apache.commons.io.FileUtils;

import java.io.*;
import java.net.MalformedURLException;
import java.net.URL;
import java.util.*;
import java.util.concurrent.atomic.*;
import java.util.stream.Collectors;

import static java.util.stream.Collectors.toSet;
import static java.util.stream.Stream.of;

public class Stats {
    public static void saveStats(HashSet<Vulnerability> vulnerabilities, String pathToStatsFolder) {
        // Create and save a MarkDown with the summary of the stats
        var sb = new StringBuilder()
                .append(new Heading("Summary", 1)).append("\n");

        // Save all refs:
        var refs = vulnerabilities.stream().map(v ->
                of(v.getReferences(), v.getPatchLinks()).flatMap(Set::stream).collect(toSet()))
                .flatMap(Set::stream)
                .collect(Collectors.toCollection(HashSet::new));

        try {
            FileUtils.writeStringToFile(new File(pathToStatsFolder + "refs.txt"),
                    refs.stream().map(ref -> ref + "\n").collect(Collectors.joining()));
        } catch (IOException e) {
            e.printStackTrace();
        }

        // Compute some distribution/analysis over the refs
        var refMap = new HashMap<String, Integer>();
        refs.forEach(ref -> {
            var base = getBaseRef(ref);
            if (base == null)   return;
            refMap.put(base, refMap.getOrDefault(base, 0) + 1);
        });

        // Sorting based on the frequency
        var keys = new LinkedList<>(refMap.keySet());
        Collections.sort(keys, Comparator.comparingInt(refMap::get).reversed());

        var tableBuilder = new Table.Builder()
                .withAlignments(Table.ALIGN_LEFT, Table.ALIGN_RIGHT)
                .addRow("Base URL", "Count");

        for (int i = 0; i < Math.min(refMap.size(), 20); i++) {
            var key = keys.get(i);
            tableBuilder.addRow(key, refMap.get(key));
        }

        sb.append(new Heading("References Info", 2)).append("\n");
        sb.append(tableBuilder.build()).append("\n");


        // Collect more info regarding vulnerabilities
        int vulnsWithPurl = 0;
        int vulnsWithPatches = 0;

        int vulnsWithPatchesNoPurls = 0;
        int vulnsWithLinksNoPatches = 0;

        for (Vulnerability v : vulnerabilities) {
            if (v.getPurls().size() > 0)   vulnsWithPurl++;
            if (v.getPatches().size() > 0) {
                vulnsWithPatches++;
            } else {
                if (v.getPatchLinks().size() > 0) {
                    vulnsWithLinksNoPatches++;
                    try {
                        FileUtils.writeStringToFile(
                                new File(pathToStatsFolder + "/lbnp/" + v.getId() + ".json"),
                                v.toJson());
                    } catch (IOException e) {
                        e.printStackTrace();
                    }
                }
            }
            if (v.getPatches().size() > 0 && v.getPurls().size() == 0) {
                // This is really important!! We cannot let this go by
                try {
                    FileUtils.writeStringToFile(
                            new File(pathToStatsFolder + "/pbnp/" + v.getId() + ".json"),
                            v.toJson());
                } catch (IOException e) {
                    e.printStackTrace();
                }
                vulnsWithPatchesNoPurls++;
            }
        }

        var tableStat = new Table.Builder().withAlignments(Table.ALIGN_LEFT, Table.ALIGN_RIGHT);
        tableStat.addRow("Vulnerabilities", "Quantity");
        tableStat.addRow("With PURL", vulnsWithPurl);
        tableStat.addRow("With Patches", vulnsWithPatches);
        tableStat.addRow("With Patches but no PURL", vulnsWithPatchesNoPurls);
        tableStat.addRow("With Patch Links but no patch", vulnsWithLinksNoPatches);
        tableStat.addRow("Total", vulnerabilities.size());

        sb.append(new Heading("General Info", 2)).append("\n");
        sb.append(tableStat.build());

        try {
            FileUtils.writeStringToFile(
                    new File(pathToStatsFolder + "stats.md"), sb.toString());
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    private static String getBaseRef(String ref) {
        try {
            var url = new URL(ref);
            var baseUrl = url.getProtocol() + "://" + url.getHost();
            return baseUrl;
        } catch (MalformedURLException e) {
            return null;
        }
    }

    public static void storeCVEsWithPurls(List<Vulnerability> vulnerabilities) {
        var cvesWithPurls = vulnerabilities.stream().filter(v -> v.getPurls().size() > 0)
                .map(Vulnerability::getId).collect(Collectors.toList());
        try {
            var writer = new FileWriter("/path/to/file.txt");
            for(String str: cvesWithPurls) {
                writer.write(str + System.lineSeparator());
            }
            writer.close();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    public static void printStats(HashMap<String, Vulnerability> vulns) {
        printStats(new ArrayList<>(vulns.values()));
    }

    public static void printStats(PriorityQueue<Vulnerability> vulns) {
        printStats(new ArrayList<>(vulns));
    }

    public static void printStats(ArrayList<Vulnerability> vulns) {
        var vp     = new AtomicInteger();
        var vp_mvn = new AtomicInteger();
        var vp_c   = new AtomicInteger();
        var vp_py  = new AtomicInteger();

        vulns.forEach(v -> {
            if (v.getPurls().size() > 0) {
                vp.addAndGet(1);
                var base = v.getPurls().get(0).split("@")[0];
                if (base.startsWith("pkg:maven"))    vp_mvn.addAndGet(1);
                if (base.startsWith("pkg:pypi"))     vp_py.addAndGet(1);
                if (base.startsWith("pkg:deb"))      vp_c.addAndGet(1);
            }
        });

        System.out.println("");
        System.out.println("Statistics:");
        System.out.println("    Total Purls: " + vp.get());
        System.out.println("          Maven Purls: " + vp_mvn.get());
        System.out.println("           PyPI Purls: " + vp_py.get());
        System.out.println("         Debian Purls: " + vp_c.get());
        System.out.println("");
    }
}
