/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package eu.fasten.vulnerabilityproducer;

import com.mongodb.client.FindIterable;
import com.mongodb.client.MongoCollection;
import com.mongodb.client.MongoDatabase;
import eu.fasten.vulnerabilityproducer.db.NitriteController;
import eu.fasten.vulnerabilityproducer.db.PatchObject;
import eu.fasten.vulnerabilityproducer.utils.PatchFarmer;
import eu.fasten.vulnerabilityproducer.utils.connections.JavaHttpClient;
import eu.fasten.vulnerabilityproducer.utils.Vulnerability;
import org.apache.commons.io.FileUtils;
import org.bson.Document;
import org.bson.conversions.Bson;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.mockito.Mockito;

import java.io.File;
import java.io.IOException;
import java.nio.charset.StandardCharsets;
import java.util.*;
import java.util.stream.Collectors;

import static com.mongodb.client.model.Filters.eq;
import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.junit.jupiter.api.Assertions.assertTrue;
import static org.mockito.Mockito.when;

public class PatchFarmerTest {

    // Inject Java Http Client to test
    JavaHttpClient clientMock = Mockito.mock(JavaHttpClient.class);

    // Inject mock database in order to test
    MongoDatabase dbMock = Mockito.mock(MongoDatabase.class);
    MongoCollection<Document> commitsMock = Mockito.mock(MongoCollection.class);
    MongoCollection<Document> prsMock = Mockito.mock(MongoCollection.class);
    MongoCollection<Document> issuesMock = Mockito.mock(MongoCollection.class);
    NitriteController nc = Mockito.mock(NitriteController.class);
    private PatchFarmer patchFarmer;

    static final String validJSON = "{" +
            "\"comment\":\"Testing\"," +
            "\"cve_id\":\"CVE-TEST-TEST\"," +
            "\"cwes\":[]," +
            "\"description\":\"Retrieve Relevant files\"," +
            "\"exploit_exists\":false," +
            "\"has_annotations\":true," +
            "\"is_processed\":true," +
            "\"langs\":[]," +
            "\"master_commit\":{" +
                "\"commit_hash\":\"hash\"," +
                "\"commit_link\":\"https://github.com/generic_commit\"," +
                "\"relevant_files\":[\"./src/index.c\",\"./src/mock.c\"]," +
                "\"repo_name\":\"test\"," +
                "\"repo_owner\":\"random\"," +
                "\"repo_url\":\"" +
            "\"}," +
            "\"products\":[]," +
            "\"references\":[]," +
            "\"score\":null" +
            "}";

    final String emptyMasterCommit = "{" +
            "\"comment\":\"Testing JSON body valid\"," +
            "\"cve_id\":\"CVE-TEST-TEST\"," +
            "\"cwes\":[]," +
            "\"description\":\"n/a\"," +
            "\"exploit_exists\":false," +
            "\"has_annotations\":true," +
            "\"is_processed\":true," +
            "\"langs\":[\"ANY\"]," +
            "\"master_commit\":{}," +
            "\"products\":[{\"product\":\"python\",\"vendor\":\"python\"}]," +
            "\"references\":[]," +
            "\"score\":null" +
            "}";

    final String genericPatch = "diff --git a/lib/stek.c b/lib/stek.c\n" +
            "index 2f885cee372d519379d238a4fdd26346c4afcd66..5ab9e7d2d1ce10d7916f11b6851135e8772425ef 100644\n" +
            "--- a/lib/stek.c\n" +
            "+++ b/lib/stek.c\n" +
            "@@ -323,20 +323,13 @@ int _gnutls_initialize_session_ticket_key_rotation(gnutls_session_t session, con\n" +
            " \tif (unlikely(session == NULL || key == NULL))\n" +
            " \t\treturn gnutls_assert_val(GNUTLS_E_INTERNAL_ERROR);\n" +
            " \n" +
            "-\tif (session->key.totp.last_result == 0) {\n" +
            "-\t\tint64_t t;\n" +
            "-\t\tmemcpy(session->key.initial_stek, key->data, key->size);\n" +
            "-\t\tt = totp_next(session);\n" +
            "-\t\tif (t < 0)\n" +
            "-\t\t\treturn gnutls_assert_val(t);\n" +
            "+\tif (unlikely(session->key.totp.last_result != 0))\n" +
            "+\t\treturn GNUTLS_E_INVALID_REQUEST;\n" +
            " \n" +
            "-\t\tsession->key.totp.last_result = t;\n" +
            "-\t\tsession->key.totp.was_rotated = 0;\n" +
            "-\n" +
            "-\t\treturn GNUTLS_E_SUCCESS;\n" +
            "-\t}\n" +
            "+\tmemcpy(session->key.initial_stek, key->data, key->size);\n" +
            " \n" +
            "-\treturn GNUTLS_E_INVALID_REQUEST;\n" +
            "+\tsession->key.totp.was_rotated = 0;\n" +
            "+\treturn 0;\n" +
            " }\n" +
            " \n" +
            " /*\n" +
            "diff --git a/tests/resume-with-previous-stek.c b/tests/resume-with-previous-stek.c\n" +
            "index f212b188b9b63b83215add818610fe15f784f21b..05c1c90868dbe7cff2da7601f29718ba35daeeef 100644\n" +
            "--- a/tests/resume-with-previous-stek.c\n" +
            "+++ b/tests/resume-with-previous-stek.c\n" +
            "@@ -196,8 +196,8 @@ static void server(int fd, unsigned rounds, const char *prio)\n" +
            " \t\tserverx509cred = NULL;\n" +
            " \t}\n" +
            " \n" +
            "-\tif (num_stek_rotations != 2)\n" +
            "-\t\tfail(\"STEK should be rotated exactly twice (%d)!\\n\", num_stek_rotations);\n" +
            "+\tif (num_stek_rotations != 3)\n" +
            "+\t\tfail(\"STEK should be rotated exactly three times (%d)!\\n\", num_stek_rotations);\n" +
            " \n" +
            " \tif (serverx509cred)\n" +
            " \t\tgnutls_certificate_free_credentials(serverx509cred);\n" +
            "diff --git a/tests/tls13/prf-early.c b/tests/tls13/prf-early.c\n" +
            "index 414b1db5ea3b21dd0b3a2b36dce8fabe0b572826..bc3196248fc24d0d00bafcab08f055c439e8e5ec 100644\n" +
            "--- a/tests/tls13/prf-early.c\n" +
            "+++ b/tests/tls13/prf-early.c\n" +
            "@@ -123,10 +123,10 @@ static void dump(const char *name, const uint8_t *data, unsigned data_size)\n" +
            " \t} \\\n" +
            " \t}\n" +
            " \n" +
            "-#define KEY_EXP_VALUE \"\\xc0\\x1e\\xc2\\xa4\\xb7\\xb4\\x04\\xaa\\x91\\x5d\\xaf\\xe8\\xf7\\x4d\\x19\\xdf\\xd0\\xe6\\x08\\xd6\\xb4\\x3b\\xcf\\xca\\xc9\\x32\\x75\\x3b\\xe3\\x11\\x19\\xb1\\xac\\x68\"\n" +
            "-#define HELLO_VALUE \"\\x77\\xdb\\x10\\x0b\\xe8\\xd0\\xb9\\x38\\xbc\\x49\\xe6\\xbe\\xf2\\x47\\x2a\\xcc\\x6b\\xea\\xce\\x85\\x04\\xd3\\x9e\\xd8\\x06\\x16\\xad\\xff\\xcd\\xbf\\x4b\"\n" +
            "-#define CONTEXT_VALUE \"\\xf2\\x17\\x9f\\xf2\\x66\\x56\\x87\\x66\\xf9\\x5c\\x8a\\xd7\\x4e\\x1d\\x46\\xee\\x0e\\x44\\x41\\x4c\\xcd\\xac\\xcb\\xc0\\x31\\x41\\x2a\\xb6\\xd7\\x01\\x62\"\n" +
            "-#define NULL_CONTEXT_VALUE \"\\xcd\\x79\\x07\\x93\\xeb\\x96\\x07\\x3e\\xec\\x78\\x90\\x89\\xf7\\x16\\x42\\x6d\\x27\\x87\\x56\\x7c\\x7b\\x60\\x2b\\x20\\x44\\xd1\\xea\\x0c\\x89\\xfb\\x8b\"\n" +
            "+#define KEY_EXP_VALUE \"\\xc1\\x6b\\x6c\\xb9\\x88\\x33\\xd5\\x28\\x80\\xec\\x27\\x87\\xa2\\x6f\\x4b\\xd0\\x01\\x5e\\x7f\\xca\\xd7\\xd4\\x8a\\x3f\\xe2\\x48\\x92\\xef\\x02\\x14\\xfb\\x81\\x90\\x04\"\n" +
            "+#define HELLO_VALUE \"\\x2a\\x73\\xd9\\x74\\x04\\x4e\\x0a\\x5f\\x41\\x8a\\x09\\xcb\\x45\\x33\\x1a\\xec\\xd3\\xfc\\xdc\\x1b\\x2c\\x67\\x26\\xe4\\x9c\\xfe\\x1f\\xa5\\x74\\xf1\\x4f\"\n" +
            "+#define CONTEXT_VALUE \"\\x87\\xf6\\x88\\xe3\\xd7\\xf2\\x05\\xbc\\xa4\\x10\\xa3\\x48\\x9f\\xf5\\xcf\\x97\\x06\\x22\\x4e\\xfd\\x18\\x32\\x52\\x1d\\xbd\\x26\\xf5\\x5b\\x21\\x20\\xec\"\n" +
            "+#define NULL_CONTEXT_VALUE \"\\xf9\\xca\\xfe\\x45\\x44\\x96\\xdb\\xc5\\x41\\x8f\\x7e\\x8e\\xd7\\xb0\\x7d\\x19\\x45\\xaf\\x09\\xbc\\x1e\\x82\\x94\\xac\\x55\\xe5\\xb9\\xb4\\x3b\\xe8\\xc0\"\n" +
            " \n" +
            " static int handshake_callback_called;\n" +
            " ";

    final String gitTrackerPatch = "diff --git a/ChangeLog b/ChangeLog\n" +
            "index f846aac70..7c8356600 100644\n" +
            "--- a/ChangeLog\n" +
            "+++ b/ChangeLog\n" +
            "@@ -1,5 +1,13 @@\n" +
            " 2015-09-19  Paul Eggert  <eggert@cs.ucla.edu>\n" +
            " \n" +
            "+\tDiagnose ERE '()|\\1'\n" +
            "+\tProblem reported by Hanno BÃ¶ck in: http://bugs.gnu.org/21513\n" +
            "+\t* lib/regcomp.c (parse_reg_exp): While parsing alternatives, keep\n" +
            "+\ttrack of the set of previously-completed subexpressions available\n" +
            "+\tbefore the first alternative, and restore this set just before\n" +
            "+\tparsing each subsequent alternative.  This lets us diagnose the\n" +
            "+\tinvalid back-reference in the ERE '()|\\1'.\n" +
            "+\n" +
            " \tregex: merge patches from libc\n" +
            " \n" +
            " \t2015-09-08  Joseph Myers  <joseph@codesourcery.com>\n" +
            "diff --git a/lib/regcomp.c b/lib/regcomp.c\n" +
            "index f50afb4bb..4cbb1b2b9 100644\n" +
            "--- a/lib/regcomp.c\n" +
            "+++ b/lib/regcomp.c\n" +
            "@@ -2191,6 +2191,7 @@ parse_reg_exp (re_string_t *regexp, regex_t *preg, re_token_t *token,\n" +
            " {\n" +
            "   re_dfa_t *dfa = preg->buffer;\n" +
            "   bin_tree_t *tree, *branch = NULL;\n" +
            "+  bitset_word_t initial_bkref_map = dfa->completed_bkref_map;\n" +
            "   tree = parse_branch (regexp, preg, token, syntax, nest, err);\n" +
            "   if (BE (*err != REG_NOERROR && tree == NULL, 0))\n" +
            "     return NULL;\n" +
            "@@ -2201,6 +2202,8 @@ parse_reg_exp (re_string_t *regexp, regex_t *preg, re_token_t *token,\n" +
            "       if (token->type != OP_ALT && token->type != END_OF_RE\n" +
            " \t  && (nest == 0 || token->type != OP_CLOSE_SUBEXP))\n" +
            " \t{\n" +
            "+\t  bitset_word_t accumulated_bkref_map = dfa->completed_bkref_map;\n" +
            "+\t  dfa->completed_bkref_map = initial_bkref_map;\n" +
            " \t  branch = parse_branch (regexp, preg, token, syntax, nest, err);\n" +
            " \t  if (BE (*err != REG_NOERROR && branch == NULL, 0))\n" +
            " \t    {\n" +
            "@@ -2208,6 +2211,7 @@ parse_reg_exp (re_string_t *regexp, regex_t *preg, re_token_t *token,\n" +
            " \t\tpostorder (tree, free_tree, NULL);\n" +
            " \t      return NULL;\n" +
            " \t    }\n" +
            "+\t  dfa->completed_bkref_map |= accumulated_bkref_map;\n" +
            " \t}\n" +
            "       else\n" +
            " \tbranch = NULL;";

    final String apacheSVNPatch = "--- tomcat/tc6.0.x/trunk/java/org/apache/catalina/authenticator/AuthenticatorBase.java\t2010/04/21 22:11:29\t936539\n" +
            "+++ tomcat/tc6.0.x/trunk/java/org/apache/catalina/authenticator/AuthenticatorBase.java\t2010/04/21 22:12:05\t936540\n" +
            "@@ -99,6 +99,11 @@\n" +
            " \n" +
            " \n" +
            "     /**\n" +
            "+     * Default authentication realm name.\n" +
            "+     */\n" +
            "+    protected static final String REALM_NAME = \"Authentication required\";\n" +
            "+\n" +
            "+    /**\n" +
            "      * The message digest algorithm to be used when generating session\n" +
            "      * identifiers.  This must be an algorithm supported by the\n" +
            "      * <code>java.security.MessageDigest</code> class on your platform.";

    final String errorJSON = "{\"code\":404,\"error\":\"Not found\"}";

    @BeforeEach
    public void setup() {
        when(dbMock.getCollection("commits")).thenReturn(commitsMock);
        when(dbMock.getCollection("pull_requests")).thenReturn(prsMock);
        when(dbMock.getCollection("issues")).thenReturn(issuesMock);
        patchFarmer = new PatchFarmer(dbMock, clientMock);
    }

    public String readFile(String filePath) throws IOException {
        File file = new File(filePath);
        return FileUtils.readFileToString(file, StandardCharsets.UTF_8);
    }

    @Test
    public void parsingCommitsFromMongo() throws IOException {
        // Setup mocks to test the response
        String patchLink = "https://github.com/python/cpython/commit/fbf648ebba32bbc5aa571a4b09e2062a65fd2492";
        String jsonCommit = readFile("./src/test/resources/patches/commit.txt");

        FindIterable mockIterable = Mockito.mock(FindIterable.class);
        when(commitsMock.find(eq("sha", Mockito.any()))).thenReturn(mockIterable);
        Document mockDocument = Mockito.mock(Document.class);
        when(mockIterable.first()).thenReturn(mockDocument);
        when(mockDocument.toJson()).thenReturn(jsonCommit);

        // Call parse Commit method
        var vp = patchFarmer.parseGHCommit(patchLink);

        // Verify Hunks in the commit
        List<Integer> hunks = new ArrayList<>();
        hunks.add(1968);

        Vulnerability.Patch vulnerable_file = new Vulnerability.Patch("Lib/test/test_socket.py", "2014-01-14T03:59:38Z", hunks);

        assertEquals(vp.size(), 4);
        List<String> filenames = vp.stream().map(Vulnerability.Patch::getFileName).collect(Collectors.toList());
        assertTrue(filenames.contains(vulnerable_file.getFileName()));
    }

    @Test
    public void parsingCommitsFromGithubAPI() throws Exception {
        String patchLink = "https://github.com/python/cpython/commit/fbf648ebba32bbc5aa571a4b09e2062a65fd2492";
        Vulnerability v = new Vulnerability("CVE-TEST-ID");
        v.setPublishedDate("2013-01-14T03:59:38Z");
        String jsonCommit = readFile("./src/test/resources/patches/commit.txt");
        when(nc.findPatchEntry(patchLink)).thenReturn(Optional.empty());

        FindIterable mockIterable = Mockito.mock(FindIterable.class);
        when(commitsMock.find(eq("sha", Mockito.any()))).thenReturn(mockIterable);
        Document mockDocument = Mockito.mock(Document.class);
        when(mockIterable.first()).thenReturn(mockDocument);
        when(mockDocument.toJson()).thenReturn(null);

        when(clientMock.sendGet(Mockito.any())).thenReturn(jsonCommit);

        // Call parse Commit method
        v.addReference(patchLink);
        patchFarmer.parseReferences(v, nc);

        // Verify Hunks in the commit
        List<Integer> hunks = new ArrayList<>();
        hunks.add(1968);

        Vulnerability.Patch vulnerable_file = new Vulnerability.Patch("Lib/test/test_socket.py", "2014-01-14T03:59:38Z", hunks);

        assertEquals(v.getPatches().size(), 4);
        List<String> filenames = v.getPatches().stream().map(Vulnerability.Patch::getFileName).collect(Collectors.toList());
        assertTrue(filenames.contains(vulnerable_file.getFileName()));
    }

    @Test
    public void parsingPullRequestsGHTorrent() throws IOException {
        // Setup mocks to test the response
        String prLink = "https://github.com/omniauth/omniauth-oauth2/pull/25";
        String jsonCommit = readFile("./src/test/resources/patches/pr.txt");

        FindIterable mockIterable = Mockito.mock(FindIterable.class);
        when(prsMock.find((Bson) Mockito.any())).thenReturn(mockIterable);
        Document mockDocument = Mockito.mock(Document.class);
        when(mockIterable.first()).thenReturn(mockDocument);
        when(mockDocument.toJson()).thenReturn(jsonCommit);

        // Mock commit behaviour
        String jsonMergeCommit = readFile("./src/test/resources/patches/pr_commit.txt");

        FindIterable mockIterableMergeCommit = Mockito.mock(FindIterable.class);
        when(commitsMock.find(eq("sha", Mockito.any()))).thenReturn(mockIterableMergeCommit);
        Document mockDocumentMergeCommit = Mockito.mock(Document.class);
        when(mockIterableMergeCommit.first()).thenReturn(mockDocumentMergeCommit);
        when(mockDocumentMergeCommit.toJson()).thenReturn(jsonMergeCommit);

        // Call parse Commit method
        var vp = patchFarmer.parseGHPullRequest(prLink);

        // Verify Hunks in the commit
        List<Integer> hunks = new ArrayList<>();
        hunks.add(49);

        Vulnerability.Patch vulnerable_file = new Vulnerability.Patch(
                "lib/omniauth/strategies/oauth2.rb",
                "2012-09-08T09:26:41Z",
                hunks);

        assertEquals(vp.size(), 1);
        List<String> filenames = vp.stream()
                .map(Vulnerability.Patch::getFileName).collect(Collectors.toList());

        assertTrue(filenames.contains(vulnerable_file.getFileName()));
    }

    @Test
    public void parsingPullRequestsGithub() throws Exception {
        // Setup mocks to test the response
        String prLink = "https://github.com/omniauth/omniauth-oauth2/pull/25";
        Vulnerability v = new Vulnerability("CVE-TEST-ID");
        v.setPublishedDate("2012-08-08T09:26:41Z");
        String jsonCommit = readFile("./src/test/resources/patches/pr.txt");
        when(nc.findPatchEntry(prLink)).thenReturn(Optional.empty());

        FindIterable mockIterable = Mockito.mock(FindIterable.class);
        when(prsMock.find((Bson) Mockito.any())).thenReturn(mockIterable);
        Document mockDocument = Mockito.mock(Document.class);
        when(mockIterable.first()).thenReturn(mockDocument);
        when(mockDocument.toJson()).thenReturn(null);

        when(clientMock.sendGet(Mockito.any())).thenReturn(jsonCommit);

        // Mock commit behaviour
        String jsonMergeCommit = readFile("./src/test/resources/patches/pr_commit.txt");

        FindIterable mockIterableMergeCommit = Mockito.mock(FindIterable.class);
        when(commitsMock.find(eq("sha", Mockito.any()))).thenReturn(mockIterableMergeCommit);
        Document mockDocumentMergeCommit = Mockito.mock(Document.class);
        when(mockIterableMergeCommit.first()).thenReturn(mockDocumentMergeCommit);
        when(mockDocumentMergeCommit.toJson()).thenReturn(jsonMergeCommit);

        // Call parse Commit method
        v.addReference(prLink);
        patchFarmer.parseReferences(v, nc);

        // Verify Hunks in the commit
        List<Integer> hunks = new ArrayList<>();
        hunks.add(49);

        Vulnerability.Patch vulnerable_file = new Vulnerability.Patch(
                "lib/omniauth/strategies/oauth2.rb",
                "2012-09-08T09:26:41Z",
                hunks);

        assertEquals(v.getPatches().size(), 1);
        List<String> filenames = v.getPatches().stream()
                .map(Vulnerability.Patch::getFileName).collect(Collectors.toList());

        assertTrue(filenames.contains(vulnerable_file.getFileName()));
    }

    @Test
    public void parsingIssuesGHTorrent() throws Exception {
        // Setup mocks to test the response
        String issueLink = "https://github.com/python/cpython/pull/32";
        String jsonIssue = readFile("./src/test/resources/patches/issue.txt");

        FindIterable mockIterable = Mockito.mock(FindIterable.class);
        when(issuesMock.find((Bson) Mockito.any())).thenReturn(mockIterable);
        Document mockDocument = Mockito.mock(Document.class);
        when(mockIterable.first()).thenReturn(mockDocument);
        when(mockDocument.toJson()).thenReturn(jsonIssue);

        // Mock pull request behaviour
        String jsonPullRequest = readFile("./src/test/resources/patches/pr_issue.txt");

        FindIterable mockIterablePR = Mockito.mock(FindIterable.class);
        when(prsMock.find((Bson) Mockito.any())).thenReturn(mockIterablePR);
        Document mockDocumentPR = Mockito.mock(Document.class);
        when(mockIterablePR.first()).thenReturn(mockDocumentPR);
        when(mockDocumentPR.toJson()).thenReturn(jsonPullRequest);

        // Mock commit behaviour
        String jsonMergeCommit = readFile("./src/test/resources/patches/commit_issue.txt");

        FindIterable mockIterableMergeCommit = Mockito.mock(FindIterable.class);
        when(commitsMock.find(eq("sha", Mockito.any()))).thenReturn(mockIterableMergeCommit);
        Document mockDocumentMergeCommit = Mockito.mock(Document.class);
        when(mockIterableMergeCommit.first()).thenReturn(mockDocumentMergeCommit);
        when(mockDocumentMergeCommit.toJson()).thenReturn(jsonMergeCommit);

        // Call parse Commit method
        var vp = patchFarmer.parseGHIssues(issueLink);

        // Verify Hunks in the commit
        List<Integer> hunks = new ArrayList<>();
        hunks.add(13);

        Vulnerability.Patch vulnerable_file = new Vulnerability.Patch(
                "Lib/importlib/abc.py",
                "2017-02-16T02:00:32Z",
                hunks);

        assertEquals(5, vp.size());
        List<String> filenames = vp.stream()
                .map(Vulnerability.Patch::getFileName).collect(Collectors.toList());

        assertTrue(filenames.contains(vulnerable_file.getFileName()));
    }

    @Test
    public void parsingIssuesGithub() throws Exception {
        // Setup mocks to test the response
        String issueLink = "https://github.com/python/cpython/pull/32";
        Vulnerability v = new Vulnerability("CVE-TEST-ID");
        v.setPublishedDate("2015-04-08T09:26:41Z");
        String jsonIssue = readFile("./src/test/resources/patches/issue.txt");
        when(nc.findPatchEntry(issueLink)).thenReturn(Optional.empty());

        FindIterable mockIterable = Mockito.mock(FindIterable.class);
        when(issuesMock.find((Bson) Mockito.any())).thenReturn(mockIterable);
        Document mockDocument = Mockito.mock(Document.class);
        when(mockIterable.first()).thenReturn(mockDocument);
        when(mockDocument.toJson()).thenReturn(null);

        when(clientMock.sendGet(Mockito.any())).thenReturn(jsonIssue);

        // Mock pull request behaviour
        String jsonPullRequest = readFile("./src/test/resources/patches/pr_issue.txt");

        FindIterable mockIterablePR = Mockito.mock(FindIterable.class);
        when(prsMock.find((Bson) Mockito.any())).thenReturn(mockIterablePR);
        Document mockDocumentPR = Mockito.mock(Document.class);
        when(mockIterablePR.first()).thenReturn(mockDocumentPR);
        when(mockDocumentPR.toJson()).thenReturn(jsonPullRequest);

        // Mock commit behaviour
        String jsonMergeCommit = readFile("./src/test/resources/patches/commit_issue.txt");

        FindIterable mockIterableMergeCommit = Mockito.mock(FindIterable.class);
        when(commitsMock.find(eq("sha", Mockito.any()))).thenReturn(mockIterableMergeCommit);
        Document mockDocumentMergeCommit = Mockito.mock(Document.class);
        when(mockIterableMergeCommit.first()).thenReturn(mockDocumentMergeCommit);
        when(mockDocumentMergeCommit.toJson()).thenReturn(jsonMergeCommit);

        // Call parse Commit method
        v.addReference(issueLink);
        patchFarmer.parseReferences(v, nc);

        // Verify Hunks in the commit
        List<Integer> hunks = new ArrayList<>();
        hunks.add(13);

        Vulnerability.Patch vulnerable_file = new Vulnerability.Patch(
                "Lib/importlib/abc.py",
                "2017-02-16T02:00:32Z",
                hunks);

        assertEquals(5, v.getPatches().size());
        List<String> filenames = v.getPatches().stream()
                .map(Vulnerability.Patch::getFileName).collect(Collectors.toList());

        assertTrue(filenames.contains(vulnerable_file.getFileName()));
    }

    @Test
    public void testPatchEntryAlreadyInNitrite() {
        NitriteController nc = Mockito.mock(NitriteController.class);
        Vulnerability v = new Vulnerability("TEST");
        v.addReference("ref");
        HashSet<Vulnerability.Patch> files = new HashSet<>();
        Vulnerability.Patch f = new Vulnerability.Patch("test_file",
                "test_date", new ArrayList<>());
        files.add(f);
        when(nc.findPatchEntry("ref")).thenReturn(Optional.of(files));

        patchFarmer.parseReferences(v, nc);
        assertTrue(v.getPatches().contains(f));
    }

    @Test
    public void testParseGLCommit() throws Exception {
        String refLink = "https://gitlab.com/gnutls/gnutls/-/commit/c2646aeee94e71cb15c90a3147cf3b5b0ca158ca";
        when(clientMock.sendGet(refLink + ".diff")).thenReturn(genericPatch);
        NitriteController nc = Mockito.mock(NitriteController.class);
        when(nc.findPatchEntry(refLink)).thenReturn(Optional.empty());

        Vulnerability v = new Vulnerability("TEST");
        v.addReference(refLink);

        // Expected vulnerability
        Vulnerability.Patch patch_1 = new Vulnerability.Patch();
        patch_1.setFileName("lib/stek.c");
        List<Integer> ln_1 = new ArrayList<>(Arrays.asList(326, 333, 339));
        patch_1.setLineNumbers(ln_1);

        Vulnerability.Patch patch_2 = new Vulnerability.Patch();
        patch_2.setFileName("tests/resume-with-previous-stek.c");
        List<Integer> ln_2 = new ArrayList<>(Arrays.asList(199));
        patch_2.setLineNumbers(ln_2);

        Vulnerability.Patch patch_3 = new Vulnerability.Patch();
        patch_3.setFileName("tests/tls13/prf-early.c");
        List<Integer> ln_3 = new ArrayList<>(Arrays.asList(126));
        patch_3.setLineNumbers(ln_3);

        patchFarmer.parseReferences(v, nc);

        assertTrue(v.getPatches().contains(patch_1));
        assertTrue(v.getPatches().contains(patch_2));
        assertTrue(v.getPatches().contains(patch_3));
    }

    @Test
    public void testParseGitTrackerCommit() throws Exception {
        String refLink = "https://git.savannah.gnu.org/cgit/gnulib.git/commit/?id=5513b40999149090987a0341c018d05d3eea1272";
        when(clientMock.sendGet(refLink.replaceFirst("/commit/", "/rawdiff/"))).thenReturn(gitTrackerPatch);
        NitriteController nc = Mockito.mock(NitriteController.class);
        when(nc.findPatchEntry(refLink)).thenReturn(Optional.empty());

        Vulnerability v = new Vulnerability("TEST");
        v.addReference(refLink);

        // Expected vulnerability
        Vulnerability.Patch patch_1 = new Vulnerability.Patch();
        patch_1.setFileName("ChangeLog");
        List<Integer> ln_1 = new ArrayList<>(Arrays.asList(3));
        patch_1.setLineNumbers(ln_1);

        Vulnerability.Patch patch_2 = new Vulnerability.Patch();
        patch_2.setFileName("lib/regcomp.c");
        List<Integer> ln_2 = new ArrayList<>(Arrays.asList(2194, 2204, 2211));
        patch_2.setLineNumbers(ln_2);

        patchFarmer.parseReferences(v, nc);

        assertTrue(v.getPatches().contains(patch_1));
        assertTrue(v.getPatches().contains(patch_2));
    }

    @Test
    public void testParseApacheSVN() throws Exception {
        String refLink = "https://svn.apache.org/viewvc?view=revision&revision=936540";
        String revisionHTML = readFile("./src/test/resources/patches/apache_svn_revision.html");
        when(clientMock.sendGet(refLink)).thenReturn(revisionHTML);
        when(clientMock.sendGet("https://svn.apache.org/viewvc/tomcat/tc6.0.x/trunk/java/org/apache/catalina/authenticator/AuthenticatorBase.java?r1=936540&r2=936539&pathrev=936540&view=patch"))
                .thenReturn(apacheSVNPatch);

        NitriteController nc = Mockito.mock(NitriteController.class);
        when(nc.findPatchEntry(refLink)).thenReturn(Optional.empty());

        Vulnerability v = new Vulnerability("TEST");
        v.addReference(refLink);

        // Expected vulnerability
        Vulnerability.Patch patch_1 = new Vulnerability.Patch();
        patch_1.setFileName("tomcat/tc6.0.x/trunk/java/org/apache/catalina/authenticator/AuthenticatorBase.java");
        List<Integer> ln_1 = new ArrayList<>(Arrays.asList(102));
        patch_1.setLineNumbers(ln_1);

        patchFarmer.parseReferences(v, nc);

        assertTrue(v.getPatches().contains(patch_1));
    }

    @Test
    public void testParseJIRATicketAttachments() throws Exception {
        String refLink = "https://issues.apache.org/jira/browse/ZOOKEEPER-1392";
        String jiraTicketApiJson = readFile("./src/test/resources/patches/jira_ticket_response.json");
        String jiraTicketPatchContent = readFile("./src/test/resources/patches/jira_ticket_patch_content.txt");

        when(clientMock.sendGet("https://issues.apache.org/jira/rest/api/2/issue/ZOOKEEPER-1392"))
                .thenReturn(jiraTicketApiJson);
        when(clientMock.sendGet("https://issues.apache.org/jira/secure/attachment/12595780/ZOOKEEPER-1392.patch"))
                .thenReturn(jiraTicketPatchContent);

        NitriteController nc = Mockito.mock(NitriteController.class);
        when(nc.findPatchEntry(refLink)).thenReturn(Optional.empty());

        Vulnerability v = new Vulnerability("TEST");
        v.addReference(refLink);

        // Expected vulnerability
        Vulnerability.Patch patch_1 = new Vulnerability.Patch();
        patch_1.setFileName("src/java/test/org/apache/zookeeper/test/ACLTest.java");
        List<Integer> ln_1 = new ArrayList<>(Arrays.asList(31, 38, 40, 80));
        patch_1.setLineNumbers(ln_1);

        Vulnerability.Patch patch_2 = new Vulnerability.Patch();
        patch_2.setFileName("src/java/main/org/apache/zookeeper/server/FinalRequestProcessor.java");
        List<Integer> ln_2 = new ArrayList<>(Arrays.asList(327));
        patch_2.setLineNumbers(ln_2);

        patchFarmer.parseReferences(v, nc);

        assertTrue(v.getPatches().contains(patch_1));
        assertTrue(v.getPatches().contains(patch_2));
    }


    @Test
    public void testParseJIRATicketComments() throws Exception {
        String refLink = "https://jira.mongodb.org/browse/SERVER-40563";
        String commitLink = "https://github.com/mongodb/mongo/commit/443e8974d66a3ddd2ad89f8b3f9c2ebb7d8d9500";
        String jiraTicketApiJson = readFile("./src/test/resources/patches/jira_ticket_mongo_comments.json");
        String patchCommitJson = readFile("./src/test/resources/patches/jira_ticket_mongo_commit.json");

        when(clientMock.sendGet("https://jira.mongodb.org/rest/api/2/issue/SERVER-40563"))
                .thenReturn(jiraTicketApiJson);

        FindIterable mockIterable = Mockito.mock(FindIterable.class);
        when(commitsMock.find((Bson) Mockito.any())).thenReturn(mockIterable);
        Document mockDocument = Mockito.mock(Document.class);
        when(mockIterable.first()).thenReturn(mockDocument);
        when(mockDocument.toJson()).thenReturn(null);

        when(clientMock.sendGet("https://api.github.com/repos/mongodb/mongo/commits/443e8974d66a3ddd2ad89f8b3f9c2ebb7d8d9500"))
                .thenReturn(patchCommitJson);

        NitriteController nc = Mockito.mock(NitriteController.class);
        when(nc.findPatchEntry(refLink)).thenReturn(Optional.empty());

        Vulnerability.Patch patch = new Vulnerability.Patch("rpm/init.d-mongod", new ArrayList<>(Arrays.asList(103, 111)));
        patch.setPatchDate("2019-05-24T15:52:45Z");

        Vulnerability v = new Vulnerability("TEST");
        v.addReference(refLink);

        patchFarmer.parseReferences(v, nc);

        assertTrue(v.getPatches().contains(patch));
    }

    @Test
    public void testParseBugzillaBug() throws Exception {
        String ref = "https://bugs.kde.org/show_bug.cgi?id=97608";

        String response = readFile("./src/test/resources/patches/bugs_kde.json");
        when(clientMock.sendGet("https://bugs.kde.org/rest/bug/97608/attachment")).thenReturn(response);
        NitriteController nc = Mockito.mock(NitriteController.class);
        when(nc.findPatchEntry(ref)).thenReturn(Optional.empty());

        Vulnerability.Patch patch = new Vulnerability.Patch("kdelibs-3.3.2/dcop/dcopidlng/dcopidlng",
                "2005-01-21 15:46:42.000000000 +0000 ",
                new ArrayList<>(Arrays.asList(6, 10, 12)));

        Vulnerability v = new Vulnerability("TEST");
        v.addReference(ref);

        patchFarmer.parseReferences(v, nc);
        assertTrue(v.getPatches().contains(patch));
    }

    @Test
    public void testApacheMailingList() throws Exception {
        var ref = "https://lists.apache.org/thread.html/f20bb4e055d8394fc525cc7772fb84096f706389043e76220c8a29a4@<hdfs-dev.hadoop.apache.org>";

        String response = readFile("./src/test/resources/patches/list_apache_message.txt");
        when(clientMock.sendGet("https://lists.apache.org/api/source.lua/f20bb4e055d8394fc525cc7772fb84096f706389043e76220c8a29a4@<hdfs-dev.hadoop.apache.org>"))
                .thenReturn(response);
        NitriteController nc = Mockito.mock(NitriteController.class);
        when(nc.findPatchEntry(ref)).thenReturn(Optional.empty());

        String jiraTicketApiJson = readFile("./src/test/resources/patches/jira_ticket_response.json");
        String jiraTicketPatchContent = readFile("./src/test/resources/patches/jira_ticket_patch_content.txt");

        when(clientMock.sendGet("https://issues.apache.org/jira/rest/api/2/issue/HDFS-8432"))
                .thenReturn(jiraTicketApiJson);
        when(clientMock.sendGet("https://issues.apache.org/jira/secure/attachment/12595780/ZOOKEEPER-1392.patch"))
                .thenReturn(jiraTicketPatchContent);

        Vulnerability v = new Vulnerability("TEST");
        v.addReference(ref);

        // Expected vulnerability
        Vulnerability.Patch patch_1 = new Vulnerability.Patch();
        patch_1.setFileName("src/java/test/org/apache/zookeeper/test/ACLTest.java");
        List<Integer> ln_1 = new ArrayList<>(Arrays.asList(31, 38, 40, 80));
        patch_1.setLineNumbers(ln_1);

        Vulnerability.Patch patch_2 = new Vulnerability.Patch();
        patch_2.setFileName("src/java/main/org/apache/zookeeper/server/FinalRequestProcessor.java");
        List<Integer> ln_2 = new ArrayList<>(Arrays.asList(327));
        patch_2.setLineNumbers(ln_2);

        patchFarmer.parseReferences(v, nc);

        assertTrue(v.getPatches().contains(patch_1));
        assertTrue(v.getPatches().contains(patch_2));
    }
}

