/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package eu.fasten.vulnerabilityproducer;

import com.mongodb.client.FindIterable;
import com.mongodb.client.MongoCollection;
import com.mongodb.client.MongoDatabase;
import eu.fasten.vulnerabilityproducer.db.NitriteController;
import eu.fasten.vulnerabilityproducer.utils.PatchFinder;
import eu.fasten.vulnerabilityproducer.utils.Vulnerability.*;
import eu.fasten.vulnerabilityproducer.utils.connections.JavaHttpClient;
import eu.fasten.vulnerabilityproducer.utils.Vulnerability;
import eu.fasten.vulnerabilityproducer.utils.patches.*;
import org.apache.commons.io.FileUtils;
import org.bson.Document;
import org.bson.conversions.Bson;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.mockito.Mockito;

import java.io.File;
import java.io.IOException;
import java.nio.charset.StandardCharsets;
import java.util.*;
import java.util.stream.Collectors;

import static com.mongodb.client.model.Filters.eq;
import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.junit.jupiter.api.Assertions.assertTrue;
import static org.mockito.Mockito.when;

public class PatchFinderTest {

    // Inject Java Http Client to test
    JavaHttpClient clientMock = Mockito.mock(JavaHttpClient.class);

    // Inject mock database in order to test
    MongoDatabase dbMock = Mockito.mock(MongoDatabase.class);
    MongoCollection<Document> commitsMock = Mockito.mock(MongoCollection.class);
    MongoCollection<Document> prsMock = Mockito.mock(MongoCollection.class);
    MongoCollection<Document> issuesMock = Mockito.mock(MongoCollection.class);
    NitriteController nc = Mockito.mock(NitriteController.class);
    private PatchFinder patchFinder;

    static final String validJSON = "{" +
            "\"comment\":\"Testing\"," +
            "\"cve_id\":\"CVE-TEST-TEST\"," +
            "\"cwes\":[]," +
            "\"description\":\"Retrieve Relevant files\"," +
            "\"exploit_exists\":false," +
            "\"has_annotations\":true," +
            "\"is_processed\":true," +
            "\"langs\":[]," +
            "\"master_commit\":{" +
                "\"commit_hash\":\"hash\"," +
                "\"commit_link\":\"https://github.com/generic_commit\"," +
                "\"relevant_files\":[\"./src/index.c\",\"./src/mock.c\"]," +
                "\"repo_name\":\"test\"," +
                "\"repo_owner\":\"random\"," +
                "\"repo_url\":\"" +
            "\"}," +
            "\"products\":[]," +
            "\"references\":[]," +
            "\"score\":null" +
            "}";

    final String emptyMasterCommit = "{" +
            "\"comment\":\"Testing JSON body valid\"," +
            "\"cve_id\":\"CVE-TEST-TEST\"," +
            "\"cwes\":[]," +
            "\"description\":\"n/a\"," +
            "\"exploit_exists\":false," +
            "\"has_annotations\":true," +
            "\"is_processed\":true," +
            "\"langs\":[\"ANY\"]," +
            "\"master_commit\":{}," +
            "\"products\":[{\"product\":\"python\",\"vendor\":\"python\"}]," +
            "\"references\":[]," +
            "\"score\":null" +
            "}";

    final String gitTrackerPatch = "diff --git a/ChangeLog b/ChangeLog\n" +
            "index f846aac70..7c8356600 100644\n" +
            "--- a/ChangeLog\n" +
            "+++ b/ChangeLog\n" +
            "@@ -1,5 +1,13 @@\n" +
            " 2015-09-19  Paul Eggert  <eggert@cs.ucla.edu>\n" +
            " \n" +
            "+\tDiagnose ERE '()|\\1'\n" +
            "+\tProblem reported by Hanno BÃ¶ck in: http://bugs.gnu.org/21513\n" +
            "+\t* lib/regcomp.c (parse_reg_exp): While parsing alternatives, keep\n" +
            "+\ttrack of the set of previously-completed subexpressions available\n" +
            "+\tbefore the first alternative, and restore this set just before\n" +
            "+\tparsing each subsequent alternative.  This lets us diagnose the\n" +
            "+\tinvalid back-reference in the ERE '()|\\1'.\n" +
            "+\n" +
            " \tregex: merge patches from libc\n" +
            " \n" +
            " \t2015-09-08  Joseph Myers  <joseph@codesourcery.com>\n" +
            "diff --git a/lib/regcomp.c b/lib/regcomp.c\n" +
            "index f50afb4bb..4cbb1b2b9 100644\n" +
            "--- a/lib/regcomp.c\n" +
            "+++ b/lib/regcomp.c\n" +
            "@@ -2191,6 +2191,7 @@ parse_reg_exp (re_string_t *regexp, regex_t *preg, re_token_t *token,\n" +
            " {\n" +
            "   re_dfa_t *dfa = preg->buffer;\n" +
            "   bin_tree_t *tree, *branch = NULL;\n" +
            "+  bitset_word_t initial_bkref_map = dfa->completed_bkref_map;\n" +
            "   tree = parse_branch (regexp, preg, token, syntax, nest, err);\n" +
            "   if (BE (*err != REG_NOERROR && tree == NULL, 0))\n" +
            "     return NULL;\n" +
            "@@ -2201,6 +2202,8 @@ parse_reg_exp (re_string_t *regexp, regex_t *preg, re_token_t *token,\n" +
            "       if (token->type != OP_ALT && token->type != END_OF_RE\n" +
            " \t  && (nest == 0 || token->type != OP_CLOSE_SUBEXP))\n" +
            " \t{\n" +
            "+\t  bitset_word_t accumulated_bkref_map = dfa->completed_bkref_map;\n" +
            "+\t  dfa->completed_bkref_map = initial_bkref_map;\n" +
            " \t  branch = parse_branch (regexp, preg, token, syntax, nest, err);\n" +
            " \t  if (BE (*err != REG_NOERROR && branch == NULL, 0))\n" +
            " \t    {\n" +
            "@@ -2208,6 +2211,7 @@ parse_reg_exp (re_string_t *regexp, regex_t *preg, re_token_t *token,\n" +
            " \t\tpostorder (tree, free_tree, NULL);\n" +
            " \t      return NULL;\n" +
            " \t    }\n" +
            "+\t  dfa->completed_bkref_map |= accumulated_bkref_map;\n" +
            " \t}\n" +
            "       else\n" +
            " \tbranch = NULL;";

    final String apacheSVNPatch = "--- tomcat/tc6.0.x/trunk/java/org/apache/catalina/authenticator/AuthenticatorBase.java\t2010/04/21 22:11:29\t936539\n" +
            "+++ tomcat/tc6.0.x/trunk/java/org/apache/catalina/authenticator/AuthenticatorBase.java\t2010/04/21 22:12:05\t936540\n" +
            "@@ -99,6 +99,11 @@\n" +
            " \n" +
            " \n" +
            "     /**\n" +
            "+     * Default authentication realm name.\n" +
            "+     */\n" +
            "+    protected static final String REALM_NAME = \"Authentication required\";\n" +
            "+\n" +
            "+    /**\n" +
            "      * The message digest algorithm to be used when generating session\n" +
            "      * identifiers.  This must be an algorithm supported by the\n" +
            "      * <code>java.security.MessageDigest</code> class on your platform.";

    final String errorJSON = "{\"code\":404,\"error\":\"Not found\"}";

    final String diffOfDiff = "diff --git a/core/src/components/toolbar/test/spec/index.html b/core/src/components/toolbar/test/spec/index.html\n" +
            "index 511b2958c26..4a6510855ac 100644\n" +
            "--- a/core/src/components/toolbar/test/spec/index.html\n" +
            "+++ b/core/src/components/toolbar/test/spec/index.html\n" +
            "@@ -1,4 +1,3 @@\n" +
            "-@@ -0,0 +1,59 @@\n" +
            " <!DOCTYPE html>\n" +
            " <html dir=\"ltr\">\n" +
            " \n" +
            "@@ -14,12 +13,12 @@\n" +
            " \n" +
            " <body>\n" +
            "   <ion-app>\n" +
            "-    <ion-header>\n" +
            "+    <ion-content>\n" +
            "       <ion-toolbar color=\"tertiary\">\n" +
            "         <ion-buttons slot=\"start\">\n" +
            "           <ion-menu-button auto-hide=\"false\"></ion-menu-button>\n" +
            "         </ion-buttons>\n" +
            "-        <ion-buttons slot=\"secondary\">\n" +
            "+        <ion-buttons slot=\"primary\">\n" +
            "           <ion-button>\n" +
            "             <ion-icon slot=\"icon-only\" name=\"download\"></ion-icon>\n" +
            "           </ion-button>";

    @BeforeEach
    public void setup() {
        when(dbMock.getCollection("commits")).thenReturn(commitsMock);
        when(dbMock.getCollection("pull_requests")).thenReturn(prsMock);
        when(dbMock.getCollection("issues")).thenReturn(issuesMock);
        patchFinder = new PatchFinder(dbMock, clientMock, "mocktoken");

        // Do not validate refs when testing
        when(clientMock.validateAndRedirect(Mockito.anyString(), Mockito.any())).thenAnswer(i -> i.getArguments()[0]);
    }

    public static String readFile(String filePath) throws IOException {
        File file = new File(filePath);
        return FileUtils.readFileToString(file, StandardCharsets.UTF_8);
    }

    @Test
    public void parsingCommitsFromMongo() throws IOException {
        // Setup mocks to test the response
        String patchLink = "https://github.com/python/cpython/commit/fbf648ebba32bbc5aa571a4b09e2062a65fd2492";
        String jsonCommit = readFile("./src/test/resources/patches/commit.txt");

        FindIterable mockIterable = Mockito.mock(FindIterable.class);
        when(commitsMock.find(eq("sha", Mockito.any()))).thenReturn(mockIterable);
        Document mockDocument = Mockito.mock(Document.class);
        when(mockIterable.first()).thenReturn(mockDocument);
        when(mockDocument.toJson()).thenReturn(jsonCommit);

        // Call parse Commit method
        var vp = patchFinder.parseReference(patchLink);

        // Verify Hunks in the commit
        List<Integer> hunks = new ArrayList<>();
        hunks.add(1968);

        Vulnerability.Patch vulnerable_file = new Vulnerability.Patch("Lib/test/test_socket.py", "2014-01-14T03:59:38Z", hunks);

        assertEquals(vp.size(), 4);
        List<String> filenames = vp.stream().map(Vulnerability.Patch::getFileName).collect(Collectors.toList());
        assertTrue(filenames.contains(vulnerable_file.getFileName()));
    }

    @Test
    public void parsingCommitsFromGithubAPI() throws Exception {
        String patchLink = "https://github.com/python/cpython/commit/fbf648ebba32bbc5aa571a4b09e2062a65fd2492";
        Vulnerability v = new Vulnerability("CVE-TEST-ID");
        v.setPublishedDate("2013-01-14T03:59:38Z");
        String jsonCommit = readFile("./src/test/resources/patches/commit.txt");
        when(nc.findPatchEntry(patchLink)).thenReturn(Optional.empty());

        FindIterable mockIterable = Mockito.mock(FindIterable.class);
        when(commitsMock.find(eq("sha", Mockito.any()))).thenReturn(mockIterable);
        Document mockDocument = Mockito.mock(Document.class);
        when(mockIterable.first()).thenReturn(mockDocument);
        when(mockDocument.toJson()).thenReturn(null);

        when(clientMock.sendGet(Mockito.any())).thenReturn(jsonCommit);

        // Call parse Commit method
        v.addReference(patchLink);
        patchFinder.parseReferences(v, nc);

        // Verify Hunks in the commit
        List<Integer> hunks = new ArrayList<>();
        hunks.add(1968);

        Vulnerability.Patch vulnerable_file = new Vulnerability.Patch("Lib/test/test_socket.py", "2014-01-14T03:59:38Z", hunks);

        assertEquals(v.getPatches().size(), 4);
        List<String> filenames = v.getPatches().stream().map(Vulnerability.Patch::getFileName).collect(Collectors.toList());
        assertTrue(filenames.contains(vulnerable_file.getFileName()));
    }

    @Test
    public void parsingPullRequestsGHTorrent() throws IOException {
        // Setup mocks to test the response
        String prLink = "https://github.com/omniauth/omniauth-oauth2/pull/25";
        String jsonCommit = readFile("./src/test/resources/patches/pr.txt");

        FindIterable mockIterable = Mockito.mock(FindIterable.class);
        when(prsMock.find((Bson) Mockito.any())).thenReturn(mockIterable);
        Document mockDocument = Mockito.mock(Document.class);
        when(mockIterable.first()).thenReturn(mockDocument);
        when(mockDocument.toJson()).thenReturn(jsonCommit);

        // Mock commit behaviour
        String jsonMergeCommit = readFile("./src/test/resources/patches/pr_commit.txt");

        FindIterable mockIterableMergeCommit = Mockito.mock(FindIterable.class);
        when(commitsMock.find(eq("sha", Mockito.any()))).thenReturn(mockIterableMergeCommit);
        Document mockDocumentMergeCommit = Mockito.mock(Document.class);
        when(mockIterableMergeCommit.first()).thenReturn(mockDocumentMergeCommit);
        when(mockDocumentMergeCommit.toJson()).thenReturn(jsonMergeCommit);

        // Call parse Commit method
        var vp = patchFinder.parseReference(prLink);

        // Verify Hunks in the commit
        List<Integer> hunks = new ArrayList<>();
        hunks.add(49);

        Vulnerability.Patch vulnerable_file = new Vulnerability.Patch(
                "lib/omniauth/strategies/oauth2.rb",
                "2012-09-08T09:26:41Z",
                hunks);

        assertEquals(vp.size(), 1);
        List<String> filenames = vp.stream()
                .map(Vulnerability.Patch::getFileName).collect(Collectors.toList());

        assertTrue(filenames.contains(vulnerable_file.getFileName()));
    }

    @Test
    public void parsingPullRequestsGithub() throws Exception {
        // Setup mocks to test the response
        String prLink = "https://github.com/omniauth/omniauth-oauth2/pull/25";
        Vulnerability v = new Vulnerability("CVE-TEST-ID");
        v.setPublishedDate("2012-08-08T09:26:41Z");
        String jsonCommit = readFile("./src/test/resources/patches/pr.txt");
        when(nc.findPatchEntry(prLink)).thenReturn(Optional.empty());

        FindIterable mockIterable = Mockito.mock(FindIterable.class);
        when(prsMock.find((Bson) Mockito.any())).thenReturn(mockIterable);
        Document mockDocument = Mockito.mock(Document.class);
        when(mockIterable.first()).thenReturn(mockDocument);
        when(mockDocument.toJson()).thenReturn(null);

        when(clientMock.sendGet(Mockito.any())).thenReturn(jsonCommit);

        // Mock commit behaviour
        String jsonMergeCommit = readFile("./src/test/resources/patches/pr_commit.txt");

        FindIterable mockIterableMergeCommit = Mockito.mock(FindIterable.class);
        when(commitsMock.find(eq("sha", Mockito.any()))).thenReturn(mockIterableMergeCommit);
        Document mockDocumentMergeCommit = Mockito.mock(Document.class);
        when(mockIterableMergeCommit.first()).thenReturn(mockDocumentMergeCommit);
        when(mockDocumentMergeCommit.toJson()).thenReturn(jsonMergeCommit);

        // Call parse Commit method
        v.addReference(prLink);
        patchFinder.parseReferences(v, nc);

        // Verify Hunks in the commit
        List<Integer> hunks = new ArrayList<>();
        hunks.add(49);

        Vulnerability.Patch vulnerable_file = new Vulnerability.Patch(
                "lib/omniauth/strategies/oauth2.rb",
                "2012-09-08T09:26:41Z",
                hunks);

        assertEquals(v.getPatches().size(), 1);
        List<String> filenames = v.getPatches().stream()
                .map(Vulnerability.Patch::getFileName).collect(Collectors.toList());

        assertTrue(filenames.contains(vulnerable_file.getFileName()));
    }

    @Test
    public void parsingIssuesGHTorrent() throws Exception {
        // Setup mocks to test the response
        String issueLink = "https://github.com/python/cpython/pull/32";
        String jsonIssue = readFile("./src/test/resources/patches/issue.txt");

        FindIterable mockIterable = Mockito.mock(FindIterable.class);
        when(issuesMock.find((Bson) Mockito.any())).thenReturn(mockIterable);
        Document mockDocument = Mockito.mock(Document.class);
        when(mockIterable.first()).thenReturn(mockDocument);
        when(mockDocument.toJson()).thenReturn(jsonIssue);

        // Mock pull request behaviour
        String jsonPullRequest = readFile("./src/test/resources/patches/pr_issue.txt");

        FindIterable mockIterablePR = Mockito.mock(FindIterable.class);
        when(prsMock.find((Bson) Mockito.any())).thenReturn(mockIterablePR);
        Document mockDocumentPR = Mockito.mock(Document.class);
        when(mockIterablePR.first()).thenReturn(mockDocumentPR);
        when(mockDocumentPR.toJson()).thenReturn(jsonPullRequest);

        // Mock commit behaviour
        String jsonMergeCommit = readFile("./src/test/resources/patches/commit_issue.txt");

        FindIterable mockIterableMergeCommit = Mockito.mock(FindIterable.class);
        when(commitsMock.find(eq("sha", Mockito.any()))).thenReturn(mockIterableMergeCommit);
        Document mockDocumentMergeCommit = Mockito.mock(Document.class);
        when(mockIterableMergeCommit.first()).thenReturn(mockDocumentMergeCommit);
        when(mockDocumentMergeCommit.toJson()).thenReturn(jsonMergeCommit);

        // Call parse Commit method
        var vp = patchFinder.parseReference(issueLink);

        // Verify Hunks in the commit
        List<Integer> hunks = new ArrayList<>();
        hunks.add(13);

        Vulnerability.Patch vulnerable_file = new Vulnerability.Patch(
                "Lib/importlib/abc.py",
                "2017-02-16T02:00:32Z",
                hunks);

        assertEquals(5, vp.size());
        List<String> filenames = vp.stream()
                .map(Vulnerability.Patch::getFileName).collect(Collectors.toList());

        assertTrue(filenames.contains(vulnerable_file.getFileName()));
    }

    @Test
    public void parsingIssuesGithub() throws Exception {
        // Setup mocks to test the response
        String issueLink = "https://github.com/python/cpython/pull/32";
        Vulnerability v = new Vulnerability("CVE-TEST-ID");
        v.setPublishedDate("2015-04-08T09:26:41Z");
        String jsonIssue = readFile("./src/test/resources/patches/issue.txt");
        when(nc.findPatchEntry(issueLink)).thenReturn(Optional.empty());

        FindIterable mockIterable = Mockito.mock(FindIterable.class);
        when(issuesMock.find((Bson) Mockito.any())).thenReturn(mockIterable);
        Document mockDocument = Mockito.mock(Document.class);
        when(mockIterable.first()).thenReturn(mockDocument);
        when(mockDocument.toJson()).thenReturn(null);

        when(clientMock.sendGet(Mockito.any())).thenReturn(jsonIssue);

        // Mock pull request behaviour
        String jsonPullRequest = readFile("./src/test/resources/patches/pr_issue.txt");

        FindIterable mockIterablePR = Mockito.mock(FindIterable.class);
        when(prsMock.find((Bson) Mockito.any())).thenReturn(mockIterablePR);
        Document mockDocumentPR = Mockito.mock(Document.class);
        when(mockIterablePR.first()).thenReturn(mockDocumentPR);
        when(mockDocumentPR.toJson()).thenReturn(jsonPullRequest);

        // Mock commit behaviour
        String jsonMergeCommit = readFile("./src/test/resources/patches/commit_issue.txt");

        FindIterable mockIterableMergeCommit = Mockito.mock(FindIterable.class);
        when(commitsMock.find(eq("sha", Mockito.any()))).thenReturn(mockIterableMergeCommit);
        Document mockDocumentMergeCommit = Mockito.mock(Document.class);
        when(mockIterableMergeCommit.first()).thenReturn(mockDocumentMergeCommit);
        when(mockDocumentMergeCommit.toJson()).thenReturn(jsonMergeCommit);

        // Call parse Commit method
        v.addReference(issueLink);
        patchFinder.parseReferences(v, nc);

        // Verify Hunks in the commit
        List<Integer> hunks = new ArrayList<>();
        hunks.add(13);

        Vulnerability.Patch vulnerable_file = new Vulnerability.Patch(
                "Lib/importlib/abc.py",
                "2017-02-16T02:00:32Z",
                hunks);

        assertEquals(5, v.getPatches().size());
        List<String> filenames = v.getPatches().stream()
                .map(Vulnerability.Patch::getFileName).collect(Collectors.toList());

        assertTrue(filenames.contains(vulnerable_file.getFileName()));
    }

    @Test
    public void testPatchEntryAlreadyInNitrite() {
        NitriteController nc = Mockito.mock(NitriteController.class);
        Vulnerability v = new Vulnerability("TEST");
        v.addReference("ref");
        HashSet<Vulnerability.Patch> files = new HashSet<>();
        Vulnerability.Patch f = new Vulnerability.Patch("test_file",
                "test_date", new ArrayList<>());
        files.add(f);
        when(nc.findPatchEntry("ref")).thenReturn(Optional.of(files));

        patchFinder.parseReferences(v, nc);
        assertTrue(v.getPatches().contains(f));
    }

    @Test
    public void testParseGitTrackerCommit() throws Exception {
        String refLink = "https://git.savannah.gnu.org/cgit/gnulib.git/commit/?id=5513b40999149090987a0341c018d05d3eea1272";
        when(clientMock.sendGet(refLink.replaceFirst("/commit/", "/rawdiff/"))).thenReturn(gitTrackerPatch);
        NitriteController nc = Mockito.mock(NitriteController.class);
        when(nc.findPatchEntry(refLink)).thenReturn(Optional.empty());

        Vulnerability v = new Vulnerability("TEST");
        v.addReference(refLink);

        // Expected vulnerability
        Vulnerability.Patch patch_1 = new Vulnerability.Patch();
        patch_1.setFileName("ChangeLog");
        List<Integer> ln_1 = new ArrayList<>(Arrays.asList(3));
        patch_1.setLineNumbers(ln_1);

        Vulnerability.Patch patch_2 = new Vulnerability.Patch();
        patch_2.setFileName("lib/regcomp.c");
        List<Integer> ln_2 = new ArrayList<>(Arrays.asList(2194, 2204, 2211));
        patch_2.setLineNumbers(ln_2);

        patchFinder.parseReferences(v, nc);

        assertTrue(v.getPatches().contains(patch_1));
        assertTrue(v.getPatches().contains(patch_2));
    }

    @Test
    public void testParseApacheSVN() throws Exception {
        String refLink = "https://svn.apache.org/viewvc?view=revision&revision=936540";
        String revisionHTML = readFile("./src/test/resources/patches/apache_svn_revision.html");
        when(clientMock.sendGet(refLink)).thenReturn(revisionHTML);
        when(clientMock.sendGet("https://svn.apache.org/viewvc/tomcat/tc6.0.x/trunk/java/org/apache/catalina/authenticator/AuthenticatorBase.java?r1=936540&r2=936539&pathrev=936540&view=patch"))
                .thenReturn(apacheSVNPatch);

        NitriteController nc = Mockito.mock(NitriteController.class);
        when(nc.findPatchEntry(refLink)).thenReturn(Optional.empty());

        Vulnerability v = new Vulnerability("TEST");
        v.addReference(refLink);

        // Expected vulnerability
        Vulnerability.Patch patch_1 = new Vulnerability.Patch();
        patch_1.setFileName("tomcat/tc6.0.x/trunk/java/org/apache/catalina/authenticator/AuthenticatorBase.java");
        List<Integer> ln_1 = new ArrayList<>(Arrays.asList(102));
        patch_1.setLineNumbers(ln_1);
        patch_1.setPatchDate("2010-04-21");

        patchFinder.parseReferences(v, nc);

        assertTrue(v.getPatches().contains(patch_1));
    }

    @Test
    public void testParseJIRATicketAttachments() throws Exception {
        String refLink = "https://issues.apache.org/jira/browse/ZOOKEEPER-1392";
        String jiraTicketApiJson = readFile("./src/test/resources/patches/jira_ticket_response.json");
        String jiraTicketPatchContent = readFile("./src/test/resources/patches/jira_ticket_patch_content.txt");

        when(clientMock.sendGet("https://issues.apache.org/jira/rest/api/2/issue/ZOOKEEPER-1392"))
                .thenReturn(jiraTicketApiJson);
        when(clientMock.sendGet("https://issues.apache.org/jira/secure/attachment/12595780/ZOOKEEPER-1392.patch"))
                .thenReturn(jiraTicketPatchContent);

        NitriteController nc = Mockito.mock(NitriteController.class);
        when(nc.findPatchEntry(refLink)).thenReturn(Optional.empty());

        Vulnerability v = new Vulnerability("TEST");
        v.addReference(refLink);

        // Expected vulnerability
        Vulnerability.Patch patch_1 = new Vulnerability.Patch();
        patch_1.setFileName("src/java/test/org/apache/zookeeper/test/ACLTest.java");
        List<Integer> ln_1 = new ArrayList<>(Arrays.asList(31, 38, 40, 80));
        patch_1.setLineNumbers(ln_1);
        patch_1.setPatchDate("2013-08-04");


        Vulnerability.Patch patch_2 = new Vulnerability.Patch();
        patch_2.setFileName("src/java/main/org/apache/zookeeper/server/FinalRequestProcessor.java");
        List<Integer> ln_2 = new ArrayList<>(Arrays.asList(327));
        patch_2.setLineNumbers(ln_2);
        patch_2.setPatchDate("2013-08-04");

        patchFinder.parseReferences(v, nc);

        v.getPatches().forEach(System.out::println);
        assertTrue(v.getPatches().contains(patch_1));
        assertTrue(v.getPatches().contains(patch_2));
    }


    @Test
    public void testParseJIRATicketComments() throws Exception {
        var refLink = "https://jira.mongodb.org/browse/SERVER-40563";
        var commitLink = "https://github.com/mongodb/mongo/commit/443e8974d66a3ddd2ad89f8b3f9c2ebb7d8d9500";
        var jiraTicketApiJson = readFile("./src/test/resources/patches/jira_ticket_mongo_comments.json");
        var patchCommitJson = readFile("./src/test/resources/patches/jira_ticket_mongo_commit.json");

        when(clientMock.sendGet("https://jira.mongodb.org/rest/api/2/issue/SERVER-40563"))
                .thenReturn(jiraTicketApiJson);

        var mockIterable = Mockito.mock(FindIterable.class);
        when(commitsMock.find((Bson) Mockito.any())).thenReturn(mockIterable);
        var mockDocument = Mockito.mock(Document.class);
        when(mockIterable.first()).thenReturn(mockDocument);
        when(mockDocument.toJson()).thenReturn(null);

        when(clientMock.sendGet("https://api.github.com/repos/mongodb/mongo/commits/443e8974d66a3ddd2ad89f8b3f9c2ebb7d8d9500"))
                .thenReturn(patchCommitJson);

        var nc = Mockito.mock(NitriteController.class);
        when(nc.findPatchEntry(refLink)).thenReturn(Optional.empty());

        var patch = new Patch("rpm/init.d-mongod", new ArrayList<>(Arrays.asList(103, 111)), commitLink);
        patch.setPatchDate("2019-05-24");

        var v = new Vulnerability("TEST");
        v.addReference(refLink);

        patchFinder.parseReferences(v, nc);

        assertTrue(v.getPatches().contains(patch));
        var vcsPatch = "git://github.com/mongodb/mongo@443e8974d66a3ddd2ad89f8b3f9c2ebb7d8d9500";
        assertTrue(v.getPatchLinks().contains(vcsPatch));
    }

    @Test
    public void testParseBugzillaBug() throws Exception {
        var ref = "https://bugs.kde.org/show_bug.cgi?id=97608";

        var responseAttach = readFile("./src/test/resources/patches/bugzilla/bugs_kde.json");
        var responseComments = readFile("./src/test/resources/patches/bugzilla/bugs_kde_comments.json");
        var responseInfo = readFile("./src/test/resources/patches/bugzilla/bugs_kde_info.json");

        when(clientMock.sendGet("https://bugs.kde.org/rest/bug/97608")).thenReturn(responseInfo);
        when(clientMock.sendGet("https://bugs.kde.org/rest/bug/97608/attachment")).thenReturn(responseAttach);
        when(clientMock.sendGet("https://bugs.kde.org/rest/bug/97608/comment")).thenReturn(responseComments);
        var nc = Mockito.mock(NitriteController.class);
        when(nc.findPatchEntry(ref)).thenReturn(Optional.empty());

        var patch = new Vulnerability.Patch("kdelibs-3.3.2/dcop/dcopidlng/dcopidlng",
                "2005-01-21",
                new ArrayList<>(Arrays.asList(6, 10, 12)));

        var v = new Vulnerability("TEST");
        v.addReference(ref);

        patchFinder.parseReferences(v, nc);
        assertTrue(v.getPatches().contains(patch));
    }

    @Test
    public void testParseBugzillaBugComments() throws Exception {
        String ref = "https://bugs.eclipse.org/bugs/show_bug.cgi?id=546577";

        String responseAttach = readFile("./src/test/resources/patches/bugzilla/bugs_jetty_attach.json");
        String responseComments = readFile("./src/test/resources/patches/bugzilla/bugs_jetty_comments.json");
        String responseInfo = readFile("./src/test/resources/patches/bugzilla/bugs_jetty_info.json");

        when(clientMock.sendGet("https://bugs.eclipse.org/bugs/rest/bug/546577/attachment")).thenReturn(responseAttach);
        when(clientMock.sendGet("https://bugs.eclipse.org/bugs/rest/bug/546577/comment")).thenReturn(responseComments);
        when(clientMock.sendGet("https://bugs.eclipse.org/bugs/rest/bug/546577")).thenReturn(responseInfo);

        // Mock commit behaviour
        String jsonMergeCommit = readFile("./src/test/resources/patches/commit_issue.txt");

        FindIterable mockIterableMergeCommit = Mockito.mock(FindIterable.class);
        when(commitsMock.find(eq("sha", Mockito.any()))).thenReturn(mockIterableMergeCommit);
        Document mockDocumentMergeCommit = Mockito.mock(Document.class);
        when(mockIterableMergeCommit.first()).thenReturn(mockDocumentMergeCommit);
        when(mockDocumentMergeCommit.toJson()).thenReturn(jsonMergeCommit);

        var patches = new HashSet<Vulnerability.Patch>();
        var patch = new Vulnerability.Patch("Lib/importlib/abc.py",
                "2017-02-16",
                new ArrayList<>(Arrays.asList(16, 37, 60, 65, 97, 101)));
        patches.add(patch);

        NitriteController nc = Mockito.mock(NitriteController.class);
        when(nc.findPatchEntry(ref)).thenReturn(Optional.empty());

        Vulnerability v = new Vulnerability("TEST");
        v.addReference(ref);

        patchFinder.parseReferences(v, nc);
        v.getPatches().forEach(System.out::println);
        assertTrue(v.getPatches().contains(patch));
    }

    @Test
    public void testApacheMailingList() throws Exception {
        var ref = "https://lists.apache.org/thread.html/f20bb4e055d8394fc525cc7772fb84096f706389043e76220c8a29a4@<hdfs-dev.hadoop.apache.org>";

        String response = readFile("./src/test/resources/patches/list_apache_message.txt");
        when(clientMock.sendGet("https://lists.apache.org/api/source.lua/f20bb4e055d8394fc525cc7772fb84096f706389043e76220c8a29a4@<hdfs-dev.hadoop.apache.org>"))
                .thenReturn(response);
        NitriteController nc = Mockito.mock(NitriteController.class);
        when(nc.findPatchEntry(ref)).thenReturn(Optional.empty());

        String jiraTicketApiJson = readFile("./src/test/resources/patches/jira_ticket_response.json");
        String jiraTicketPatchContent = readFile("./src/test/resources/patches/jira_ticket_patch_content.txt");

        when(clientMock.sendGet("https://issues.apache.org/jira/rest/api/2/issue/HDFS-8432"))
                .thenReturn(jiraTicketApiJson);
        when(clientMock.sendGet("https://issues.apache.org/jira/secure/attachment/12595780/ZOOKEEPER-1392.patch"))
                .thenReturn(jiraTicketPatchContent);

        Vulnerability v = new Vulnerability("TEST");
        v.addReference(ref);

        // Expected vulnerability
        Vulnerability.Patch patch_1 = new Vulnerability.Patch();
        patch_1.setFileName("src/java/test/org/apache/zookeeper/test/ACLTest.java");
        List<Integer> ln_1 = new ArrayList<>(Arrays.asList(31, 38, 40, 80));
        patch_1.setPatchDate("2013-08-04");
        patch_1.setLineNumbers(ln_1);

        Vulnerability.Patch patch_2 = new Vulnerability.Patch();
        patch_2.setFileName("src/java/main/org/apache/zookeeper/server/FinalRequestProcessor.java");
        List<Integer> ln_2 = new ArrayList<>(Arrays.asList(327));
        patch_2.setPatchDate("2013-08-04");
        patch_2.setLineNumbers(ln_2);

        patchFinder.parseReferences(v, nc);

        assertTrue(v.getPatches().contains(patch_1));
        assertTrue(v.getPatches().contains(patch_2));
    }

    @Test
    public void testGetPatchesInPrsThatMentionIssue() throws Exception {
        var ref = "https://github.com/uclouvain/openjpeg/issues/1044";
        var issueJson = readFile("./src/test/resources/patches/issueMentionsPr/issueAPIv4.json");
        var prJson = readFile("./src/test/resources/patches/issueMentionsPr/prAPIv3.json");
        var commitJson = readFile("./src/test/resources/patches/issueMentionsPr/commitAPIv3.json");
        var issueV3Json = readFile("./src/test/resources/patches/issueMentionsPr/issueAPIv3.json");

        when(clientMock.sendPost(Mockito.any(),Mockito.any(),Mockito.any())).thenReturn(issueJson);
        when(clientMock.sendGet("https://api.github.com/repos/uclouvain/openjpeg/issues/1044")).thenReturn(issueV3Json);
        when(clientMock.sendGet("https://api.github.com/repos/uclouvain/openjpeg/pulls/1160")).thenReturn(prJson);
        when(clientMock.sendGet("https://api.github.com/repos/uclouvain/openjpeg/commits/92023cd6c377e0384a7725949b25655d4d94dced"))
                .thenReturn(commitJson);
        when(nc.findPatchEntry(ref)).thenReturn(Optional.empty());

        FindIterable mockIterable = Mockito.mock(FindIterable.class);
        when(issuesMock.find((Bson) Mockito.any())).thenReturn(mockIterable);
        when(prsMock.find((Bson) Mockito.any())).thenReturn(mockIterable);
        when(commitsMock.find((Bson) Mockito.any())).thenReturn(mockIterable);
        Document mockDocument = Mockito.mock(Document.class);
        when(mockIterable.first()).thenReturn(mockDocument);
        when(mockDocument.toJson()).thenReturn(null);

        HashSet<Vulnerability.Patch> patches_exp = new HashSet<>();
        Vulnerability.Patch patch_1 = new Vulnerability.Patch("src/bin/jp2/convert.c", "2018-11-16", new ArrayList<>(Arrays.asList(2236)));
        Vulnerability.Patch patch_2 = new Vulnerability.Patch("src/bin/jpwl/convert.c", "2018-11-16", new ArrayList<>(Arrays.asList(1352)));
        Vulnerability.Patch patch_3 = new Vulnerability.Patch("src/bin/jp3d/convert.c", "2018-11-16", new ArrayList<>(Arrays.asList(300)));
        patches_exp.add(patch_1);
        patches_exp.add(patch_2);
        patches_exp.add(patch_3);

        Vulnerability v = new Vulnerability();
        v.addPatchLink(ref);
        patchFinder.parseReferences(v, nc);

        assertEquals(patches_exp, v.getPatches());
    }

    @Test
    public void testGetReferencesInIssueComments() throws Exception {
        var ref = "https://github.com/uclouvain/openjpeg/issues/1126";
        var issueJson = readFile("./src/test/resources/patches/refsInIssueComments/issueAPIv4.json");
        var commitJson = readFile("./src/test/resources/patches/refsInIssueComments/commitAPIv3.json");
        var issueV3Json = readFile("./src/test/resources/patches/refsInIssueComments/issueAPIv3.json");

        when(clientMock.sendPost(Mockito.any(),Mockito.any(),Mockito.any())).thenReturn(issueJson);
        when(clientMock.sendGet("https://api.github.com/repos/uclouvain/openjpeg/issues/1126")).thenReturn(issueV3Json);
        when(clientMock.sendGet("https://api.github.com/repos/uclouvain/openjpeg/commits/619e1b086eaa21ebd9b23eb67deee543b07bf06f"))
                .thenReturn(commitJson);
        when(nc.findPatchEntry(ref)).thenReturn(Optional.empty());

        FindIterable mockIterable = Mockito.mock(FindIterable.class);
        when(issuesMock.find((Bson) Mockito.any())).thenReturn(mockIterable);
        when(prsMock.find((Bson) Mockito.any())).thenReturn(mockIterable);
        when(commitsMock.find((Bson) Mockito.any())).thenReturn(mockIterable);
        Document mockDocument = Mockito.mock(Document.class);
        when(mockIterable.first()).thenReturn(mockDocument);
        when(mockDocument.toJson()).thenReturn(null);

        HashSet<Vulnerability.Patch> patches_exp = new HashSet<>();
        Vulnerability.Patch patch_1 = new Vulnerability.Patch("src/bin/jpwl/convert.c", "2018-11-23", new ArrayList<>(Arrays.asList(44, 1865)));
        patches_exp.add(patch_1);

        Vulnerability v = new Vulnerability();
        v.addPatchLink(ref);
        patchFinder.parseReferences(v, nc);

        assertEquals(patches_exp, v.getPatches());
    }

    @Test
    public void testGetCommitThatClosedIssue() throws Exception {
        var ref = "https://github.com/hapijs/subtext/issues/72";
        var issueJson = readFile("./src/test/resources/patches/commitClosesIssue/issueAPIv4.json");
        var commitJson = readFile("./src/test/resources/patches/commitClosesIssue/commitAPIv3.json");
        var issueV3Json = readFile("./src/test/resources/patches/commitClosesIssue/issueAPIv3.json");

        when(clientMock.sendPost(Mockito.any(),Mockito.any(),Mockito.any())).thenReturn(issueJson);
        when(clientMock.sendGet("https://api.github.com/repos/hapijs/subtext/issues/72")).thenReturn(issueV3Json);
        when(clientMock.sendGet("https://api.github.com/repos/hapijs/subtext/commits/1e2aed64b7154e1786d866a3b5bdd4f36e9f492d"))
                .thenReturn(commitJson);
        when(nc.findPatchEntry(ref)).thenReturn(Optional.empty());

        FindIterable mockIterable = Mockito.mock(FindIterable.class);
        when(issuesMock.find((Bson) Mockito.any())).thenReturn(mockIterable);
        when(prsMock.find((Bson) Mockito.any())).thenReturn(mockIterable);
        when(commitsMock.find((Bson) Mockito.any())).thenReturn(mockIterable);
        Document mockDocument = Mockito.mock(Document.class);
        when(mockIterable.first()).thenReturn(mockDocument);
        when(mockDocument.toJson()).thenReturn(null);

        HashSet<Vulnerability.Patch> patches_exp = new HashSet<>();
        Vulnerability.Patch patch_1 = new Vulnerability.Patch("lib/index.js", "2019-09-13", new ArrayList<>(Arrays.asList(309,407,411,416)));
        Vulnerability.Patch patch_2 = new Vulnerability.Patch("test/index.js", "2019-09-13", new ArrayList<>(Arrays.asList(167)));
        patches_exp.add(patch_1);
        patches_exp.add(patch_2);

        Vulnerability v = new Vulnerability();
        v.addPatchLink(ref);
        patchFinder.parseReferences(v, nc);

        assertEquals(patches_exp, v.getPatches());
    }

    @Test
    public void testGetCommitReferencingIssue() throws Exception {
        var ref = "https://github.com/expressjs/serve-static/issues/26";
        var issueJson = readFile("./src/test/resources/patches/commitReferencingIssue/issueAPIv4.json");
        var commitJson = readFile("./src/test/resources/patches/commitReferencingIssue/commitAPIv3.json");
        var issueV3Json = readFile("./src/test/resources/patches/commitReferencingIssue/issueAPIv3.json");

        when(clientMock.sendPost(Mockito.any(),Mockito.any(),Mockito.any())).thenReturn(issueJson);
        when(clientMock.sendGet("https://api.github.com/repos/expressjs/serve-static/issues/26")).thenReturn(issueV3Json);
        when(clientMock.sendGet("https://api.github.com/repos/expressjs/serve-static/commits/1bb77964849f82bd9276de30259e9546c6f84e8f"))
                .thenReturn(commitJson);
        when(nc.findPatchEntry(ref)).thenReturn(Optional.empty());

        FindIterable mockIterable = Mockito.mock(FindIterable.class);
        when(issuesMock.find((Bson) Mockito.any())).thenReturn(mockIterable);
        when(prsMock.find((Bson) Mockito.any())).thenReturn(mockIterable);
        when(commitsMock.find((Bson) Mockito.any())).thenReturn(mockIterable);
        Document mockDocument = Mockito.mock(Document.class);
        when(mockIterable.first()).thenReturn(mockDocument);
        when(mockDocument.toJson()).thenReturn(null);

        HashSet<Vulnerability.Patch> patches_exp = new HashSet<>();
        Vulnerability.Patch patch_1 = new Vulnerability.Patch("index.js", "2015-01-03", new ArrayList<>(Arrays.asList(82,84,86,119)));
        patches_exp.add(patch_1);

        Vulnerability v = new Vulnerability();
        v.addPatchLink(ref);
        patchFinder.parseReferences(v, nc);

        assertEquals(patches_exp, v.getPatches());
    }

    @Test
    public void testParseGLCommit() throws Exception {
        String refLink = "https://gitlab.com/gnutls/gnutls/-/commit/c2646aeee94e71cb15c90a3147cf3b5b0ca158ca";
        String projectLink = "https://gitlab.com/api/v4/projects/gnutls%2Fgnutls";
        String commitLink = "https://gitlab.com/api/v4/projects/179611/repository/commits/c2646aeee94e71cb15c90a3147cf3b5b0ca158ca";
        String genericPatch = readFile("./src/test/resources/patches/GitLab/gnutls_commit.patch");
        String projectJson = readFile("./src/test/resources/patches/GitLab/gnutls_project.json");
        String commitJson = readFile("./src/test/resources/patches/GitLab/gnutls_commit.json");

        when(clientMock.sendGet(refLink + ".diff")).thenReturn(genericPatch);
        when(clientMock.sendGet(projectLink)).thenReturn(projectJson);
        when(clientMock.sendGet(commitLink)).thenReturn(commitJson);

        NitriteController nc = Mockito.mock(NitriteController.class);
        when(nc.findPatchEntry(refLink)).thenReturn(Optional.empty());

        Vulnerability v = new Vulnerability("TEST");
        v.addReference(refLink);

        // Expected vulnerability
        Vulnerability.Patch patch_1 = new Vulnerability.Patch();
        patch_1.setFileName("lib/stek.c");
        List<Integer> ln_1 = new ArrayList<>(Arrays.asList(326));
        patch_1.setLineNumbers(ln_1);
        patch_1.setPatchDate("2020-06-03");

        Vulnerability.Patch patch_2 = new Vulnerability.Patch();
        patch_2.setFileName("tests/resume-with-previous-stek.c");
        List<Integer> ln_2 = new ArrayList<>(Arrays.asList(199));
        patch_2.setLineNumbers(ln_2);
        patch_2.setPatchDate("2020-06-03");


        Vulnerability.Patch patch_3 = new Vulnerability.Patch();
        patch_3.setFileName("tests/tls13/prf-early.c");
        List<Integer> ln_3 = new ArrayList<>(Arrays.asList(126));
        patch_3.setLineNumbers(ln_3);
        patch_3.setPatchDate("2020-06-03");

        patchFinder.parseReferences(v, nc);

        assertTrue(v.getPatches().contains(patch_1));
        assertTrue(v.getPatches().contains(patch_2));
        assertTrue(v.getPatches().contains(patch_3));
    }

    @Test
    public void testParseGLMergeRequest() throws Exception {
        String refLink = "https://gitlab.com/gnutls/gnutls/-/merge_requests/657";
        String projectLink = "https://gitlab.com/api/v4/projects/gnutls%2Fgnutls";
        String mrLink = "https://gitlab.com/api/v4/projects/179611/merge_requests/657";
        String commitLink = "https://gitlab.com/api/v4/projects/179611/repository/commits/c48e8d25d2d378f6b258de05e3e80fed19d788fa";
        String commitDiff = "https://gitlab.com/gnutls/gnutls/-/commit/c48e8d25d2d378f6b258de05e3e80fed19d788fa.diff";
        String genericPatch = readFile("./src/test/resources/patches/GitLab/gnutls_commit_2.patch");
        String projectJson = readFile("./src/test/resources/patches/GitLab/gnutls_project.json");
        String commitJson = readFile("./src/test/resources/patches/GitLab/gnutls_commit_2.json");
        String mrJson = readFile("./src/test/resources/patches/GitLab/gnutls_mr.json");

        when(clientMock.sendGet(mrLink)).thenReturn(mrJson);
        when(clientMock.sendGet(commitDiff)).thenReturn(genericPatch);
        when(clientMock.sendGet(projectLink)).thenReturn(projectJson);
        when(clientMock.sendGet(commitLink)).thenReturn(commitJson);

        NitriteController nc = Mockito.mock(NitriteController.class);
        when(nc.findPatchEntry(refLink)).thenReturn(Optional.empty());

        Vulnerability v = new Vulnerability("TEST");
        v.addReference(refLink);

        // Expected vulnerability
        Vulnerability.Patch patch_1 = new Vulnerability.Patch();
        patch_1.setFileName("lib/priority_options.gperf");
        List<Integer> ln_1 = new ArrayList<>(Arrays.asList(13));
        patch_1.setLineNumbers(ln_1);
        patch_1.setPatchDate("2018-06-12");

        Vulnerability.Patch patch_2 = new Vulnerability.Patch();
        patch_2.setFileName("lib/cipher.h");
        List<Integer> ln_2 = new ArrayList<>(Arrays.asList(33));
        patch_2.setLineNumbers(ln_2);
        patch_2.setPatchDate("2018-06-12");


        Vulnerability.Patch patch_3 = new Vulnerability.Patch();
        patch_3.setFileName("lib/handshake.c");
        List<Integer> ln_3 = new ArrayList<>(Arrays.asList(1828, 1881));
        patch_3.setLineNumbers(ln_3);
        patch_3.setPatchDate("2018-06-12");

        patchFinder.parseReferences(v, nc);

        assertTrue(v.getPatches().contains(patch_1));
        assertTrue(v.getPatches().contains(patch_2));
        assertTrue(v.getPatches().contains(patch_3));
    }

    @Test
    public void testParseGLIssue() throws Exception {
        String refLink = "https://gitlab.com/gitlab-org/gitlab-foss/-/issues/53385";
        String projectLink = "https://gitlab.com/api/v4/projects/gitlab-org%2Fgitlab-foss";
        String issueLink = "https://gitlab.com/api/v4/projects/13083/issues/53385/related_merge_requests";
        String commitLink = "https://gitlab.com/api/v4/projects/13083/repository/commits/ffdb1c1b100b9fd05fdcc790116250c85aa45ca8";
        String commitDiff = "https://gitlab.com/gitlab-org/gitlab-foss/-/commit/ffdb1c1b100b9fd05fdcc790116250c85aa45ca8.diff";
        String genericPatch = readFile("./src/test/resources/patches/GitLab/gitlab_commit.patch");
        String projectJson = readFile("./src/test/resources/patches/GitLab/gitlab_project.json");
        String commitJson = readFile("./src/test/resources/patches/GitLab/gitlab_commit.json");
        String issueJson = readFile("./src/test/resources/patches/GitLab/gitlab_issue_mrs.json");

        when(clientMock.sendGet(projectLink)).thenReturn(projectJson);
        when(clientMock.sendGet(issueLink)).thenReturn(issueJson);
        when(clientMock.sendGet(commitLink)).thenReturn(commitJson);
        when(clientMock.sendGet(commitDiff)).thenReturn(genericPatch);

        NitriteController nc = Mockito.mock(NitriteController.class);
        when(nc.findPatchEntry(refLink)).thenReturn(Optional.empty());

        Vulnerability v = new Vulnerability("TEST");
        v.addReference(refLink);

        // Expected vulnerability
        Vulnerability.Patch patch_1 = new Vulnerability.Patch();
        patch_1.setFileName("qa/qa/page/project/show.rb");
        List<Integer> ln_1 = new ArrayList<>(Arrays.asList(8));
        patch_1.setLineNumbers(ln_1);
        patch_1.setPatchDate("2019-07-04");

        patchFinder.parseReferences(v, nc);

        assertTrue(v.getPatches().contains(patch_1));
    }

    @Test
    public void testParseBitBucketCommit() throws Exception {
        String refLink = "https://bitbucket.org/asomov/snakeyaml/commits/da11ddbd91c1f8392ea932b37fa48110fa54ed8c";
        String apiLink = "https://bitbucket.org/api/2.0/repositories/asomov/snakeyaml/commit/da11ddbd91c1f8392ea932b37fa48110fa54ed8c";
        String commitDiffLink = "https://bitbucket.org/api/2.0/repositories/asomov/snakeyaml/diff/da11ddbd91c1f8392ea932b37fa48110fa54ed8c";

        String commitJson = readFile("./src/test/resources/patches/BitBucketPatches/commitPatch.json");
        String commitDiff = readFile("./src/test/resources/patches/BitBucketPatches/commitDiff.txt");

        when(clientMock.sendGet(apiLink)).thenReturn(commitJson);
        when(clientMock.sendGet(commitDiffLink)).thenReturn(commitDiff);

        NitriteController nc = Mockito.mock(NitriteController.class);
        when(nc.findPatchEntry(refLink)).thenReturn(Optional.empty());

        HashSet<Vulnerability.Patch> patches_exp = new HashSet<>();
        Vulnerability.Patch patch_1 = new Vulnerability.Patch("src/main/java/org/yaml/snakeyaml/Yaml.java",
                "2020-02-24", new ArrayList<>(Arrays.asList(85,470,484,553,566)));
        patches_exp.add(patch_1);

        Vulnerability v = new Vulnerability();
        v.addPatchLink(refLink);
        patchFinder.parseReferences(v, nc);

        assertEquals(patches_exp, v.getPatches());
    }

    @Test
    public void testParseBitBucketPullRequest() throws Exception {
        String refLink = "https://bitbucket.org/asomov/snakeyaml/pull-requests/42";
        String apiLinkPR = "https://bitbucket.org/api/2.0/repositories/asomov/snakeyaml/pullrequests/42";
        String apiLinkCommit = "https://bitbucket.org/api/2.0/repositories/asomov/snakeyaml/commit/da11ddbd91c1f8392ea932b37fa48110fa54ed8c";
        String commitDiffLink = "https://bitbucket.org/api/2.0/repositories/asomov/snakeyaml/diff/da11ddbd91c1f8392ea932b37fa48110fa54ed8c";

        String commitJson = readFile("./src/test/resources/patches/BitBucketPatches/commitPatch.json");
        String commitDiff = readFile("./src/test/resources/patches/BitBucketPatches/commitDiff.txt");
        String prJson = readFile("./src/test/resources/patches/BitBucketPatches/pullRequest.json");

        when(clientMock.sendGet(apiLinkPR)).thenReturn(prJson);
        when(clientMock.sendGet(apiLinkCommit)).thenReturn(commitJson);
        when(clientMock.sendGet(commitDiffLink)).thenReturn(commitDiff);

        NitriteController nc = Mockito.mock(NitriteController.class);
        when(nc.findPatchEntry(refLink)).thenReturn(Optional.empty());

        HashSet<Vulnerability.Patch> patches_exp = new HashSet<>();
        Vulnerability.Patch patch_1 = new Vulnerability.Patch("src/main/java/org/yaml/snakeyaml/Yaml.java",
                "2020-02-24", new ArrayList<>(Arrays.asList(85,470,484,553,566)));
        patches_exp.add(patch_1);

        Vulnerability v = new Vulnerability();
        v.addPatchLink(refLink);
        patchFinder.parseReferences(v, nc);

        assertEquals(patches_exp, v.getPatches());
    }

    @Test
    public void testParseBitBucketIssueComments() throws Exception {
        String refLink = "https://bitbucket.org/asomov/snakeyaml/issues/377";
        String apiLinkCommit = "https://bitbucket.org/api/2.0/repositories/asomov/snakeyaml/commit/da11ddbd91c1f8392ea932b37fa48110fa54ed8c";
        String commitDiffLink = "https://bitbucket.org/api/2.0/repositories/asomov/snakeyaml/diff/da11ddbd91c1f8392ea932b37fa48110fa54ed8c";
        String apiLinkAttachments = "https://bitbucket.org/api/2.0/repositories/asomov/snakeyaml/issues/377/attachments";
        String apiLinkComments = "https://bitbucket.org/api/2.0/repositories/asomov/snakeyaml/issues/377/comments";

        String emptyAttachments = readFile("./src/test/resources/patches/BitBucketPatches/emptyAttachments.json");
        String commentsJson = readFile("./src/test/resources/patches/BitBucketPatches/issueComments.json");
        String commitJson = readFile("./src/test/resources/patches/BitBucketPatches/commitPatch.json");
        String commitDiff = readFile("./src/test/resources/patches/BitBucketPatches/commitDiff.txt");

        when(clientMock.sendGet(apiLinkCommit)).thenReturn(commitJson);
        when(clientMock.sendGet(commitDiffLink)).thenReturn(commitDiff);
        when(clientMock.sendGet(apiLinkComments)).thenReturn(commentsJson);
        when(clientMock.sendGet(apiLinkAttachments)).thenReturn(emptyAttachments);

        NitriteController nc = Mockito.mock(NitriteController.class);
        when(nc.findPatchEntry(refLink)).thenReturn(Optional.empty());

        HashSet<Vulnerability.Patch> patches_exp = new HashSet<>();
        Vulnerability.Patch patch_1 = new Vulnerability.Patch("src/main/java/org/yaml/snakeyaml/Yaml.java",
                "2020-02-24", new ArrayList<>(Arrays.asList(85,470,484,553,566)));
        patches_exp.add(patch_1);

        Vulnerability v = new Vulnerability();
        v.addPatchLink(refLink);
        patchFinder.parseReferences(v, nc);

        assertEquals(patches_exp, v.getPatches());
    }

    @Test
    public void testParseBitBucketIssueAttachments() throws Exception {
        String refLink = "https://bitbucket.org/asomov/snakeyaml/issues/377";
        String apiLinkAttachments = "https://bitbucket.org/api/2.0/repositories/asomov/snakeyaml/issues/377/attachments";
        String apiLinKAttachmentsPatch = "https://bitbucket.org/api/2.0/repositories/asomov/snakeyaml/issues/377/attachments/wiki.patch";
        String apiLinkComments = "https://bitbucket.org/api/2.0/repositories/asomov/snakeyaml/issues/377/comments";

        String attachmentsJson = readFile("./src/test/resources/patches/BitBucketPatches/issueAttachments.json");
        String attachmentPatch = readFile("./src/test/resources/patches/BitBucketPatches/issueAttachmentPatch.patch");
        String emptyComments = readFile("./src/test/resources/patches/BitBucketPatches/emptyComments.json");

        when(clientMock.sendGet(apiLinkAttachments)).thenReturn(attachmentsJson);
        when(clientMock.sendGet(apiLinKAttachmentsPatch)).thenReturn(attachmentPatch);
        when(clientMock.sendGet(apiLinkComments)).thenReturn(emptyComments);

        NitriteController nc = Mockito.mock(NitriteController.class);
        when(nc.findPatchEntry(refLink)).thenReturn(Optional.empty());

        HashSet<Vulnerability.Patch> patches_exp = new HashSet<>();
        Vulnerability.Patch patch_1 = new Vulnerability.Patch("src/main/java/org/yaml/snakeyaml/LoaderOptions.java",
                null, new ArrayList<>(Arrays.asList(22,60)));
        patches_exp.add(patch_1);

        Vulnerability v = new Vulnerability();
        v.addPatchLink(refLink);
        patchFinder.parseReferences(v, nc);

        assertEquals(patches_exp, v.getPatches());
    }

    @Test
    public void testGetGithubBaseRepo() {
        var ref1 = "https://github.com/fasten-project/vulnerability-producer/commit/e357a6740dbd96a6412c0810228124aa8db91212";
        var ref2 = "https://github.com/fasten-project/vulnerability-producer/issue/3";
        var ref3 = "https://github.com/fasten-project/fasten/issues/33";
        Vulnerability v = new Vulnerability("TEST");
        v.addPatchLink(ref1);
        v.addPatchLink(ref2);
        v.addPatchLink(ref3);

        var repoBase = patchFinder.getBaseRepo(v);
        assertEquals("https://github.com/fasten-project/vulnerability-producer", repoBase);
    }

    @Test
    public void testMercurialDiffParser() throws IOException {
        var ref = "http://hg.code.sf.net/p/graphicsmagick/code/rev/135bdcb88b8d";
        var patch = readFile("./src/test/resources/patches/hg.patch");

        when(clientMock.sendGet(ref.replace("rev", "raw-rev"))).thenReturn(patch);

        var v = new Vulnerability("TEST");
        v.addPatchLink(ref);

        var nc = Mockito.mock(NitriteController.class);
        when(nc.findPatchEntry(ref)).thenReturn(Optional.empty());

        patchFinder.parseReferences(v, nc);
        var patches = new HashSet<Vulnerability.Patch>();
        patches.add(new Vulnerability.Patch("coders/wpg.c",
                "2017-11-05",
                new ArrayList<>(Arrays.asList(343, 344, 348))));
        assertEquals(patches, v.getPatches());
    }

    @Test
    public void testParserDiffOfDiff() throws Exception {
        var patches = DiffParser.getPatchesFromDiffs(diffOfDiff);
        var exPatches = new HashSet<Patch>();
        exPatches.add(new Patch("core/src/components/toolbar/test/spec/index.html", null, Arrays.asList(17, 22)));
        assertEquals(exPatches, patches);
    }
}

