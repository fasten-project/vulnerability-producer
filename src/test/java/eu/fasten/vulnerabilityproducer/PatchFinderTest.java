/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package eu.fasten.vulnerabilityproducer;

import com.mongodb.client.FindIterable;
import com.mongodb.client.MongoCollection;
import com.mongodb.client.MongoDatabase;
import eu.fasten.vulnerabilityproducer.db.NitriteController;
import eu.fasten.vulnerabilityproducer.utils.*;
import eu.fasten.vulnerabilityproducer.utils.Vulnerability.*;
import eu.fasten.vulnerabilityproducer.utils.connections.JavaHttpClient;
import eu.fasten.vulnerabilityproducer.utils.patches.*;
import org.apache.commons.io.FileUtils;
import org.bson.Document;
import org.bson.conversions.Bson;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.mockito.Mockito;

import java.io.File;
import java.io.IOException;
import java.nio.charset.StandardCharsets;
import java.util.*;
import java.util.stream.Collectors;

import static com.mongodb.client.model.Filters.eq;
import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.junit.jupiter.api.Assertions.assertTrue;
import static org.mockito.Mockito.when;

public class PatchFinderTest {

    // Inject Java Http Client to test
    JavaHttpClient clientMock = Mockito.mock(JavaHttpClient.class);

    // Inject mock database in order to test
    MongoDatabase dbMock = Mockito.mock(MongoDatabase.class);
    MongoCollection<Document> commitsMock = Mockito.mock(MongoCollection.class);
    MongoCollection<Document> prsMock = Mockito.mock(MongoCollection.class);
    MongoCollection<Document> issuesMock = Mockito.mock(MongoCollection.class);
    NitriteController nc = Mockito.mock(NitriteController.class);
    private PatchFinder patchFinder;

    static final String validJSON = "{" +
            "\"comment\":\"Testing\"," +
            "\"cve_id\":\"CVE-TEST-TEST\"," +
            "\"cwes\":[]," +
            "\"description\":\"Retrieve Relevant files\"," +
            "\"exploit_exists\":false," +
            "\"has_annotations\":true," +
            "\"is_processed\":true," +
            "\"langs\":[]," +
            "\"master_commit\":{" +
                "\"commit_hash\":\"hash\"," +
                "\"commit_link\":\"https://github.com/generic_commit\"," +
                "\"relevant_files\":[\"./src/index.c\",\"./src/mock.c\"]," +
                "\"repo_name\":\"test\"," +
                "\"repo_owner\":\"random\"," +
                "\"repo_url\":\"" +
            "\"}," +
            "\"products\":[]," +
            "\"references\":[]," +
            "\"score\":null" +
            "}";

    final String emptyMasterCommit = "{" +
            "\"comment\":\"Testing JSON body valid\"," +
            "\"cve_id\":\"CVE-TEST-TEST\"," +
            "\"cwes\":[]," +
            "\"description\":\"n/a\"," +
            "\"exploit_exists\":false," +
            "\"has_annotations\":true," +
            "\"is_processed\":true," +
            "\"langs\":[\"ANY\"]," +
            "\"master_commit\":{}," +
            "\"products\":[{\"product\":\"python\",\"vendor\":\"python\"}]," +
            "\"references\":[]," +
            "\"score\":null" +
            "}";

    final String gitTrackerPatch = "diff --git a/ChangeLog b/ChangeLog\n" +
            "index f846aac70..7c8356600 100644\n" +
            "--- a/ChangeLog\n" +
            "+++ b/ChangeLog\n" +
            "@@ -1,5 +1,13 @@\n" +
            " 2015-09-19  Paul Eggert  <eggert@cs.ucla.edu>\n" +
            " \n" +
            "+\tDiagnose ERE '()|\\1'\n" +
            "+\tProblem reported by Hanno BÃ¶ck in: http://bugs.gnu.org/21513\n" +
            "+\t* lib/regcomp.c (parse_reg_exp): While parsing alternatives, keep\n" +
            "+\ttrack of the set of previously-completed subexpressions available\n" +
            "+\tbefore the first alternative, and restore this set just before\n" +
            "+\tparsing each subsequent alternative.  This lets us diagnose the\n" +
            "+\tinvalid back-reference in the ERE '()|\\1'.\n" +
            "+\n" +
            " \tregex: merge patches from libc\n" +
            " \n" +
            " \t2015-09-08  Joseph Myers  <joseph@codesourcery.com>\n" +
            "diff --git a/lib/regcomp.c b/lib/regcomp.c\n" +
            "index f50afb4bb..4cbb1b2b9 100644\n" +
            "--- a/lib/regcomp.c\n" +
            "+++ b/lib/regcomp.c\n" +
            "@@ -2191,6 +2191,7 @@ parse_reg_exp (re_string_t *regexp, regex_t *preg, re_token_t *token,\n" +
            " {\n" +
            "   re_dfa_t *dfa = preg->buffer;\n" +
            "   bin_tree_t *tree, *branch = NULL;\n" +
            "+  bitset_word_t initial_bkref_map = dfa->completed_bkref_map;\n" +
            "   tree = parse_branch (regexp, preg, token, syntax, nest, err);\n" +
            "   if (BE (*err != REG_NOERROR && tree == NULL, 0))\n" +
            "     return NULL;\n" +
            "@@ -2201,6 +2202,8 @@ parse_reg_exp (re_string_t *regexp, regex_t *preg, re_token_t *token,\n" +
            "       if (token->type != OP_ALT && token->type != END_OF_RE\n" +
            " \t  && (nest == 0 || token->type != OP_CLOSE_SUBEXP))\n" +
            " \t{\n" +
            "+\t  bitset_word_t accumulated_bkref_map = dfa->completed_bkref_map;\n" +
            "+\t  dfa->completed_bkref_map = initial_bkref_map;\n" +
            " \t  branch = parse_branch (regexp, preg, token, syntax, nest, err);\n" +
            " \t  if (BE (*err != REG_NOERROR && branch == NULL, 0))\n" +
            " \t    {\n" +
            "@@ -2208,6 +2211,7 @@ parse_reg_exp (re_string_t *regexp, regex_t *preg, re_token_t *token,\n" +
            " \t\tpostorder (tree, free_tree, NULL);\n" +
            " \t      return NULL;\n" +
            " \t    }\n" +
            "+\t  dfa->completed_bkref_map |= accumulated_bkref_map;\n" +
            " \t}\n" +
            "       else\n" +
            " \tbranch = NULL;";

    final String apacheSVNPatch = "--- tomcat/tc6.0.x/trunk/java/org/apache/catalina/authenticator/AuthenticatorBase.java\t2010/04/21 22:11:29\t936539\n" +
            "+++ tomcat/tc6.0.x/trunk/java/org/apache/catalina/authenticator/AuthenticatorBase.java\t2010/04/21 22:12:05\t936540\n" +
            "@@ -99,6 +99,11 @@\n" +
            " \n" +
            " \n" +
            "     /**\n" +
            "+     * Default authentication realm name.\n" +
            "+     */\n" +
            "+    protected static final String REALM_NAME = \"Authentication required\";\n" +
            "+\n" +
            "+    /**\n" +
            "      * The message digest algorithm to be used when generating session\n" +
            "      * identifiers.  This must be an algorithm supported by the\n" +
            "      * <code>java.security.MessageDigest</code> class on your platform.";

    final String errorJSON = "{\"code\":404,\"error\":\"Not found\"}";

    final String diffOfDiff = "diff --git a/core/src/components/toolbar/test/spec/index.html b/core/src/components/toolbar/test/spec/index.html\n" +
            "index 511b2958c26..4a6510855ac 100644\n" +
            "--- a/core/src/components/toolbar/test/spec/index.html\n" +
            "+++ b/core/src/components/toolbar/test/spec/index.html\n" +
            "@@ -1,4 +1,3 @@\n" +
            "-@@ -0,0 +1,59 @@\n" +
            " <!DOCTYPE html>\n" +
            " <html dir=\"ltr\">\n" +
            " \n" +
            "@@ -14,12 +13,12 @@\n" +
            " \n" +
            " <body>\n" +
            "   <ion-app>\n" +
            "-    <ion-header>\n" +
            "+    <ion-content>\n" +
            "       <ion-toolbar color=\"tertiary\">\n" +
            "         <ion-buttons slot=\"start\">\n" +
            "           <ion-menu-button auto-hide=\"false\"></ion-menu-button>\n" +
            "         </ion-buttons>\n" +
            "-        <ion-buttons slot=\"secondary\">\n" +
            "+        <ion-buttons slot=\"primary\">\n" +
            "           <ion-button>\n" +
            "             <ion-icon slot=\"icon-only\" name=\"download\"></ion-icon>\n" +
            "           </ion-button>";

    @BeforeEach
    public void setup() {
        when(dbMock.getCollection("commits")).thenReturn(commitsMock);
        when(dbMock.getCollection("pull_requests")).thenReturn(prsMock);
        when(dbMock.getCollection("issues")).thenReturn(issuesMock);
        patchFinder = new PatchFinder(dbMock, clientMock, "mocktoken");

        // Do not validate refs when testing
        when(clientMock.validateAndRedirect(Mockito.anyString(), Mockito.any())).thenAnswer(i -> i.getArguments()[0]);
    }

    public static String readFile(String filePath) throws IOException {
        File file = new File(filePath);
        return FileUtils.readFileToString(file, StandardCharsets.UTF_8);
    }

    @Test
    public void parsingCommitsFromMongo() throws IOException {
        // Setup mocks to test the response
        var patchLink = "https://github.com/python/cpython/commit/fbf648ebba32bbc5aa571a4b09e2062a65fd2492";
        var jsonCommit = readFile("./src/test/resources/patches/commit.txt");

        var mockIterable = Mockito.mock(FindIterable.class);
        when(commitsMock.find(eq("sha", Mockito.any()))).thenReturn(mockIterable);
        var mockDocument = Mockito.mock(Document.class);
        when(mockIterable.first()).thenReturn(mockDocument);
        when(mockDocument.toJson()).thenReturn(jsonCommit);

        var vp = patchFinder.parseReference(patchLink);

        var originalChanges = new ArrayList<Integer>();
        var newChanges      = Arrays.asList(1971, 1972);

        var vulnerable_file = new Patch("Lib/test/test_socket.py",
                originalChanges,
                newChanges,
                patchLink,
                "2014-01-14T03:59:38Z");

        assertEquals(vp.size(), 4);
        var filenames = vp.stream().map(Patch::getFileName).collect(Collectors.toList());
        assertTrue(filenames.contains(vulnerable_file.getFileName()));
    }

    @Test
    public void parsingCommitsFromGithubAPI() throws Exception {
        var patchLink = "https://github.com/python/cpython/commit/fbf648ebba32bbc5aa571a4b09e2062a65fd2492";
        var v = new Vulnerability("CVE-TEST-ID");
        v.setPublishedDate("2013-01-14T03:59:38Z");
        var jsonCommit = readFile("./src/test/resources/patches/commit.txt");
        when(nc.findPatchEntry(patchLink)).thenReturn(Optional.empty());

        var mockIterable = Mockito.mock(FindIterable.class);
        when(commitsMock.find(eq("sha", Mockito.any()))).thenReturn(mockIterable);
        var mockDocument = Mockito.mock(Document.class);
        when(mockIterable.first()).thenReturn(mockDocument);
        when(mockDocument.toJson()).thenReturn(null);

        when(clientMock.sendGet(Mockito.any())).thenReturn(jsonCommit);

        // Call parse Commit method
        v.addReference(patchLink);
        patchFinder.parseReferences(v, nc);

        var originalChanges = new ArrayList<Integer>();
        var newChanges      = Arrays.asList(1971, 1972);

        var vulnerable_file = new Patch("Lib/test/test_socket.py",
                originalChanges,
                newChanges,
                patchLink,
                "2014-01-14T03:59:38Z");

        assertEquals(v.getPatches().size(), 4);
        List<String> filenames = v.getPatches().stream().map(Patch::getFileName).collect(Collectors.toList());
        assertTrue(filenames.contains(vulnerable_file.getFileName()));
    }

    @Test
    public void parsingPullRequestsGHTorrent() throws IOException {
        // Setup mocks to test the response
        var prLink = "https://github.com/omniauth/omniauth-oauth2/pull/25";
        var jsonCommit = readFile("./src/test/resources/patches/pr.txt");

        var mockIterable = Mockito.mock(FindIterable.class);
        when(prsMock.find((Bson) Mockito.any())).thenReturn(mockIterable);
        var mockDocument = Mockito.mock(Document.class);
        when(mockIterable.first()).thenReturn(mockDocument);
        when(mockDocument.toJson()).thenReturn(jsonCommit);

        // Mock commit behaviour
        var jsonMergeCommit = readFile("./src/test/resources/patches/pr_commit.txt");

        var mockIterableMergeCommit = Mockito.mock(FindIterable.class);
        when(commitsMock.find(eq("sha", Mockito.any()))).thenReturn(mockIterableMergeCommit);
        var mockDocumentMergeCommit = Mockito.mock(Document.class);
        when(mockIterableMergeCommit.first()).thenReturn(mockDocumentMergeCommit);
        when(mockDocumentMergeCommit.toJson()).thenReturn(jsonMergeCommit);

        // Call parse Commit method
        var vp = patchFinder.parseReference(prLink);

        // Verify Hunks in the commit
        var originalChanges = Arrays.asList(52, 53, 54);
        var newChanges      = Arrays.asList(52);

        var vulnerable_file = new Patch("lib/omniauth/strategies/oauth2.rb",
                originalChanges,
                newChanges,
                prLink,
                "2012-09-08T09:26:41Z");

        assertEquals(vp.size(), 1);
        List<String> filenames = vp.stream()
                .map(Patch::getFileName).collect(Collectors.toList());

        assertTrue(filenames.contains(vulnerable_file.getFileName()));
    }

    @Test
    public void parsingPullRequestsGithub() throws Exception {
        // Setup mocks to test the response
        var prLink = "https://github.com/omniauth/omniauth-oauth2/pull/25";
        var v = new Vulnerability("CVE-TEST-ID");
        v.setPublishedDate("2012-08-08T09:26:41Z");
        var jsonCommit = readFile("./src/test/resources/patches/pr.txt");
        when(nc.findPatchEntry(prLink)).thenReturn(Optional.empty());

        var mockIterable = Mockito.mock(FindIterable.class);
        when(prsMock.find((Bson) Mockito.any())).thenReturn(mockIterable);
        var mockDocument = Mockito.mock(Document.class);
        when(mockIterable.first()).thenReturn(mockDocument);
        when(mockDocument.toJson()).thenReturn(null);

        when(clientMock.sendGet(Mockito.any())).thenReturn(jsonCommit);

        // Mock commit behaviour
        var jsonMergeCommit = readFile("./src/test/resources/patches/pr_commit.txt");

        var mockIterableMergeCommit = Mockito.mock(FindIterable.class);
        when(commitsMock.find(eq("sha", Mockito.any()))).thenReturn(mockIterableMergeCommit);
        var mockDocumentMergeCommit = Mockito.mock(Document.class);
        when(mockIterableMergeCommit.first()).thenReturn(mockDocumentMergeCommit);
        when(mockDocumentMergeCommit.toJson()).thenReturn(jsonMergeCommit);

        // Call parse Commit method
        v.addReference(prLink);
        patchFinder.parseReferences(v, nc);

        var originalChanges = Arrays.asList(52, 53, 54);
        var newChanges      = Arrays.asList(52);

        var vulnerable_file = new Patch("lib/omniauth/strategies/oauth2.rb",
                originalChanges,
                newChanges,
                prLink,
                "2012-09-08T09:26:41Z");

        assertEquals(v.getPatches().size(), 1);
        var filenames = v.getPatches().stream().map(Patch::getFileName).collect(Collectors.toList());

        assertTrue(filenames.contains(vulnerable_file.getFileName()));
    }

    @Test
    public void parsingIssuesGHTorrent() throws Exception {
        // Setup mocks to test the response
        var issueLink = "https://github.com/python/cpython/pull/32";
        var jsonIssue = readFile("./src/test/resources/patches/issue.txt");

        var mockIterable = Mockito.mock(FindIterable.class);
        when(issuesMock.find((Bson) Mockito.any())).thenReturn(mockIterable);
        var mockDocument = Mockito.mock(Document.class);
        when(mockIterable.first()).thenReturn(mockDocument);
        when(mockDocument.toJson()).thenReturn(jsonIssue);

        // Mock pull request behaviour
        var jsonPullRequest = readFile("./src/test/resources/patches/pr_issue.txt");

        var mockIterablePR = Mockito.mock(FindIterable.class);
        when(prsMock.find((Bson) Mockito.any())).thenReturn(mockIterablePR);
        var mockDocumentPR = Mockito.mock(Document.class);
        when(mockIterablePR.first()).thenReturn(mockDocumentPR);
        when(mockDocumentPR.toJson()).thenReturn(jsonPullRequest);

        // Mock commit behaviour
        var jsonMergeCommit = readFile("./src/test/resources/patches/commit_issue.txt");

        var mockIterableMergeCommit = Mockito.mock(FindIterable.class);
        when(commitsMock.find(eq("sha", Mockito.any()))).thenReturn(mockIterableMergeCommit);
        var mockDocumentMergeCommit = Mockito.mock(Document.class);
        when(mockIterableMergeCommit.first()).thenReturn(mockDocumentMergeCommit);
        when(mockDocumentMergeCommit.toJson()).thenReturn(jsonMergeCommit);

        // Call parse Commit method
        var vp = patchFinder.parseReference(issueLink);

        // Verify Hunks in the commit
        var linesChanged = Arrays.asList(13);

        var vulnerable_file = new Patch(
                "Lib/importlib/abc.py",
                linesChanged,
                linesChanged,
                issueLink,
                "2017-02-16T02:00:32Z");

        assertEquals(5, vp.size());
        var filenames = vp.stream().map(Patch::getFileName).collect(Collectors.toList());
        assertTrue(filenames.contains(vulnerable_file.getFileName()));
    }

    @Test
    public void parsingIssuesGithub() throws Exception {
        // Setup mocks to test the response
        var issueLink = "https://github.com/python/cpython/pull/32";
        var v = new Vulnerability("CVE-TEST-ID");
        v.setPublishedDate("2015-04-08T09:26:41Z");
        var jsonIssue = readFile("./src/test/resources/patches/issue.txt");
        when(nc.findPatchEntry(issueLink)).thenReturn(Optional.empty());

        var mockIterable = Mockito.mock(FindIterable.class);
        when(issuesMock.find((Bson) Mockito.any())).thenReturn(mockIterable);
        var mockDocument = Mockito.mock(Document.class);
        when(mockIterable.first()).thenReturn(mockDocument);
        when(mockDocument.toJson()).thenReturn(null);

        when(clientMock.sendGet(Mockito.any())).thenReturn(jsonIssue);

        // Mock pull request behaviour
        var jsonPullRequest = readFile("./src/test/resources/patches/pr_issue.txt");

        var mockIterablePR = Mockito.mock(FindIterable.class);
        when(prsMock.find((Bson) Mockito.any())).thenReturn(mockIterablePR);
        var mockDocumentPR = Mockito.mock(Document.class);
        when(mockIterablePR.first()).thenReturn(mockDocumentPR);
        when(mockDocumentPR.toJson()).thenReturn(jsonPullRequest);

        // Mock commit behaviour
        var jsonMergeCommit = readFile("./src/test/resources/patches/commit_issue.txt");

        var mockIterableMergeCommit = Mockito.mock(FindIterable.class);
        when(commitsMock.find(eq("sha", Mockito.any()))).thenReturn(mockIterableMergeCommit);
        var mockDocumentMergeCommit = Mockito.mock(Document.class);
        when(mockIterableMergeCommit.first()).thenReturn(mockDocumentMergeCommit);
        when(mockDocumentMergeCommit.toJson()).thenReturn(jsonMergeCommit);

        // Call parse Commit method
        v.addReference(issueLink);
        patchFinder.parseReferences(v, nc);

        var linesChanged = Arrays.asList(13);

        var vulnerable_file = new Patch(
                "Lib/importlib/abc.py",
                linesChanged,
                linesChanged,
                issueLink,
                "2017-02-16T02:00:32Z");

        assertEquals(5, v.getPatches().size());
        var filenames = v.getPatches().stream()
                .map(Patch::getFileName).collect(Collectors.toList());

        assertTrue(filenames.contains(vulnerable_file.getFileName()));
    }

    @Test
    public void testPatchEntryAlreadyInNitrite() {
        var nc = Mockito.mock(NitriteController.class);
        var v = new Vulnerability("TEST");
        v.addReference("ref");
        var files = new HashSet<Patch>();
        var f = new Patch("test_file", new ArrayList<>(), new ArrayList<>(), "test_url", "test_date");
        files.add(f);
        when(nc.findPatchEntry("ref")).thenReturn(Optional.of(files));

        patchFinder.parseReferences(v, nc);
        assertTrue(v.getPatches().contains(f));
    }

    @Test
    public void testParseGitTrackerCommit() throws Exception {
        String refLink = "https://git.savannah.gnu.org/cgit/gnulib.git/commit/?id=5513b40999149090987a0341c018d05d3eea1272";
        when(clientMock.sendGet(refLink.replaceFirst("/commit/", "/rawdiff/"))).thenReturn(gitTrackerPatch);
        var nc = Mockito.mock(NitriteController.class);
        when(nc.findPatchEntry(refLink)).thenReturn(Optional.empty());

        Vulnerability v = new Vulnerability("TEST");
        v.addReference(refLink);

        // Expected vulnerability
        var patch_1 = new Patch();
        patch_1.setFileName("ChangeLog");
        var ln_1 = Arrays.asList(3, 4, 5, 6, 7, 8, 9, 10);
        patch_1.setNewChangedLineNumbers(ln_1);

        var patch_2 = new Patch();
        patch_2.setFileName("lib/regcomp.c");
        var ln_2 = Arrays.asList(2194, 2205, 2206, 2214);
        patch_2.setNewChangedLineNumbers(ln_2);

        patchFinder.parseReferences(v, nc);

        assertTrue(v.getPatches().contains(patch_1));
        assertTrue(v.getPatches().contains(patch_2));
    }

    @Test
    public void testParseApacheSVN() throws Exception {
        var refLink = "https://svn.apache.org/viewvc?view=revision&revision=936540";
        var revisionHTML = readFile("./src/test/resources/patches/apache_svn_revision.html");
        when(clientMock.sendGet(refLink)).thenReturn(revisionHTML);
        when(clientMock.sendGet("https://svn.apache.org/viewvc/tomcat/tc6.0.x/trunk/java/org/apache/catalina/authenticator/AuthenticatorBase.java?r1=936540&r2=936539&pathrev=936540&view=patch"))
                .thenReturn(apacheSVNPatch);

        var nc = Mockito.mock(NitriteController.class);
        when(nc.findPatchEntry(refLink)).thenReturn(Optional.empty());

        var v = new Vulnerability("TEST");
        v.addReference(refLink);

        // Expected vulnerability
        var patch_1 = new Patch();
        patch_1.setFileName("tomcat/tc6.0.x/trunk/java/org/apache/catalina/authenticator/AuthenticatorBase.java");
        var ln_1 = Arrays.asList(102, 103, 104, 105, 106);
        patch_1.setNewChangedLineNumbers(ln_1);
        patch_1.setPatchDate("2010-04-21");

        patchFinder.parseReferences(v, nc);

        assertTrue(v.getPatches().contains(patch_1));
    }

    @Test
    public void testParseJIRATicketAttachments() throws Exception {
        var refLink = "https://issues.apache.org/jira/browse/ZOOKEEPER-1392";
        var jiraTicketApiJson = readFile("./src/test/resources/patches/jira_ticket_response.json");
        var jiraTicketPatchContent = readFile("./src/test/resources/patches/jira_ticket_patch_content.txt");

        when(clientMock.sendGet("https://issues.apache.org/jira/rest/api/2/issue/ZOOKEEPER-1392"))
                .thenReturn(jiraTicketApiJson);
        when(clientMock.sendGet("https://issues.apache.org/jira/secure/attachment/12595780/ZOOKEEPER-1392.patch"))
                .thenReturn(jiraTicketPatchContent);

        var nc = Mockito.mock(NitriteController.class);
        when(nc.findPatchEntry(refLink)).thenReturn(Optional.empty());

        var v = new Vulnerability("TEST");
        v.addReference(refLink);

        var patch = new Patch(
                "src/java/main/org/apache/zookeeper/server/FinalRequestProcessor.java",
                Arrays.asList(),
                Arrays.asList(327, 328, 329, 330, 331, 332, 333, 334, 335, 336, 337),
                refLink,
                "2013-08-04"
        );

        patchFinder.parseReferences(v, nc);

        assertTrue(v.getPatches().contains(patch));
    }


    @Test
    public void testParseJIRATicketComments() throws Exception {
        var refLink = "https://jira.mongodb.org/browse/SERVER-40563";
        var commitLink = "https://github.com/mongodb/mongo/commit/443e8974d66a3ddd2ad89f8b3f9c2ebb7d8d9500";
        var jiraTicketApiJson = readFile("./src/test/resources/patches/jira_ticket_mongo_comments.json");
        var patchCommitJson = readFile("./src/test/resources/patches/jira_ticket_mongo_commit.json");

        when(clientMock.sendGet("https://jira.mongodb.org/rest/api/2/issue/SERVER-40563"))
                .thenReturn(jiraTicketApiJson);

        var mockIterable = Mockito.mock(FindIterable.class);
        when(commitsMock.find((Bson) Mockito.any())).thenReturn(mockIterable);
        var mockDocument = Mockito.mock(Document.class);
        when(mockIterable.first()).thenReturn(mockDocument);
        when(mockDocument.toJson()).thenReturn(null);

        when(clientMock.sendGet("https://api.github.com/repos/mongodb/mongo/commits/443e8974d66a3ddd2ad89f8b3f9c2ebb7d8d9500"))
                .thenReturn(patchCommitJson);

        var nc = Mockito.mock(NitriteController.class);
        when(nc.findPatchEntry(refLink)).thenReturn(Optional.empty());

        var originalChanges = Arrays.asList(103, 111);
        var newChanges = new ArrayList<Integer>();
        for (int i = 103; i <= 123; i++) newChanges.add(i);
        newChanges.add(131);
        var patch = new Patch("rpm/init.d-mongod",
                originalChanges,
                newChanges,
                commitLink,
                "2019-05-24");

        var v = new Vulnerability("TEST");
        v.addReference(refLink);

        patchFinder.parseReferences(v, nc);

        assertTrue(v.getPatches().contains(patch));
        var vcsPatch = "git://github.com/mongodb/mongo@443e8974d66a3ddd2ad89f8b3f9c2ebb7d8d9500";
        assertTrue(v.getPatches().iterator().next().getPatchUrl().equals(vcsPatch));
    }

    @Test
    public void testParseBugzillaBug() throws Exception {
        var ref = "https://bugs.kde.org/show_bug.cgi?id=97608";

        var responseAttach = readFile("./src/test/resources/patches/bugzilla/bugs_kde.json");
        var responseComments = readFile("./src/test/resources/patches/bugzilla/bugs_kde_comments.json");
        var responseInfo = readFile("./src/test/resources/patches/bugzilla/bugs_kde_info.json");

        when(clientMock.sendGet("https://bugs.kde.org/rest/bug/97608")).thenReturn(responseInfo);
        when(clientMock.sendGet("https://bugs.kde.org/rest/bug/97608/attachment")).thenReturn(responseAttach);
        when(clientMock.sendGet("https://bugs.kde.org/rest/bug/97608/comment")).thenReturn(responseComments);
        var nc = Mockito.mock(NitriteController.class);
        when(nc.findPatchEntry(ref)).thenReturn(Optional.empty());

        var patch = new Patch(
                "kdelibs-3.3.2/dcop/dcopidlng/dcopidlng",
                Arrays.asList(6, 10, 12),
                Arrays.asList(6, 7, 8, 12, 14),
                ref,
                "2005-01-21");

        var v = new Vulnerability("TEST");
        v.addReference(ref);

        patchFinder.parseReferences(v, nc);
        assertTrue(v.getPatches().contains(patch));
    }

    @Test
    public void testParseBugzillaBugComments() throws Exception {
        var ref = "https://bugs.eclipse.org/bugs/show_bug.cgi?id=546577";
        var vcsUrl = "git://github.com/eclipse/jetty.project@04c994712c0b29824633598cfe0bf709f3b96f09";

        var responseAttach = readFile("./src/test/resources/patches/bugzilla/bugs_jetty_attach.json");
        var responseComments = readFile("./src/test/resources/patches/bugzilla/bugs_jetty_comments.json");
        var responseInfo = readFile("./src/test/resources/patches/bugzilla/bugs_jetty_info.json");

        when(clientMock.sendGet("https://bugs.eclipse.org/bugs/rest/bug/546577/attachment")).thenReturn(responseAttach);
        when(clientMock.sendGet("https://bugs.eclipse.org/bugs/rest/bug/546577/comment")).thenReturn(responseComments);
        when(clientMock.sendGet("https://bugs.eclipse.org/bugs/rest/bug/546577")).thenReturn(responseInfo);

        // Mock commit behaviour
        var jsonMergeCommit = readFile("./src/test/resources/patches/commit_issue.txt");

        var mockIterableMergeCommit = Mockito.mock(FindIterable.class);
        when(commitsMock.find(eq("sha", Mockito.any()))).thenReturn(mockIterableMergeCommit);
        var mockDocumentMergeCommit = Mockito.mock(Document.class);
        when(mockIterableMergeCommit.first()).thenReturn(mockDocumentMergeCommit);
        when(mockDocumentMergeCommit.toJson()).thenReturn(jsonMergeCommit);

        var patches = new HashSet<Patch>();
        var patch = new Patch("Lib/importlib/abc.py",
                Arrays.asList(60, 61, 62, 97, 98, 99),
                Arrays.asList(16, 38, 39, 63, 64, 65, 68, 69, 70, 71,
                        72, 105, 106, 107, 109, 110, 111, 112, 113),
                vcsUrl,
                "2017-02-16");
        patches.add(patch);

        var nc = Mockito.mock(NitriteController.class);
        when(nc.findPatchEntry(ref)).thenReturn(Optional.empty());

        var v = new Vulnerability("TEST");
        v.addReference(ref);

        patchFinder.parseReferences(v, nc);
        assertTrue(v.getPatches().contains(patch));
    }

    @Test
    public void testApacheMailingList() throws Exception {
        var ref = "https://lists.apache.org/thread.html/f20bb4e055d8394fc525cc7772fb84096f706389043e76220c8a29a4@<hdfs-dev.hadoop.apache.org>";

        var response = readFile("./src/test/resources/patches/list_apache_message.txt");
        when(clientMock.sendGet("https://lists.apache.org/api/source.lua/f20bb4e055d8394fc525cc7772fb84096f706389043e76220c8a29a4@<hdfs-dev.hadoop.apache.org>"))
                .thenReturn(response);
        var nc = Mockito.mock(NitriteController.class);
        when(nc.findPatchEntry(ref)).thenReturn(Optional.empty());

        var jiraTicketApiJson = readFile("./src/test/resources/patches/jira_ticket_response.json");
        var jiraTicketPatchContent = readFile("./src/test/resources/patches/jira_ticket_patch_content.txt");

        when(clientMock.sendGet("https://issues.apache.org/jira/rest/api/2/issue/HDFS-8432"))
                .thenReturn(jiraTicketApiJson);
        when(clientMock.sendGet("https://issues.apache.org/jira/secure/attachment/12595780/ZOOKEEPER-1392.patch"))
                .thenReturn(jiraTicketPatchContent);

        var v = new Vulnerability("TEST");
        v.addReference(ref);

        var patch_1 = new Patch();
        patch_1.setFileName("src/java/main/org/apache/zookeeper/server/FinalRequestProcessor.java");
        patch_1.setPatchDate("2013-08-04");
        patch_1.setNewChangedLineNumbers(Arrays.asList(327, 328, 329, 330, 331,
                332, 333, 334, 335, 336, 337));

        patchFinder.parseReferences(v, nc);

        assertTrue(v.getPatches().contains(patch_1));
    }

    @Test
    public void testGetPatchesInPrsThatMentionIssue() throws Exception {
        var ref = "https://github.com/uclouvain/openjpeg/issues/1044";
        var vcsUrl = "git://github.com/uclouvain/openjpeg@92023cd6c377e0384a7725949b25655d4d94dced";
        var issueJson = readFile("./src/test/resources/patches/issueMentionsPr/issueAPIv4.json");
        var prJson = readFile("./src/test/resources/patches/issueMentionsPr/prAPIv3.json");
        var commitJson = readFile("./src/test/resources/patches/issueMentionsPr/commitAPIv3.json");
        var issueV3Json = readFile("./src/test/resources/patches/issueMentionsPr/issueAPIv3.json");

        when(clientMock.sendPost(Mockito.any(),Mockito.any(),Mockito.any())).thenReturn(issueJson);
        when(clientMock.sendGet("https://api.github.com/repos/uclouvain/openjpeg/issues/1044")).thenReturn(issueV3Json);
        when(clientMock.sendGet("https://api.github.com/repos/uclouvain/openjpeg/pulls/1160")).thenReturn(prJson);
        when(clientMock.sendGet("https://api.github.com/repos/uclouvain/openjpeg/commits/92023cd6c377e0384a7725949b25655d4d94dced"))
                .thenReturn(commitJson);
        when(nc.findPatchEntry(ref)).thenReturn(Optional.empty());

        var mockIterable = Mockito.mock(FindIterable.class);
        when(issuesMock.find((Bson) Mockito.any())).thenReturn(mockIterable);
        when(prsMock.find((Bson) Mockito.any())).thenReturn(mockIterable);
        when(commitsMock.find((Bson) Mockito.any())).thenReturn(mockIterable);
        var mockDocument = Mockito.mock(Document.class);
        when(mockIterable.first()).thenReturn(mockDocument);
        when(mockDocument.toJson()).thenReturn(null);

        var patches_exp = new HashSet<Patch>();
        var patch_1 = new Patch("src/bin/jp2/convert.c",
                Arrays.asList(),
                Arrays.asList(2236, 2237, 2238, 2239, 2240),
                vcsUrl,
        "2018-11-16");
        var patch_2 = new Patch("src/bin/jp3d/convert.c",
                Arrays.asList(300, 301),
                Arrays.asList(300, 301),
                vcsUrl,
                "2018-11-16");
        var patch_3 = new Patch("src/bin/jpwl/convert.c",
                Arrays.asList(1352),
                Arrays.asList(1352),
                vcsUrl,
                "2018-11-16");

        patches_exp.add(patch_1);
        patches_exp.add(patch_2);
        patches_exp.add(patch_3);

        var v = new Vulnerability();
        v.addPatchLink(ref);
        patchFinder.parseReferences(v, nc);

        assertEquals(patches_exp, v.getPatches());
    }

    @Test
    public void testGetReferencesInIssueComments() throws Exception {
        var ref = "https://github.com/uclouvain/openjpeg/issues/1126";
        var issueJson = readFile("./src/test/resources/patches/refsInIssueComments/issueAPIv4.json");
        var commitJson = readFile("./src/test/resources/patches/refsInIssueComments/commitAPIv3.json");
        var issueV3Json = readFile("./src/test/resources/patches/refsInIssueComments/issueAPIv3.json");

        when(clientMock.sendPost(Mockito.any(),Mockito.any(),Mockito.any())).thenReturn(issueJson);
        when(clientMock.sendGet("https://api.github.com/repos/uclouvain/openjpeg/issues/1126")).thenReturn(issueV3Json);
        when(clientMock.sendGet("https://api.github.com/repos/uclouvain/openjpeg/commits/619e1b086eaa21ebd9b23eb67deee543b07bf06f"))
                .thenReturn(commitJson);
        when(nc.findPatchEntry(ref)).thenReturn(Optional.empty());

        var mockIterable = Mockito.mock(FindIterable.class);
        when(issuesMock.find((Bson) Mockito.any())).thenReturn(mockIterable);
        when(prsMock.find((Bson) Mockito.any())).thenReturn(mockIterable);
        when(commitsMock.find((Bson) Mockito.any())).thenReturn(mockIterable);
        var mockDocument = Mockito.mock(Document.class);
        when(mockIterable.first()).thenReturn(mockDocument);
        when(mockDocument.toJson()).thenReturn(null);

        var patches_exp = new HashSet<Patch>();
        var patch_1 = new Patch("src/bin/jpwl/convert.c",
                new ArrayList<>(),
                Arrays.asList(44, 1866, 1867, 1868, 1869, 1870, 1871, 1872, 1873, 1874),
                ref,
                "2018-11-23");
        patches_exp.add(patch_1);

        var v = new Vulnerability();
        v.addPatchLink(ref);
        patchFinder.parseReferences(v, nc);

        assertEquals(patches_exp, v.getPatches());
    }

    @Test
    public void testGetCommitThatClosedIssue() throws Exception {
        var ref = "https://github.com/hapijs/subtext/issues/72";
        var issueJson = readFile("./src/test/resources/patches/commitClosesIssue/issueAPIv4.json");
        var commitJson = readFile("./src/test/resources/patches/commitClosesIssue/commitAPIv3.json");
        var issueV3Json = readFile("./src/test/resources/patches/commitClosesIssue/issueAPIv3.json");

        when(clientMock.sendPost(Mockito.any(),Mockito.any(),Mockito.any())).thenReturn(issueJson);
        when(clientMock.sendGet("https://api.github.com/repos/hapijs/subtext/issues/72")).thenReturn(issueV3Json);
        when(clientMock.sendGet("https://api.github.com/repos/hapijs/subtext/commits/1e2aed64b7154e1786d866a3b5bdd4f36e9f492d"))
                .thenReturn(commitJson);
        when(nc.findPatchEntry(ref)).thenReturn(Optional.empty());

        var mockIterable = Mockito.mock(FindIterable.class);
        when(issuesMock.find((Bson) Mockito.any())).thenReturn(mockIterable);
        when(prsMock.find((Bson) Mockito.any())).thenReturn(mockIterable);
        when(commitsMock.find((Bson) Mockito.any())).thenReturn(mockIterable);
        var mockDocument = Mockito.mock(Document.class);
        when(mockIterable.first()).thenReturn(mockDocument);
        when(mockDocument.toJson()).thenReturn(null);

        var patch_1 = new Patch("lib/index.js",
                Arrays.asList(309, 407),
                Arrays.asList(309, 407, 411, 417, 418, 419, 420, 421, 422, 423),
                ref,
                "2018-11-16");

        var v = new Vulnerability();
        v.addPatchLink(ref);
        patchFinder.parseReferences(v, nc);

        assertTrue(v.getPatches().contains(patch_1));
    }

    @Test
    public void testGetCommitReferencingIssue() throws Exception {
        var ref = "https://github.com/expressjs/serve-static/issues/26";
        var vcsUrl = "git://github.com/expressjs/serve-static@1bb77964849f82bd9276de30259e9546c6f84e8f";
        var issueJson = readFile("./src/test/resources/patches/commitReferencingIssue/issueAPIv4.json");
        var commitJson = readFile("./src/test/resources/patches/commitReferencingIssue/commitAPIv3.json");
        var issueV3Json = readFile("./src/test/resources/patches/commitReferencingIssue/issueAPIv3.json");

        when(clientMock.sendPost(Mockito.any(),Mockito.any(),Mockito.any())).thenReturn(issueJson);
        when(clientMock.sendGet("https://api.github.com/repos/expressjs/serve-static/issues/26")).thenReturn(issueV3Json);
        when(clientMock.sendGet("https://api.github.com/repos/expressjs/serve-static/commits/1bb77964849f82bd9276de30259e9546c6f84e8f"))
                .thenReturn(commitJson);
        when(nc.findPatchEntry(ref)).thenReturn(Optional.empty());

        var mockIterable = Mockito.mock(FindIterable.class);
        when(issuesMock.find((Bson) Mockito.any())).thenReturn(mockIterable);
        when(prsMock.find((Bson) Mockito.any())).thenReturn(mockIterable);
        when(commitsMock.find((Bson) Mockito.any())).thenReturn(mockIterable);
        var mockDocument = Mockito.mock(Document.class);
        when(mockIterable.first()).thenReturn(mockDocument);
        when(mockDocument.toJson()).thenReturn(null);

        var patch_1 = new Patch("index.js",
                Arrays.asList(82),
                Arrays.asList(82, 83, 85, 88, 122, 123, 124, 125, 126, 127, 128,
                        129, 130, 131, 132, 133, 134, 135, 136, 137),
                vcsUrl,
                "2015-01-03");

        var v = new Vulnerability();
        v.addPatchLink(ref);
        patchFinder.parseReferences(v, nc);

        assertEquals(v.getPatches().iterator().next(), patch_1);
    }

    @Test
    public void testParseGLCommit() throws Exception {
        var refLink = "https://gitlab.com/gnutls/gnutls/-/commit/c2646aeee94e71cb15c90a3147cf3b5b0ca158ca";
        var projectLink = "https://gitlab.com/api/v4/projects/gnutls%2Fgnutls";
        var commitLink = "https://gitlab.com/api/v4/projects/179611/repository/commits/c2646aeee94e71cb15c90a3147cf3b5b0ca158ca";
        var genericPatch = readFile("./src/test/resources/patches/GitLab/gnutls_commit.patch");
        var projectJson = readFile("./src/test/resources/patches/GitLab/gnutls_project.json");
        var commitJson = readFile("./src/test/resources/patches/GitLab/gnutls_commit.json");

        when(clientMock.sendGet(refLink + ".diff")).thenReturn(genericPatch);
        when(clientMock.sendGet(projectLink)).thenReturn(projectJson);
        when(clientMock.sendGet(commitLink)).thenReturn(commitJson);

        var nc = Mockito.mock(NitriteController.class);
        when(nc.findPatchEntry(refLink)).thenReturn(Optional.empty());

        var v = new Vulnerability("TEST");
        v.addReference(refLink);

        // Expected vulnerability
        var patch_1 = new Patch();
        patch_1.setFileName("lib/stek.c");
        var ln_1 = Arrays.asList(326, 327, 328, 329, 330, 331,
                333, 334, 335, 336, 337, 339);
        var ln_2 = Arrays.asList(326, 327, 329, 331, 332);
        patch_1.setOriginalChangedLineNumbers(ln_1);
        patch_1.setNewChangedLineNumbers(ln_2);
        patch_1.setPatchDate("2020-06-03");

        patchFinder.parseReferences(v, nc);

        assertTrue(v.getPatches().contains(patch_1));
    }

    @Test
    public void testParseGLMergeRequest() throws Exception {
        var refLink = "https://gitlab.com/gnutls/gnutls/-/merge_requests/657";
        var projectLink = "https://gitlab.com/api/v4/projects/gnutls%2Fgnutls";
        var mrLink = "https://gitlab.com/api/v4/projects/179611/merge_requests/657";
        var commitLink = "https://gitlab.com/api/v4/projects/179611/repository/commits/c48e8d25d2d378f6b258de05e3e80fed19d788fa";
        var commitDiff = "https://gitlab.com/gnutls/gnutls/-/commit/c48e8d25d2d378f6b258de05e3e80fed19d788fa.diff";
        var genericPatch = readFile("./src/test/resources/patches/GitLab/gnutls_commit_2.patch");
        var projectJson = readFile("./src/test/resources/patches/GitLab/gnutls_project.json");
        var commitJson = readFile("./src/test/resources/patches/GitLab/gnutls_commit_2.json");
        var mrJson = readFile("./src/test/resources/patches/GitLab/gnutls_mr.json");

        when(clientMock.sendGet(mrLink)).thenReturn(mrJson);
        when(clientMock.sendGet(commitDiff)).thenReturn(genericPatch);
        when(clientMock.sendGet(projectLink)).thenReturn(projectJson);
        when(clientMock.sendGet(commitLink)).thenReturn(commitJson);

        var nc = Mockito.mock(NitriteController.class);
        when(nc.findPatchEntry(refLink)).thenReturn(Optional.empty());

        var v = new Vulnerability("TEST");
        v.addReference(refLink);

        // Expected vulnerability
        var patch_1 = new Patch();
        patch_1.setFileName("lib/priority.c");
        var ln_1 = Arrays.asList(458, 465, 499, 506);
        var ln_2 = Arrays.asList(812, 813, 814, 815);
        patch_1.setOriginalChangedLineNumbers(ln_1);
        patch_1.setNewChangedLineNumbers(ln_2);
        patch_1.setPatchDate("2018-06-12");

        patchFinder.parseReferences(v, nc);

        assertTrue(v.getPatches().contains(patch_1));
    }

    @Test
    public void testParseGLIssue() throws Exception {
        var refLink = "https://gitlab.com/gitlab-org/gitlab-foss/-/issues/53385";
        var projectLink = "https://gitlab.com/api/v4/projects/gitlab-org%2Fgitlab-foss";
        var issueLink = "https://gitlab.com/api/v4/projects/13083/issues/53385/related_merge_requests";
        var commitLink = "https://gitlab.com/api/v4/projects/13083/repository/commits/ffdb1c1b100b9fd05fdcc790116250c85aa45ca8";
        var commitDiff = "https://gitlab.com/gitlab-org/gitlab-foss/-/commit/ffdb1c1b100b9fd05fdcc790116250c85aa45ca8.diff";
        var genericPatch = readFile("./src/test/resources/patches/GitLab/gitlab_commit.patch");
        var projectJson = readFile("./src/test/resources/patches/GitLab/gitlab_project.json");
        var commitJson = readFile("./src/test/resources/patches/GitLab/gitlab_commit.json");
        var issueJson = readFile("./src/test/resources/patches/GitLab/gitlab_issue_mrs.json");

        when(clientMock.sendGet(projectLink)).thenReturn(projectJson);
        when(clientMock.sendGet(issueLink)).thenReturn(issueJson);
        when(clientMock.sendGet(commitLink)).thenReturn(commitJson);
        when(clientMock.sendGet(commitDiff)).thenReturn(genericPatch);

        var nc = Mockito.mock(NitriteController.class);
        when(nc.findPatchEntry(refLink)).thenReturn(Optional.empty());

        var v = new Vulnerability("TEST");
        v.addReference(refLink);

        // Expected vulnerability
        var patch_1 = new Patch();
        patch_1.setFileName("qa/qa/page/project/show.rb");
        var ln_1 = Arrays.asList(8);
        patch_1.setNewChangedLineNumbers(ln_1);
        patch_1.setPatchDate("2019-07-04");

        patchFinder.parseReferences(v, nc);

        assertTrue(v.getPatches().contains(patch_1));
    }

    @Test
    public void testParseBitBucketCommit() throws Exception {
        var refLink = "https://bitbucket.org/asomov/snakeyaml/commits/da11ddbd91c1f8392ea932b37fa48110fa54ed8c";
        var apiLink = "https://bitbucket.org/api/2.0/repositories/asomov/snakeyaml/commit/da11ddbd91c1f8392ea932b37fa48110fa54ed8c";
        var commitDiffLink = "https://bitbucket.org/api/2.0/repositories/asomov/snakeyaml/diff/da11ddbd91c1f8392ea932b37fa48110fa54ed8c";

        var commitJson = readFile("./src/test/resources/patches/BitBucketPatches/commitPatch.json");
        var commitDiff = readFile("./src/test/resources/patches/BitBucketPatches/commitDiff.txt");

        when(clientMock.sendGet(apiLink)).thenReturn(commitJson);
        when(clientMock.sendGet(commitDiffLink)).thenReturn(commitDiff);

        var nc = Mockito.mock(NitriteController.class);
        when(nc.findPatchEntry(refLink)).thenReturn(Optional.empty());

        var patches_exp = new HashSet<Patch>();
        var patch_1 = new Patch("src/main/java/org/yaml/snakeyaml/Yaml.java",
                Arrays.asList(85,470,484,553,566),
                Arrays.asList(85,470,484,553,566),
                refLink,
                "2020-02-24");
        patches_exp.add(patch_1);

        var v = new Vulnerability();
        v.addPatchLink(refLink);
        patchFinder.parseReferences(v, nc);

        assertEquals(patches_exp, v.getPatches());
    }

    @Test
    public void testParseBitBucketPullRequest() throws Exception {
        var refLink = "https://bitbucket.org/asomov/snakeyaml/pull-requests/42";
        var apiLinkPR = "https://bitbucket.org/api/2.0/repositories/asomov/snakeyaml/pullrequests/42";
        var apiLinkCommit = "https://bitbucket.org/api/2.0/repositories/asomov/snakeyaml/commit/da11ddbd91c1f8392ea932b37fa48110fa54ed8c";
        var commitDiffLink = "https://bitbucket.org/api/2.0/repositories/asomov/snakeyaml/diff/da11ddbd91c1f8392ea932b37fa48110fa54ed8c";

        var commitJson = readFile("./src/test/resources/patches/BitBucketPatches/commitPatch.json");
        var commitDiff = readFile("./src/test/resources/patches/BitBucketPatches/commitDiff.txt");
        var prJson = readFile("./src/test/resources/patches/BitBucketPatches/pullRequest.json");

        when(clientMock.sendGet(apiLinkPR)).thenReturn(prJson);
        when(clientMock.sendGet(apiLinkCommit)).thenReturn(commitJson);
        when(clientMock.sendGet(commitDiffLink)).thenReturn(commitDiff);

        var nc = Mockito.mock(NitriteController.class);
        when(nc.findPatchEntry(refLink)).thenReturn(Optional.empty());

        var patches_exp = new HashSet<Patch>();
        var patch_1 = new Patch("src/main/java/org/yaml/snakeyaml/Yaml.java",
                Arrays.asList(85,470,484,553,566),
                Arrays.asList(85,470,484,553,566),
                refLink,
                "2020-02-24");
        patches_exp.add(patch_1);

        var v = new Vulnerability();
        v.addPatchLink(refLink);
        patchFinder.parseReferences(v, nc);

        assertEquals(patches_exp, v.getPatches());
    }

    @Test
    public void testParseBitBucketIssueComments() throws Exception {
        var refLink = "https://bitbucket.org/asomov/snakeyaml/issues/377";
        var apiLinkCommit = "https://bitbucket.org/api/2.0/repositories/asomov/snakeyaml/commit/da11ddbd91c1f8392ea932b37fa48110fa54ed8c";
        var commitDiffLink = "https://bitbucket.org/api/2.0/repositories/asomov/snakeyaml/diff/da11ddbd91c1f8392ea932b37fa48110fa54ed8c";
        var apiLinkAttachments = "https://bitbucket.org/api/2.0/repositories/asomov/snakeyaml/issues/377/attachments";
        var apiLinkComments = "https://bitbucket.org/api/2.0/repositories/asomov/snakeyaml/issues/377/comments";

        var emptyAttachments = readFile("./src/test/resources/patches/BitBucketPatches/emptyAttachments.json");
        var commentsJson = readFile("./src/test/resources/patches/BitBucketPatches/issueComments.json");
        var commitJson = readFile("./src/test/resources/patches/BitBucketPatches/commitPatch.json");
        var commitDiff = readFile("./src/test/resources/patches/BitBucketPatches/commitDiff.txt");

        when(clientMock.sendGet(apiLinkCommit)).thenReturn(commitJson);
        when(clientMock.sendGet(commitDiffLink)).thenReturn(commitDiff);
        when(clientMock.sendGet(apiLinkComments)).thenReturn(commentsJson);
        when(clientMock.sendGet(apiLinkAttachments)).thenReturn(emptyAttachments);

        var nc = Mockito.mock(NitriteController.class);
        when(nc.findPatchEntry(refLink)).thenReturn(Optional.empty());

        var patches_exp = new HashSet<Patch>();
        var patch_1 = new Patch("src/main/java/org/yaml/snakeyaml/Yaml.java",
                Arrays.asList(85,470,484,553,566),
                Arrays.asList(85,470,484,553,566),
                refLink,
                "2020-02-24");
        patches_exp.add(patch_1);

        var v = new Vulnerability();
        v.addPatchLink(refLink);
        patchFinder.parseReferences(v, nc);

        assertEquals(patches_exp, v.getPatches());
    }

    @Test
    public void testParseBitBucketIssueAttachments() throws Exception {
        var refLink = "https://bitbucket.org/asomov/snakeyaml/issues/377";
        var apiLinkAttachments = "https://bitbucket.org/api/2.0/repositories/asomov/snakeyaml/issues/377/attachments";
        var apiLinKAttachmentsPatch = "https://bitbucket.org/api/2.0/repositories/asomov/snakeyaml/issues/377/attachments/wiki.patch";
        var apiLinkComments = "https://bitbucket.org/api/2.0/repositories/asomov/snakeyaml/issues/377/comments";

        var attachmentsJson = readFile("./src/test/resources/patches/BitBucketPatches/issueAttachments.json");
        var attachmentPatch = readFile("./src/test/resources/patches/BitBucketPatches/issueAttachmentPatch.patch");
        var emptyComments = readFile("./src/test/resources/patches/BitBucketPatches/emptyComments.json");

        when(clientMock.sendGet(apiLinkAttachments)).thenReturn(attachmentsJson);
        when(clientMock.sendGet(apiLinKAttachmentsPatch)).thenReturn(attachmentPatch);
        when(clientMock.sendGet(apiLinkComments)).thenReturn(emptyComments);

        var nc = Mockito.mock(NitriteController.class);
        when(nc.findPatchEntry(refLink)).thenReturn(Optional.empty());

        var patches_exp = new HashSet<Patch>();
        var patch_1 = new Patch("src/main/java/org/yaml/snakeyaml/LoaderOptions.java",
                new ArrayList<>(),
                Arrays.asList(22, 23, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77),
                refLink,
                null);
        patches_exp.add(patch_1);

        var v = new Vulnerability();
        v.addPatchLink(refLink);
        patchFinder.parseReferences(v, nc);

        assertEquals(patches_exp, v.getPatches());
    }

    @Test
    public void testGetGithubBaseRepo() {
        var ref1 = "https://github.com/fasten-project/vulnerability-producer/commit/e357a6740dbd96a6412c0810228124aa8db91212";
        var ref2 = "https://github.com/fasten-project/vulnerability-producer/issue/3";
        var ref3 = "https://github.com/fasten-project/fasten/issues/33";
        var v = new Vulnerability("TEST");
        v.addPatchLink(ref1);
        v.addPatchLink(ref2);
        v.addPatchLink(ref3);

        var repoBase = patchFinder.getBaseRepo(v);
        assertEquals("https://github.com/fasten-project/vulnerability-producer", repoBase);
    }

    @Test
    public void testMercurialDiffParser() throws IOException {
        var ref = "http://hg.code.sf.net/p/graphicsmagick/code/rev/135bdcb88b8d";
        var patch = readFile("./src/test/resources/patches/hg.patch");

        when(clientMock.sendGet(ref.replace("rev", "raw-rev"))).thenReturn(patch);

        var v = new Vulnerability("TEST");
        v.addPatchLink(ref);

        var nc = Mockito.mock(NitriteController.class);
        when(nc.findPatchEntry(ref)).thenReturn(Optional.empty());

        patchFinder.parseReferences(v, nc);
        var patches = new HashSet<Patch>();
        patches.add(new Patch("coders/wpg.c",
                Arrays.asList(345, 348),
                Arrays.asList(343, 345, 346, 348, 351),
                ref,
                "2017-11-05"));
        assertEquals(patches, v.getPatches());
    }

    @Test
    public void testParserDiffOfDiff() throws Exception {
        var patches = DiffParser.getPatchesFromUnifiedDiff(diffOfDiff);
        var exPatches = new HashSet<Patch>();
        exPatches.add(new Patch("core/src/components/toolbar/test/spec/index.html",
                Arrays.asList(1, 17, 22),
                Arrays.asList(16, 21),
                null, null));
        assertEquals(exPatches, patches);
    }
}

