/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package eu.fasten.vulnerabilityproducer.parsers;

import eu.fasten.vulnerabilityproducer.utils.Vulnerability;
import eu.fasten.vulnerabilityproducer.utils.connections.GitHelper;
import eu.fasten.vulnerabilityproducer.utils.connections.JavaHttpClient;
import eu.fasten.vulnerabilityproducer.utils.mappers.VersionRanger;
import eu.fasten.vulnerabilityproducer.utils.mappers.YAMLHandler;
import eu.fasten.vulnerabilityproducer.utils.parsers.ExtraParser;
import kotlin.Pair;
import org.apache.commons.io.FileUtils;
import org.apache.commons.lang3.builder.ToStringExclude;
import org.joda.time.DateTime;
import org.junit.jupiter.api.Test;
import org.mockito.Mockito;

import java.io.File;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.io.PrintWriter;
import java.nio.charset.StandardCharsets;
import java.util.*;
import java.util.stream.Collectors;

import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.junit.jupiter.api.Assertions.assertTrue;
import static org.mockito.Mockito.when;

public class ExtraParserTest {

    JavaHttpClient clientMock = Mockito.mock(JavaHttpClient.class);
    GitHelper gitHelperMock = Mockito.mock(GitHelper.class);
    ExtraParser extraParser = new ExtraParser(clientMock, new VersionRanger(clientMock, "./analyzer/vulnerability-plugin/src/main/resources/trackers/package_versions.json"));

    String extraCommits = "CVE-2017-4971,https://github.com/spring-projects/spring-webflow,57f2ccb66946943fbf3b3f2165eac1c8eb6b1523,pos\n" +
            "CVE-2018-1000134,https://github.com/pingidentity/ldapsdk,8471904a02438c03965d21367890276bc25fa5a6,pos";

    String mockCSV = ",authentication_required,availability_impact,cve_id," +
            "cve_page,cwe_id,access_complexity,confidentiality_impact,integrity_impact," +
            "publish_date,score,summary,update_date,vulnerability_classification,ref_link," +
            "commit_id,commit_message,files_changed,lang,project,version_after_fix,version_before_fix\n" +
            "0,Not required,Partial,CVE-2009-1194," +
            "https://www.cvedetails.com/cve/CVE-2009-1194/,CWE-189,Medium,Partial,Partial,2009-05-11,6.8," +
            "\"Description of vulnerability.\"," +
            "2018-10-10,DoS Exec Code Overflow ," +
            "https://github.com/bratsche/pango/commit/4de30e5500eaeb49f4bf0b7a07f718e149a2ed5e,4de30e5500eaeb49f4bf0b7a07f718e149a2ed5e," +
            "[glyphstring] Handle overflow with very long glyphstrings";

    String insecureJsonMock;

    {
        try {
            insecureJsonMock = FileUtils.readFileToString(new File("./src/test/resources/parsers/insecureMock.json"), StandardCharsets.UTF_8);
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    @Test
    public void testInjectExtraCommits() throws Exception {
        when(clientMock.sendGet("https://raw.githubusercontent.com/SAP/project-kb/master/MSR2019/dataset/vulas_db_msr2019_release.csv")).thenReturn(extraCommits);

        extraParser.injectMSR2019SAP();

        assertTrue(extraParser.getVulnerabilitiesInMemory().containsKey("CVE-2017-4971"));
        assertTrue(extraParser.getVulnerabilitiesInMemory().get("CVE-2017-4971").getPatchLinks().contains("https://github.com/spring-projects/spring-webflow/commit/57f2ccb66946943fbf3b3f2165eac1c8eb6b1523"));

        assertTrue(extraParser.getVulnerabilitiesInMemory().containsKey("CVE-2018-1000134"));
        assertTrue(extraParser.getVulnerabilitiesInMemory().get("CVE-2018-1000134").getPatchLinks().contains("https://github.com/pingidentity/ldapsdk/commit/8471904a02438c03965d21367890276bc25fa5a6"));
    }

    @Test
    public void testInjectFromSafetyDB() throws Exception {
        List mockVersions = Arrays.asList("0.9", "1.0", "1.1", "1.2").stream().map(x -> new Pair(x, null)).collect(Collectors.toList());
        extraParser.getVersionRanger().versionsMappings.put("pkg:pypi/mock", mockVersions);

        when(clientMock.sendGet("https://raw.githubusercontent.com/pyupio/safety-db/master/data/insecure_full.json")).thenReturn(insecureJsonMock);

        extraParser.injectFromSafetyDB();

        Vulnerability v = new Vulnerability("mock-id");
        v.setDescription("mock description");
        v.addPurl("pkg:pypi/mock@0.9");
        v.addPurl("pkg:pypi/mock@1.0");

        assertTrue(extraParser.getVulnerabilitiesInMemory().get("mock-id").equals(v));

        Vulnerability v2 = new Vulnerability("CVE-TEST-1");
        v2.setDescription("mock description 2");
        v2.addPurl("pkg:pypi/mock@0.9");
        v2.addPurl("pkg:pypi/mock@1.0");

        assertTrue(extraParser.getVulnerabilitiesInMemory().get("CVE-TEST-1").equals(v2));

        Vulnerability v3 = new Vulnerability("CVE-TEST-2");
        v3.setDescription("mock description 3");
        v3.addPurl("pkg:pypi/mock@1.1");
        v3.addPurl("pkg:pypi/mock@1.2");

        assertTrue(extraParser.getVulnerabilitiesInMemory().get("CVE-TEST-2").equals(v3));

        Vulnerability v4 = new Vulnerability("CVE-TEST-3");
        v4.setDescription("mock description 3");
        v4.addPurl("pkg:pypi/mock@1.1");
        v4.addPurl("pkg:pypi/mock@1.2");

        assertTrue(extraParser.getVulnerabilitiesInMemory().get("CVE-TEST-3").equals(v4));
    }

    @Test
    public void testInjectYAMLSource() {
        var versionsA = new ArrayList<Pair<String, DateTime>>(); Arrays.asList("2.0.0", "2.0.1.RELEASE").forEach(x -> versionsA.add(new Pair(x, null)));
        var versionsB = new ArrayList<Pair<String, DateTime>>(); Arrays.asList("0.2.2", "0.3.4").forEach(x -> versionsA.add(new Pair(x, null)));

        extraParser.getVersionRanger().versionsMappings.put("pkg:maven/org.mock/testing", versionsA);
        extraParser.getVersionRanger().versionsMappings.put("pkg:pypi/mock", versionsB);

        Vulnerability vJava = new Vulnerability("CVE-2020-0001");
        vJava.setDescription("mock java");
        vJava.addReference("ref.com");
        vJava.setScoreCVSS2(7.5);
        vJava.addPurl("pkg:maven/org.mock/testing@2.0.1.RELEASE");

        Vulnerability vPython = new Vulnerability("CVE-2020-0002");
        vPython.setDescription("mock python");
        vPython.addReference("ref2.com");
        vPython.setScoreCVSS2(6.8);
        vPython.addPurl("pkg:pypi/mock@0.2.2");

        extraParser.parseYAMLInformation("./src/test/resources/parsers/yamlSource");

        assertTrue(extraParser.getVulnerabilitiesInMemory().get("CVE-2020-0001").equals(vJava));
        assertTrue(extraParser.getVulnerabilitiesInMemory().get("CVE-2020-0002").equals(vPython));
    }

    @Test
    public void testInjectMSR2020SaveFile() throws Exception {
        when(clientMock.sendGet("https://raw.githubusercontent.com/ZeoVan/MSR_20_Code_vulnerability_CSV_Dataset/master/all_c_cpp_release2.0.csv"))
                .thenReturn(mockCSV);
        String datasetPath = "./src/test/resources/parsers/msr2020_mock.csv";
        extraParser.injectMSR2020CPP(datasetPath);
        assertTrue(extraParser.getVulnerabilitiesInMemory().get("CVE-2009-1194")
                .getPatchLinks().contains("https://github.com/bratsche/pango/commit/4de30e5500eaeb49f4bf0b7a07f718e149a2ed5e"));
        // Delete file that sits in memory
        File dataFile = new File(datasetPath);
        if (dataFile.exists()) {
            FileUtils.deleteQuietly(dataFile);
        }
    }


    @Test
    public void testInjectMSR2020FileInMemory() {
        String datasetPath = "./src/test/resources/parsers/msr2020_mock.csv";
        // Write the file to memory
        try (PrintWriter out = new PrintWriter(datasetPath)) {
            out.write(mockCSV);
        } catch (FileNotFoundException e) {
            e.printStackTrace();
        }
        // File is already in memory, so it should find it
        extraParser.injectMSR2020CPP(datasetPath);
        assertTrue(extraParser.getVulnerabilitiesInMemory().get("CVE-2009-1194")
                .getPatchLinks().contains("https://github.com/bratsche/pango/commit/4de30e5500eaeb49f4bf0b7a07f718e149a2ed5e"));
        // Delete file at the end
        File dataFile = new File(datasetPath);
        if (dataFile.exists()) {
            FileUtils.deleteQuietly(dataFile);
        }
    }

    @Test
    public void testInjectProjectKb() {
        extraParser.setGitHelper(gitHelperMock);
        // Do not clone
        var projectDir = "./src/test/resources/parsers/project-kb";
        when(gitHelperMock.cloneRepo(Mockito.anyString(), Mockito.anyString(), Mockito.anyString()))
                .thenReturn(projectDir);
        extraParser.injectSAPProjectKb("./src/test/resources/parsers/oof-cannot-find-it");
        Vulnerability v = new Vulnerability("CVE-2020-11989");
        v.addPatchLink("https://github.com/apache/shiro/commit/b90f91875e5e18c4805013c2fa0567b1700f5a96");
        v.addPurl("pkg:maven/org.apache.shiro/shiro-web@1.0.0-incubating");
        v.addPurl("pkg:maven/org.apache.shiro/shiro-web@1.5.2");
        v.setDescription("Apache Shiro before 1.5.3, when using Apache Shiro with Spring dynamic controllers, a specially crafted request may cause an authentication bypass.");

        assertTrue(extraParser.getVulnerabilitiesInMemory().containsKey("CVE-2020-11989"));
        assertEquals(extraParser.getVulnerabilitiesInMemory().get("CVE-2020-11989"), v);
    }

    @Test
    public void translateYAMLToVulnerability() {
        YAMLHandler.SAPVulnMapper yaml = new YAMLHandler.SAPVulnMapper();
        yaml.vulnerability_id = "CVE-TEST";
        var note = new YAMLHandler.NoteTextMapper();
        note.text = "text";
        yaml.notes.add(note);
        var fixes = new YAMLHandler.FixMapper();
        var commit = new YAMLHandler.CommitMapper();
        commit.repository = "https://github.com/oof/foo";
        commit.id = "7556";
        fixes.commits.add(commit);
        yaml.fixes.add(fixes);
        var artifact = new YAMLHandler.ArtifactMapper();
        artifact.id = "pkg:maven/org.apache.xmlgraphics/batik-anim@1.9.1?packaging=sources";
        artifact.affected = true;
        artifact.reason = "oof";
        yaml.artifacts.add(artifact);

        Vulnerability v = new Vulnerability("CVE-TEST");
        v.addPatchLink("https://github.com/oof/foo/commit/7556");
        v.addPurl("pkg:maven/org.apache.xmlgraphics/batik-anim@1.9.1?packaging=sources");
        v.setDescription("text");

        assertEquals(v, yaml.translateFromStatement());
    }

    @Test
    public void testGetUpdatedVulnerabilities() {
        HashMap<String, Vulnerability> oldVulns = new HashMap<>();
        HashMap<String, Vulnerability> newVulns = new HashMap<>();

        Vulnerability v1 = new Vulnerability("CVE-1");
        Vulnerability v2 = new Vulnerability("CVE-1");
        Vulnerability v3 = new Vulnerability("CVE-2");
        Vulnerability v4 = new Vulnerability("CVE-2");
        Vulnerability v5 = new Vulnerability("CVE-3");


        oldVulns.put(v1.getId(), v1);
        oldVulns.put(v4.getId(), v4);
        newVulns.put(v2.getId(), v2);
        newVulns.put(v3.getId(), v3);
        newVulns.put(v5.getId(), v5);

        var vulns = extraParser.getUpdatedVulnerabilities(oldVulns, newVulns);
        assertTrue(vulns.size() == 1);
    }

    @Test
    public void testGetRubyAdvisoryInformation() {
        extraParser.setGitHelper(gitHelperMock);
        // Do not clone
        var projectDir = "./src/test/resources/parsers/ruby-advisory-db";
        when(gitHelperMock.cloneRepo("https://github.com/rubysec/ruby-advisory-db",
                "./src/test/resources/parsers/oof-cannot-find-it/ruby-advisory-db", null))
                .thenReturn(projectDir);
        extraParser.injectRubyAdvisory("./src/test/resources/parsers/oof-cannot-find-it");
        var v = new Vulnerability("CVE-2013-2617");
        v.setDescription("Curl Gem for Ruby URI Handling Arbitrary Command Injection\n" +
                "Curl Gem for Ruby contains a flaw that is triggered during the\n" +
                "  handling of specially crafted input passed via the URL.  This may allow\n" +
                "  a context-dependent attacker to potentially execute arbitrary commands by\n" +
                "  injecting them via a semi-colon (;).");
        v.setPublishedDate("2013-03-12");
        v.setScoreCVSS2(7.5);
    }
}
