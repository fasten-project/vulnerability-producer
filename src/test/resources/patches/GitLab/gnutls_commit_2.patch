diff --git a/NEWS b/NEWS
index 53c9601d21b26109ec97ce34ca96ad84c878ce27..4dc1c24463a2a0c685bf74e1a99d6a068ba0c649 100644
--- a/NEWS
+++ b/NEWS
@@ -25,7 +25,7 @@ See the end for copying conditions.
    with an anonymous credentials structure.

 ** Provide a uniform cipher list across different protocols; the CAMELLIA ciphers
-   as well as ciphers utilizing HMAC-SHA384 have been removed from the default
+   as well as ciphers utilizing HMAC-SHA384 and SHA256 have been removed from the default
    priority strings.

 ** libgnutls: Introduced low-level function to assist applications attempting client
diff --git a/doc/cha-gtls-app.texi b/doc/cha-gtls-app.texi
index 5ecb3d738269571b060ef8e136607ded4b05d29a..c23c848d9005034b2ac925bb8db34413a9f003df 100644
--- a/doc/cha-gtls-app.texi
+++ b/doc/cha-gtls-app.texi
@@ -1350,6 +1350,10 @@ in certificates.
 will disable the encrypt-then-mac TLS extension (RFC7366). This is
 implied by the %COMPAT keyword.

+@item %FORCE_ETM @tab
+negotiate CBC ciphersuites only when both sides of the connection support
+encrypt-then-mac TLS extension (RFC7366).
+
 @item %DISABLE_SAFE_RENEGOTIATION @tab
 will completely disable safe renegotiation
 completely.  Do not use unless you know what you are doing.
diff --git a/lib/Makefile.am b/lib/Makefile.am
index 64c7110d850f82e38422c9d400e5e5b24ddc4bd0..11de0a05bf9618f3a00b0ae9ef18a46a7a392938 100644
--- a/lib/Makefile.am
+++ b/lib/Makefile.am
@@ -66,7 +66,7 @@ SRP_COBJECTS = srp.c
 PSK_COBJECTS = psk.c

 COBJECTS = range.c record.c compress.c debug.c cipher.c gthreads.h handshake-tls13.c \
-	mbuffers.c buffers.c handshake.c num.c errors.c dh.c kx.c	\
+	mbuffers.c buffers.c handshake.c num.c errors.c dh.c kx.c cipher-cbc.c \
 	priority.c hash_int.c cipher_int.c session.c db.c x509_b64.c	\
 	hello_ext.c auth.c sslv2_compat.c datum.c session_pack.c mpi.c \
 	pk.c cert-cred.c global.c constate.c anon_cred.c pkix_asn1_tab.c gnutls_asn1_tab.c	\
diff --git a/lib/algorithms/ciphersuites.c b/lib/algorithms/ciphersuites.c
index 02023ce2a960d1bc4deea28d35e9418cb12ab6f9..ac1fdf9f4131b847793ca9af0404d7e12d219e5d 100644
--- a/lib/algorithms/ciphersuites.c
+++ b/lib/algorithms/ciphersuites.c
@@ -1405,6 +1405,14 @@ const char *gnutls_cipher_suite_info(size_t idx,
 					continue; \
 			}

+#define CIPHER_CHECK(algo) \
+			if (session->internals.priorities->force_etm && !have_etm) { \
+				const cipher_entry_st *_cipher; \
+				_cipher = cipher_to_entry(algo); \
+				if (_cipher == NULL || _gnutls_cipher_type(_cipher) == CIPHER_BLOCK) \
+					continue; \
+			}
+
 #define KX_SRP_CHECKS(kx, action) \
 	if (kx == GNUTLS_KX_SRP_RSA || kx == GNUTLS_KX_SRP_DSS) { \
 		if (!_gnutls_get_cred(session, GNUTLS_CRD_SRP)) { \
@@ -1450,11 +1458,20 @@ _gnutls_figure_common_ciphersuite(gnutls_session_t session,
 	gnutls_credentials_type_t cred_type = GNUTLS_CRD_CERTIFICATE; /* default for TLS1.3 */
 	unsigned int no_cert_found = 0;
 	const gnutls_group_entry_st *sgroup = NULL;
+	gnutls_ext_priv_data_t epriv;
+	unsigned have_etm = 0;

 	if (version == NULL) {
 		return gnutls_assert_val(GNUTLS_E_NO_CIPHER_SUITES);
 	}

+	/* we figure whether etm is negotiated by checking the raw extension data
+	 * because we only set (security_params) EtM to true only after the ciphersuite is
+	 * negotiated. */
+	ret = _gnutls_hello_ext_get_priv(session, GNUTLS_EXTENSION_ETM, &epriv);
+	if (ret >= 0 && ((intptr_t)epriv) != 0)
+		have_etm = 1;
+
 	/* If we didn't receive the supported_groups extension, then
 	 * we should assume that SECP256R1 is supported; that is required
 	 * by RFC4492, probably to allow SSLv2 hellos negotiate elliptic curve
@@ -1474,6 +1491,8 @@ _gnutls_figure_common_ciphersuite(gnutls_session_t session,

 			kx = peer_clist->entry[i]->kx_algorithm;

+			CIPHER_CHECK(peer_clist->entry[i]->block_algorithm);
+
 			if (!version->tls13_sem)
 				cred_type = _gnutls_map_kx_get_cred(kx, 1);

@@ -1510,6 +1529,8 @@ _gnutls_figure_common_ciphersuite(gnutls_session_t session,
 		for (j = 0; j < session->internals.priorities->cs.size; j++) {
 			VERSION_CHECK(session->internals.priorities->cs.entry[j]);

+			CIPHER_CHECK(session->internals.priorities->cs.entry[j]->block_algorithm);
+
 			for (i = 0; i < peer_clist->size; i++) {
 				_gnutls_debug_log("checking %.2x.%.2x (%s) for compatibility\n",
 					(unsigned)peer_clist->entry[i]->id[0],
diff --git a/lib/algorithms/mac.c b/lib/algorithms/mac.c
index ba982b72fc03ca64146d1f6ec81052d625e41cff..f6f9cb3ecfbc306fd8b9848c2e13425740511109 100644
--- a/lib/algorithms/mac.c
+++ b/lib/algorithms/mac.c
@@ -59,14 +59,14 @@ static const mac_entry_st hash_algorithms[] = {
 	 .id = GNUTLS_MAC_SHA384,
 	 .output_size = 48,
 	 .key_size = 48,
-	 .block_size = 64},
+	 .block_size = 128},
 	{.name = "SHA512",
 	 .oid = HASH_OID_SHA512,
 	 .mac_oid = MAC_OID_SHA512,
 	 .id = GNUTLS_MAC_SHA512,
 	 .output_size = 64,
 	 .key_size = 64,
-	 .block_size = 64},
+	 .block_size = 128},
 	{.name = "SHA224",
 	 .oid = HASH_OID_SHA224,
 	 .mac_oid = MAC_OID_SHA224,
diff --git a/lib/cipher-cbc.c b/lib/cipher-cbc.c
new file mode 100644
index 0000000000000000000000000000000000000000..22b9390596db495d439799c1d0fd92d8be565ddc
--- /dev/null
+++ b/lib/cipher-cbc.c
@@ -0,0 +1,161 @@
+/*
+ * Copyright (C) 2000-2013 Free Software Foundation, Inc.
+ * Copyright (C) 2013 Nikos Mavrogiannopoulos
+ * Copyright (C) 2017-2018 Red Hat, Inc.
+ *
+ * Author: Nikos Mavrogiannopoulos
+ *
+ * This file is part of GnuTLS.
+ *
+ * The GnuTLS is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public License
+ * as published by the Free Software Foundation; either version 2.1 of
+ * the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>
+ *
+ */
+
+#include "gnutls_int.h"
+#include "cipher.h"
+
+static void dummy_wait(record_parameters_st *params,
+		       const uint8_t *data, size_t data_size,
+		       unsigned int mac_data, unsigned int max_mac_data)
+{
+	/* this hack is only needed on CBC ciphers when Encrypt-then-MAC mode
+	 * is not supported by the peer. */
+	unsigned v;
+	unsigned int tag_size =
+	    _gnutls_auth_cipher_tag_len(&params->read.ctx.tls12);
+	unsigned hash_block = _gnutls_mac_block_size(params->mac);
+
+	/* force additional hash compression function evaluations to prevent timing
+	 * attacks that distinguish between wrong-mac + correct pad, from wrong-mac + incorrect pad.
+	 */
+
+	if (params->mac && params->mac->id == GNUTLS_MAC_SHA384)
+		/* v = 1 for the hash function padding + 16 for message length */
+		v = 17;
+	else /* v = 1 for the hash function padding + 8 for message length */
+		v = 9;
+
+	if (hash_block > 0) {
+		int max_blocks = (max_mac_data+v+hash_block-1)/hash_block;
+		int hashed_blocks = (mac_data+v+hash_block-1)/hash_block;
+		unsigned to_hash;
+
+		max_blocks -= hashed_blocks;
+		if (max_blocks < 1)
+			return;
+
+		to_hash = max_blocks * hash_block;
+		if ((unsigned)to_hash+1+tag_size < data_size) {
+			_gnutls_auth_cipher_add_auth
+				    (&params->read.ctx.tls12,
+				     data+data_size-tag_size-to_hash-1,
+				     to_hash);
+		}
+	}
+}
+
+/* Verifies the CBC HMAC. That's a special case as it tries to avoid
+ * any leaks which could make CBC ciphersuites without EtM usable as an
+ * oracle to attacks.
+ */
+int cbc_mac_verify(gnutls_session_t session, record_parameters_st *params,
+		   uint8_t preamble[MAX_PREAMBLE_SIZE],
+		   content_type_t type,
+		   gnutls_uint64 *sequence,
+		   const uint8_t *data, size_t data_size,
+		   size_t tag_size)
+{
+	int ret;
+	const version_entry_st *ver = get_version(session);
+	unsigned int tmp_pad_failed = 0;
+	unsigned int pad_failed = 0;
+	unsigned int pad, i, length;
+	const uint8_t *tag_ptr = NULL;
+	unsigned preamble_size;
+	uint8_t tag[MAX_HASH_SIZE];
+	unsigned blocksize = _gnutls_cipher_get_block_size(params->cipher);
+
+	pad = data[data_size - 1];	/* pad */
+
+	/* Check the pading bytes (TLS 1.x).
+	 * Note that we access all 256 bytes of ciphertext for padding check
+	 * because there is a timing channel in that memory access (in certain CPUs).
+	 */
+#ifdef ENABLE_SSL3
+	if (ver->id == GNUTLS_SSL3) {
+		if (pad >= blocksize)
+			pad_failed = 1;
+	} else
+#endif
+	{
+		for (i = 2; i <= MIN(256, data_size); i++) {
+			tmp_pad_failed |=
+			    (data[data_size - i] != pad);
+			pad_failed |=
+			    ((i <= (1 + pad)) & (tmp_pad_failed));
+		}
+	}
+
+	if (unlikely
+	    (pad_failed != 0
+	     || (1 + pad > ((int) data_size - tag_size)))) {
+		/* We do not fail here. We check below for the
+		 * the pad_failed. If zero means success.
+		 */
+		pad_failed = 1;
+		pad = 0;
+	}
+
+	length = data_size - tag_size - pad - 1;
+	tag_ptr = &data[length];
+
+	/* Pass the type, version, length and plain through
+	 * MAC.
+	 */
+	preamble_size =
+	    _gnutls_make_preamble(UINT64DATA(*sequence), type,
+				  length, ver, preamble);
+
+	ret =
+	    _gnutls_auth_cipher_add_auth(&params->read.
+					 ctx.tls12, preamble,
+					 preamble_size);
+	if (unlikely(ret < 0))
+		return gnutls_assert_val(ret);
+
+	ret =
+	    _gnutls_auth_cipher_add_auth(&params->read.
+					 ctx.tls12,
+					 data, length);
+	if (unlikely(ret < 0))
+		return gnutls_assert_val(ret);
+
+	ret =
+	    _gnutls_auth_cipher_tag(&params->read.ctx.tls12, tag,
+				    tag_size);
+	if (unlikely(ret < 0))
+		return gnutls_assert_val(ret);
+
+	if (unlikely
+	    (gnutls_memcmp(tag, tag_ptr, tag_size) != 0 || pad_failed != 0)) {
+		/* HMAC was not the same. */
+		dummy_wait(params, data, data_size,
+			   length + preamble_size,
+			   preamble_size + data_size - tag_size - 1);
+
+		return gnutls_assert_val(GNUTLS_E_DECRYPTION_FAILED);
+	}
+
+	return length;
+}
diff --git a/lib/cipher.c b/lib/cipher.c
index a2215bc1eee6f0ae1dd6cf8a23bc98c28f5fc9cb..c8bdeb542807cd419c801c21b42b0b2a19461751 100644
--- a/lib/cipher.c
+++ b/lib/cipher.c
@@ -209,14 +209,12 @@ calc_enc_length_stream(gnutls_session_t session, int data_size,
 	return length;
 }

-#define MAX_PREAMBLE_SIZE 16
-
 /* generates the authentication data (data to be hashed only
  * and are not to be sent). Returns their size.
  */
-static inline int
-make_preamble(uint8_t * uint64_data, uint8_t type, unsigned int length,
-	      const version_entry_st * ver, uint8_t * preamble)
+int
+_gnutls_make_preamble(uint8_t * uint64_data, uint8_t type, unsigned int length,
+		      const version_entry_st * ver, uint8_t preamble[MAX_PREAMBLE_SIZE])
 {
 	uint8_t *p = preamble;
 	uint16_t c_length;
@@ -372,8 +370,8 @@ encrypt_packet(gnutls_session_t session,
 		ret = plain->size;

 	preamble_size =
-	    make_preamble(UINT64DATA(params->write.sequence_number),
-			  type, ret, ver, preamble);
+	    _gnutls_make_preamble(UINT64DATA(params->write.sequence_number),
+				  type, ret, ver, preamble);

 	if (algo_type == CIPHER_BLOCK || algo_type == CIPHER_STREAM) {
 		/* add the authenticated data */
@@ -495,41 +493,6 @@ encrypt_packet_tls13(gnutls_session_t session,
 	return cipher_size;
 }

-static void dummy_wait(record_parameters_st * params,
-		       gnutls_datum_t * plaintext, unsigned pad_failed,
-		       unsigned int pad, unsigned total)
-{
-	/* this hack is only needed on CBC ciphers */
-	if (_gnutls_cipher_type(params->cipher) == CIPHER_BLOCK) {
-		unsigned len;
-
-		/* force an additional hash compression function evaluation to prevent timing
-		 * attacks that distinguish between wrong-mac + correct pad, from wrong-mac + incorrect pad.
-		 */
-		if (pad_failed == 0 && pad > 0) {
-			len = _gnutls_mac_block_size(params->mac);
-			if (len > 0) {
-				/* This is really specific to the current hash functions.
-				 * It should be removed once a protocol fix is in place.
-				 */
-				if ((pad + total) % len > len - 9
-				    && total % len <= len - 9) {
-					if (len < plaintext->size)
-						_gnutls_auth_cipher_add_auth
-						    (&params->read.
-						     ctx.tls12,
-						     plaintext->data, len);
-					else
-						_gnutls_auth_cipher_add_auth
-						    (&params->read.
-						     ctx.tls12,
-						     plaintext->data,
-						     plaintext->size);
-				}
-			}
-		}
-	}
-}

 /* Deciphers the ciphertext packet, and puts the result to plain.
  * Returns the actual plaintext packet size.
@@ -544,12 +507,10 @@ decrypt_packet(gnutls_session_t session,
 	uint8_t tag[MAX_HASH_SIZE];
 	uint8_t nonce[MAX_CIPHER_IV_SIZE];
 	const uint8_t *tag_ptr = NULL;
-	unsigned int pad = 0, i;
+	unsigned int pad = 0;
 	int length, length_to_decrypt;
 	uint16_t blocksize;
 	int ret;
-	unsigned int tmp_pad_failed = 0;
-	unsigned int pad_failed = 0;
 	uint8_t preamble[MAX_PREAMBLE_SIZE];
 	unsigned int preamble_size = 0;
 	const version_entry_st *ver = get_version(session);
@@ -575,9 +536,9 @@ decrypt_packet(gnutls_session_t session,
 		if (unlikely(ciphertext->size < tag_size))
 			return gnutls_assert_val(GNUTLS_E_UNEXPECTED_PACKET_LENGTH);

-		preamble_size = make_preamble(UINT64DATA(*sequence),
-					type, ciphertext->size-tag_size,
-					ver, preamble);
+		preamble_size = _gnutls_make_preamble(UINT64DATA(*sequence),
+						      type, ciphertext->size-tag_size,
+						      ver, preamble);

 		ret = _gnutls_auth_cipher_add_auth(&params->read.
 						   ctx.tls12, preamble,
@@ -651,8 +612,8 @@ decrypt_packet(gnutls_session_t session,
 		 * MAC.
 		 */
 		preamble_size =
-		    make_preamble(UINT64DATA(*sequence), type,
-				  length, ver, preamble);
+		    _gnutls_make_preamble(UINT64DATA(*sequence), type,
+					  length, ver, preamble);


 		if (unlikely
@@ -691,8 +652,8 @@ decrypt_packet(gnutls_session_t session,
 		 * MAC.
 		 */
 		preamble_size =
-		    make_preamble(UINT64DATA(*sequence), type,
-				  length, ver, preamble);
+		    _gnutls_make_preamble(UINT64DATA(*sequence), type,
+					  length, ver, preamble);

 		ret =
 		    _gnutls_auth_cipher_add_auth(&params->read.
@@ -722,6 +683,17 @@ decrypt_packet(gnutls_session_t session,
 		if (unlikely(ret < 0))
 			return gnutls_assert_val(ret);

+		ret =
+		    _gnutls_auth_cipher_tag(&params->read.ctx.tls12, tag,
+					    tag_size);
+		if (unlikely(ret < 0))
+			return gnutls_assert_val(ret);
+
+		if (unlikely
+		    (gnutls_memcmp(tag, tag_ptr, tag_size) != 0)) {
+			return gnutls_assert_val(GNUTLS_E_DECRYPTION_FAILED);
+		}
+
 		break;
 	case CIPHER_BLOCK:
 		if (unlikely(ciphertext->size < blocksize))
@@ -773,56 +745,13 @@ decrypt_packet(gnutls_session_t session,
 			if (unlikely(ret < 0))
 				return gnutls_assert_val(ret);

-			pad = plain->data[ciphertext->size - 1];	/* pad */
-
-			/* Check the pading bytes (TLS 1.x).
-			 * Note that we access all 256 bytes of ciphertext for padding check
-			 * because there is a timing channel in that memory access (in certain CPUs).
-			 */
-#ifdef ENABLE_SSL3
-			if (ver->id != GNUTLS_SSL3)
-#endif
-				for (i = 2; i <= MIN(256, ciphertext->size); i++) {
-					tmp_pad_failed |=
-					    (plain->
-					     data[ciphertext->size - i] != pad);
-					pad_failed |=
-					    ((i <= (1 + pad)) & (tmp_pad_failed));
-				}
-
-			if (unlikely
-			    (pad_failed != 0
-			     || (1 + pad > ((int) ciphertext->size - tag_size)))) {
-				/* We do not fail here. We check below for the
-				 * the pad_failed. If zero means success.
-				 */
-				pad_failed = 1;
-				pad = 0;
-			}
-
-			length = ciphertext->size - tag_size - pad - 1;
-			tag_ptr = &plain->data[length];
-
-			/* Pass the type, version, length and plain through
-			 * MAC.
-			 */
-			preamble_size =
-			    make_preamble(UINT64DATA(*sequence), type,
-					  length, ver, preamble);
-
-			ret =
-			    _gnutls_auth_cipher_add_auth(&params->read.
-							 ctx.tls12, preamble,
-							 preamble_size);
+			ret = cbc_mac_verify(session, params, preamble, type,
+					     sequence, plain->data, ciphertext->size,
+					     tag_size);
 			if (unlikely(ret < 0))
 				return gnutls_assert_val(ret);

-			ret =
-			    _gnutls_auth_cipher_add_auth(&params->read.
-							 ctx.tls12,
-							 plain->data, length);
-			if (unlikely(ret < 0))
-				return gnutls_assert_val(ret);
+			length = ret;
 		} else { /* EtM */
 			ret =
 			    _gnutls_cipher_decrypt2(&params->read.ctx.tls12.
@@ -844,29 +773,6 @@ decrypt_packet(gnutls_session_t session,
 		return gnutls_assert_val(GNUTLS_E_DECRYPTION_FAILED);
 	}

-	/* STREAM or BLOCK arrive here */
-	if (etm == 0) {
-		ret =
-		    _gnutls_auth_cipher_tag(&params->read.ctx.tls12, tag,
-					    tag_size);
-		if (unlikely(ret < 0))
-			return gnutls_assert_val(ret);
-
-		/* Here there could be a timing leakage in CBC ciphersuites that
-		 * could be exploited if the cost of a successful memcmp is high.
-		 * A constant time memcmp would help there, but it is not easy to maintain
-		 * against compiler optimizations. Currently we rely on the fact that
-		 * a memcmp comparison is negligible over the crypto operations.
-		 */
-		if (unlikely
-		    (gnutls_memcmp(tag, tag_ptr, tag_size) != 0 || pad_failed != 0)) {
-			/* HMAC was not the same. */
-			dummy_wait(params, plain, pad_failed, pad,
-				   length + preamble_size);
-
-			return gnutls_assert_val(GNUTLS_E_DECRYPTION_FAILED);
-		}
-	}

 	return length;
 }
diff --git a/lib/cipher.h b/lib/cipher.h
index 0d7c74adaf8f12e9ac28d3c6cf87c4780f4f0289..3cebaa1cbb83dff24d1e8cfa403849b5aa992ee7 100644
--- a/lib/cipher.h
+++ b/lib/cipher.h
@@ -30,3 +30,16 @@ int _gnutls_decrypt(gnutls_session_t session,
 		    gnutls_datum_t * ciphertext, gnutls_datum_t * output,
 		    content_type_t *type, record_parameters_st * params,
 		    gnutls_uint64 * sequence);
+
+#define MAX_PREAMBLE_SIZE 16
+
+int
+_gnutls_make_preamble(uint8_t * uint64_data, uint8_t type, unsigned int length,
+		      const version_entry_st * ver, uint8_t preamble[MAX_PREAMBLE_SIZE]);
+
+int cbc_mac_verify(gnutls_session_t session, record_parameters_st *params,
+		   uint8_t preamble[MAX_PREAMBLE_SIZE],
+		   content_type_t type,
+		   gnutls_uint64 *sequence,
+		   const uint8_t *data, size_t data_size,
+		   size_t tag_size);
diff --git a/lib/gnutls_int.h b/lib/gnutls_int.h
index 320c394d18cf1cd613e5196d3fa8454eecc37e42..0db05af163d6c610e51260ad8541609b4e56274c 100644
--- a/lib/gnutls_int.h
+++ b/lib/gnutls_int.h
@@ -900,6 +900,7 @@ struct gnutls_priority_st {
 	bool no_tickets;
 	bool have_cbc;
 	bool have_psk;
+	bool force_etm;
 	unsigned int additional_verify_flags;

 	/* TLS_FALLBACK_SCSV */
diff --git a/lib/handshake.c b/lib/handshake.c
index 30e229f3d05ff806e18cd466682c925ee85b5d01..278769e2f853d8affeefbfef33116078966a6cf5 100644
--- a/lib/handshake.c
+++ b/lib/handshake.c
@@ -1825,7 +1825,6 @@ read_server_hello(gnutls_session_t session,
 	 */
 	if (!vers->tls13_sem &&
 	    client_check_if_resuming(session, session_id, session_id_len) == 0) {
-
 		ret =
 		    _gnutls_parse_hello_extensions(session, GNUTLS_EXT_FLAG_TLS12_SERVER_HELLO,
 						   GNUTLS_EXT_MANDATORY,
@@ -1878,6 +1877,14 @@ read_server_hello(gnutls_session_t session,
 	if (ret < 0)
 		return gnutls_assert_val(ret);

+	/* check if EtM is required */
+	if (!vers->tls13_sem && session->internals.priorities->force_etm && !session->security_parameters.etm) {
+		const cipher_entry_st *cipher = cipher_to_entry(session->security_parameters.cs->block_algorithm);
+		if (_gnutls_cipher_type(cipher) == CIPHER_BLOCK)
+			return gnutls_assert_val(GNUTLS_E_UNWANTED_ALGORITHM);
+	}
+
+
 	ret =
 	    _gnutls_parse_hello_extensions(session,
 					   ext_parse_flag,
diff --git a/lib/priority.c b/lib/priority.c
index 0dc39f362c43f9456411b5622d79311e48ac8fb4..a7496785802a3b0c0e9404d5f9407a30111ca714 100644
--- a/lib/priority.c
+++ b/lib/priority.c
@@ -455,14 +455,12 @@ static const int* sign_priority_secure192 = _sign_priority_secure192;

 static const int mac_priority_normal_default[] = {
 	GNUTLS_MAC_SHA1,
-	GNUTLS_MAC_SHA256,
 	GNUTLS_MAC_AEAD,
 	0
 };

 static const int mac_priority_normal_fips[] = {
 	GNUTLS_MAC_SHA1,
-	GNUTLS_MAC_SHA256,
 	GNUTLS_MAC_AEAD,
 	0
 };
@@ -496,14 +494,12 @@ static const int* mac_priority_suiteb = _mac_priority_suiteb;

 static const int _mac_priority_secure128[] = {
 	GNUTLS_MAC_SHA1,
-	GNUTLS_MAC_SHA256,
 	GNUTLS_MAC_AEAD,
 	0
 };
 static const int* mac_priority_secure128 = _mac_priority_secure128;

 static const int _mac_priority_secure192[] = {
-	GNUTLS_MAC_SHA256,
 	GNUTLS_MAC_AEAD,
 	0
 };
@@ -813,6 +809,10 @@ static void enable_no_etm(gnutls_priority_t c)
 {
 	c->_no_etm = 1;
 }
+static void enable_force_etm(gnutls_priority_t c)
+{
+	c->force_etm = 1;
+}
 static void enable_no_tickets(gnutls_priority_t c)
 {
 	c->no_tickets = 1;
diff --git a/lib/priority_options.gperf b/lib/priority_options.gperf
index 44968d432710eb0a367be578588d5d715e7a849a..a955ec85e6ba517c73112555fbdcd7173fd9ac1d 100644
--- a/lib/priority_options.gperf
+++ b/lib/priority_options.gperf
@@ -10,6 +10,7 @@ DUMBFW, enable_dumbfw
 NO_EXTENSIONS, enable_no_extensions
 NO_TICKETS, enable_no_tickets
 NO_ETM, enable_no_etm
+FORCE_ETM, enable_force_etm
 NO_SESSION_HASH, enable_no_ext_master_secret
 STATELESS_COMPRESSION, dummy_func
 VERIFY_ALLOW_BROKEN, enable_verify_allow_broken
diff --git a/tests/Makefile.am b/tests/Makefile.am
index e095e36cbceb637cdabd2ed86878b01d9f015f1d..9f4b053e43f0d6b1d9ca83d50299b3d7bbc8117b 100644
--- a/tests/Makefile.am
+++ b/tests/Makefile.am
@@ -153,7 +153,7 @@ ctests += mini-record-2 simple gnutls_hmac_fast set_pkcs12_cred cert certuniquei
 	 pubkey-import-export sign-is-secure spki spki-abstract rsa-rsa-pss \
 	 mini-dtls-fork mini-dtls-pthread mini-key-material x509cert-invalid \
 	 tls-ext-register tls-supplemental mini-dtls0-9 duplicate-extensions \
-	 record-retvals mini-server-name tls-etm x509-cert-callback alerts \
+	 record-retvals mini-server-name tls-etm tls-force-etm x509-cert-callback alerts \
 	 client-sign-md5-rep tls12-invalid-key-exchanges session-rdn-read \
 	 tls13-cert-key-exchange x509-cert-callback-ocsp gnutls_ocsp_resp_list_import2 \
 	 server-sign-md5-rep privkey-keygen mini-tls-nonblock no-signal pkcs7-gen dtls-etm \
diff --git a/tests/dtls1-2-mtu-check.c b/tests/dtls1-2-mtu-check.c
index 707fa32e377eb63f7e5f018f07b4fde3289c1f21..460aa9442b8452c3050fd81ca5cbd851ede512d4 100644
--- a/tests/dtls1-2-mtu-check.c
+++ b/tests/dtls1-2-mtu-check.c
@@ -79,7 +79,7 @@ static void dtls_mtu_try(const char *name, const char *client_prio,
 				serverx509cred);

 	assert(gnutls_priority_set_direct(server,
-				   "NORMAL:+ANON-ECDH:+ANON-DH:+3DES-CBC:+ECDHE-RSA:+DHE-RSA:+RSA:+ECDHE-ECDSA:+CURVE-X25519",
+				   "NORMAL:+ANON-ECDH:+ANON-DH:+3DES-CBC:+ECDHE-RSA:+DHE-RSA:+RSA:+ECDHE-ECDSA:+SHA256:+CURVE-X25519",
 				   NULL) >= 0);
 	gnutls_transport_set_push_function(server, server_push);
 	gnutls_transport_set_pull_function(server, server_pull);
diff --git a/tests/priorities.c b/tests/priorities.c
index 1f85d7966f8333d9195feafb17996b9811e7123d..3cbde6e5669c1022f1546f9935032fb544072e7f 100644
--- a/tests/priorities.c
+++ b/tests/priorities.c
@@ -113,19 +113,19 @@ try_prio_err(const char *prio, int err)

 void doit(void)
 {
-	const int null = 4;
-	int sec128_cs = 31;
-	int sec256_cs = 12;
-	int normal_cs = 31;
+	const int null = 3;
+	int sec128_cs = 25;
+	int sec256_cs = 10;
+	int normal_cs = 25;
 	int normal_ciphers = 7;
-	int pfs_cs = 23;
+	int pfs_cs = 19;

 	if (gnutls_fips140_mode_enabled()) {
-		normal_cs = 28;
+		normal_cs = 22;
 		normal_ciphers = 6;
 		pfs_cs = 22;
-		sec256_cs = 9;
-		sec128_cs = 28;
+		sec256_cs = 7;
+		sec128_cs = 22;
 	}

 	try_prio("NORMAL", normal_cs, normal_ciphers, __LINE__);
@@ -136,7 +136,7 @@ void doit(void)
 		try_prio("NORMAL:+CIPHER-ALL", normal_cs, 7, __LINE__);	/* all (except null) */
 		try_prio("NORMAL:-CIPHER-ALL:+NULL", null, 1, __LINE__);	/* null */
 		try_prio("NORMAL:-CIPHER-ALL:+NULL:+CIPHER-ALL", normal_cs + null, 8, __LINE__);	/* should be null + all */
-		try_prio("NORMAL:-CIPHER-ALL:+NULL:+CIPHER-ALL:-CIPHER-ALL:+AES-128-CBC", 8, 1, __LINE__);	/* should be null + all */
+		try_prio("NORMAL:-CIPHER-ALL:+NULL:+CIPHER-ALL:-CIPHER-ALL:+AES-128-CBC", 4, 1, __LINE__);	/* should be null + all */
 	}

 	try_prio("PERFORMANCE", normal_cs, normal_ciphers, __LINE__);
diff --git a/tests/suite/Makefile.am b/tests/suite/Makefile.am
index 02c75c36108108faad4a5d8385e1164951588eda..81036c75909d9f1f8a647a8db65474ccc693801f 100644
--- a/tests/suite/Makefile.am
+++ b/tests/suite/Makefile.am
@@ -31,7 +31,7 @@ AM_CPPFLAGS = \
 	-I$(top_srcdir)/tests/suite/ecore/src/include \
 	-I$(top_srcdir)/tests/suite/ecore/src/lib

-EXTRA_DIST =
+EXTRA_DIST = cbc-record-check.sh

 check_PROGRAMS = rng prime-check
 AM_LDFLAGS = -no-install
diff --git a/tests/suite/cbc-record-check.sh b/tests/suite/cbc-record-check.sh
new file mode 100755
index 0000000000000000000000000000000000000000..453c29993b92b7082785fba68aec36cf46e5b37d
--- /dev/null
+++ b/tests/suite/cbc-record-check.sh
@@ -0,0 +1,81 @@
+#!/bin/bash
+
+ecode=0
+
+FAILED=""
+
+if test -z "${OPTIONS}";then
+OPTIONS="sha1 sha256 sha384 sha256-new sha1-one"
+fi
+
+echo "Running for: $OPTIONS"
+
+TIME=ns
+
+function plot()
+{
+	hash=$1
+	R --no-save <<_EOF_
+#plot
+require(lattice)
+
+z=read.csv("out-$hash.txt", header=TRUE);
+
+options(scipen=999)
+
+m <- matrix(ncol=3,nrow=256)
+
+png(filename = "$hash-density.png",width=3072,height=4096,units="px",bg="white");
+d <- density(unlist(z[1,]));
+plot(d, ylab="Delta", xlab="${TIME}", col="red", main=sprintf("estimated PDF for %d", 1));
+for (row in c(4,72,253,256)){
+  lines(density(unlist(z[row,])), col = sample(colours(), 5));
+}
+dev.off();
+
+colnames(m) <- c("Delta","TimeMedian","TimeAverage")
+for (row in 1:256){
+  v=tail(z[row,], length(z[row,])-1)
+  m[row,][1] = unlist(z[row,][1]);
+  m[row,][2] = median(unlist(v));
+  m[row,][3] = mean(unlist(v));
+}
+
+png(filename = "$hash-timings-med.png",width=1024,height=1024,units="px",bg="white");
+plot(m[,1],m[,2],xlab="Delta",ylab="Median timings (${TIME})");
+dev.off();
+
+png(filename = "$hash-timings-ave.png",width=1024,height=1024,units="px",bg="white");
+plot(m[,1],m[,3],xlab="Delta",ylab="Average timings (${TIME})");
+dev.off();
+
+estatus=0;
+for (row in 2:256){
+  v=ks.test(unlist(z[1,]),unlist(z[row,]));
+  p = 0.05/255
+  if (v[2] < p) {
+    print (row);
+    print (v[2]);
+    estatus=1;
+  }
+}
+q(status=estatus);
+_EOF_
+
+if test $? != 0;then
+	echo "*** Failed test for $hash"
+	FAILED="${FAILED} $hash"
+	ecode=1
+fi
+}
+
+for hash in ${OPTIONS};do
+	if ! test -f out-$hash.txt;then
+		./mini-record-timing $hash
+	fi
+	plot $hash
+done
+
+echo "Failed: ${FAILED}"
+
+exit $ecode
diff --git a/tests/suite/mini-record-timing.c b/tests/suite/mini-record-timing.c
index 712386178d0910ffeed09d6ff58978030c34c3e2..b08d36434c61e8004ea77518a15fa2d93cd643cf 100644
--- a/tests/suite/mini-record-timing.c
+++ b/tests/suite/mini-record-timing.c
@@ -47,11 +47,16 @@ int main()
 #include <signal.h>
 #include <assert.h>
 #include <errno.h>
-#include "../utils.h"
+
+//#define USE_RDTSC
+//#define TEST_ETM

 #include <time.h>
 #include <sys/time.h>
 #include <sys/resource.h>
+#ifdef USE_RDTSC
+#include <x86intrin.h>
+#endif

 #ifdef DEBUG
 static void server_log_func(int level, const char *str)
@@ -65,53 +70,28 @@ static void client_log_func(int level, const char *str)
 }
 #endif

-#undef REHANDSHAKE
-
-/* This program tests the robustness of record
- * decoding.
- */
-
-static unsigned char server_cert_pem[] =
-    "-----BEGIN CERTIFICATE-----\n"
-    "MIIBeTCCASWgAwIBAgIBBzANBgkqhkiG9w0BAQsFADAPMQ0wCwYDVQQDEwROb25l\n"
-    "MCIYDzIwMTMwMTE5MTA0MDAwWhgPMjA0MDA2MDUxMDQwMDBaMA8xDTALBgNVBAMT\n"
-    "BE5vbmUwWTANBgkqhkiG9w0BAQEFAANIADBFAj4Bh52/b3FNXDdICg1Obqu9ivW+\n"
-    "PGJ89mNsX3O9S/aclnx5Ozw9MC1UJuZ2UEHl27YVmm4xG/y3nKUNevZjKwIDAQAB\n"
-    "o2swaTAMBgNVHRMBAf8EAjAAMBQGA1UdEQQNMAuCCWxvY2FsaG9zdDATBgNVHSUE\n"
-    "DDAKBggrBgEFBQcDATAPBgNVHQ8BAf8EBQMDB6AAMB0GA1UdDgQWBBRhEgmVCi6c\n"
-    "hhRQvMzfEXqLKTRxcTANBgkqhkiG9w0BAQsFAAM/AADMi31wr0Tp2SJUCuQjFVCb\n"
-    "JDleomTayOWVS/afCyAUxYjqFfUFSZ8sYN3zAgnXt5DYO3VclIlax4n6iXOg\n"
-    "-----END CERTIFICATE-----\n";
-
-const gnutls_datum_t server_cert = { server_cert_pem,
-	sizeof(server_cert_pem)
-};
-
-static unsigned char server_key_pem[] =
-    "-----BEGIN RSA PRIVATE KEY-----\n"
-    "MIIBLAIBAAI+AYedv29xTVw3SAoNTm6rvYr1vjxifPZjbF9zvUv2nJZ8eTs8PTAt\n"
-    "VCbmdlBB5du2FZpuMRv8t5ylDXr2YysCAwEAAQI9EPt8Q77sFeWn0BfHoPD9pTsG\n"
-    "5uN2e9DP8Eu6l8K4AcOuEsEkqZzvxgqZPA68pw8BZ5xKINMFdRPHmrX/cQIfHsdq\n"
-    "aMDYR/moqgj8MbupqOr/48iorTk/D//2lgAMnwIfDLk3UWGvPiv6fNTlEnTgVn6o\n"
-    "TdL0mvpkixebQ5RR9QIfHDjkRGtXph+xXUBh50RZXE8nFfl/WV7diVE+DOq8pwIf\n"
-    "BxdOwjdsAH1oLBxG0sN6qBoM2NrCYoE8edydNsu55QIfEWsrlJnO/t0GzHy7qWdV\n"
-    "zi9JMPu9MTDhOGmqPQO7Xw==\n" "-----END RSA PRIVATE KEY-----\n";


-const gnutls_datum_t server_key = { server_key_pem,
-	sizeof(server_key_pem)
-};
+#ifndef _POSIX_TIMERS
+#error need posix timers
+#endif

+#define CLOCK_TO_USE CLOCK_MONOTONIC
+//#define CLOCK_TO_USE CLOCK_MONOTONIC_RAW
+//#define CLOCK_TO_USE CLOCK_PROCESS_CPUTIME_ID

-#define MAX_PER_POINT (684*1024)
-#define MAX_MEASUREMENTS(np) (MAX_PER_POINT*(np))
+/* This program tests the robustness of record
+ * decoding.
+ */
+#define MAX_PER_POINT (8*1024)
+#define WARM_UP (2)
 #define MAX_BUF 1024

 struct point_st {
 	unsigned char byte1;
 	unsigned char byte2;
 	unsigned midx;
-	unsigned long *measurements;
+	unsigned taken;
 	unsigned long *smeasurements;
 };

@@ -122,6 +102,7 @@ struct test_st {
 	const char *file;
 	const char *name;
 	unsigned text_size;
+	uint8_t fill;
 };

 struct point_st *prev_point_ptr = NULL;
@@ -145,113 +126,37 @@ push_crippled(gnutls_transport_ptr_t tr, const void *_data, size_t len)
 	unsigned p_size;
 	struct test_st *test = gnutls_session_get_ptr(cli_session);

-	p = &test->points[point_idx];
 	p_size = test->npoints;

-	memcpy(&data[len - 32], data + 5, 32);
+	if (point_idx >= p_size)
+		abort();

-/*fprintf(stderr, "sending: %d: %d\n", (unsigned)p->byte1, (int)len);*/
-	data[len - 17] ^= p->byte1;
-	data[len - 18] ^= p->byte2;
+	p = &test->points[point_idx];

-	prev_point_ptr = p;
-	point_idx++;
-	if (point_idx >= p_size)
-		point_idx = 0;
+
+	if (test->fill != 0xff) {
+		/* original lucky13 attack */
+		memmove(&data[len - 32], data + 5, 32);
+		data[len - 17] ^= p->byte1;
+		data[len - 18] ^= p->byte2;
+	} else {
+		/* a revised attack which depends on chosen-plaintext */
+		assert(len>512);
+		memmove(data+len-256-32, data+5, 256+32);
+		data[len - 257] ^= p->byte1;
+	}

 	return send(fd, data, len, 0);
 }


+#ifndef USE_RDTSC
 static unsigned long timespec_sub_ns(struct timespec *a,
 				     struct timespec *b)
 {
 	return (a->tv_sec * 1000 * 1000 * 1000 + a->tv_nsec -
 		(b->tv_sec * 1000 * 1000 * 1000 + b->tv_nsec));
 }
-
-static
-double calc_avg(unsigned long *diffs, unsigned int diffs_size)
-{
-	double avg = 0;
-	unsigned int i;
-	unsigned int start = diffs_size / 20;
-	unsigned int stop = diffs_size - diffs_size / 20;
-
-	for (i = start; i < stop; i++)
-		avg += diffs[i];
-
-	avg /= (stop - start);
-
-	return avg;
-}
-
-static int compar(const void *_a, const void *_b)
-{
-	unsigned long a, b;
-
-	a = *((unsigned long *) _a);
-	b = *((unsigned long *) _b);
-
-	if (a < b)
-		return -1;
-	else if (a == b)
-		return 0;
-	else
-		return 1;
-}
-
-static
-double calc_median(unsigned long *diffs, unsigned int diffs_size)
-{
-	double med;
-
-	if (diffs_size % 2 == 1)
-		med = diffs[diffs_size / 2];
-	else {
-		med = diffs[diffs_size / 2] + diffs[(diffs_size - 1) / 2];
-		med /= 2;
-	}
-
-	return med;
-}
-
-#if 0
-static
-unsigned long calc_min(unsigned long *diffs, unsigned int diffs_size)
-{
-	unsigned long min = 0, i;
-	unsigned int start = diffs_size / 20;
-	unsigned int stop = diffs_size - diffs_size / 20;
-
-
-	for (i = start; i < stop; i++) {
-		if (min == 0)
-			min = diffs[i];
-		else if (diffs[i] < min)
-			min = diffs[i];
-	}
-	return min;
-}
-
-static
-double calc_var(unsigned long *diffs, unsigned int diffs_size, double avg)
-{
-	double sum = 0, d;
-	unsigned int i;
-	unsigned int start = diffs_size / 20;
-	unsigned int stop = diffs_size - diffs_size / 20;
-
-	for (i = start; i < stop; i++) {
-		d = ((double) diffs[i] - avg);
-		d *= d;
-
-		sum += d;
-	}
-	sum /= diffs_size - 1;
-
-	return sum;
-}
 #endif

 static void
@@ -261,33 +166,31 @@ client(int fd, const char *prio, unsigned int text_size,
 	int ret;
 	char buffer[MAX_BUF + 1];
 	char text[text_size];
-	gnutls_certificate_credentials_t x509_cred;
+	gnutls_psk_client_credentials_t pskcred;
 	gnutls_session_t session;
-	struct timespec start, stop;
-	static unsigned long taken = 0;
 	static unsigned long measurement;
+	const gnutls_datum_t key = { (void *) "DEADBEEF", 8 };
 	const char *err;
+	unsigned j;

-	global_init();
+	gnutls_global_init();

 	setpriority(PRIO_PROCESS, getpid(), -15);

-	memset(text, 0, text_size);
+	memset(text, test->fill, text_size);

 #ifdef DEBUG
 	gnutls_global_set_log_function(client_log_func);
 	gnutls_global_set_log_level(6);
 #endif

-	gnutls_certificate_allocate_credentials(&x509_cred);
-
-#ifdef REHANDSHAKE
-      restart:
-#endif
+	gnutls_psk_allocate_client_credentials(&pskcred);
+	gnutls_psk_set_client_credentials(pskcred, "test", &key,
+					  GNUTLS_PSK_KEY_HEX);

 	/* Initialize TLS session
 	 */
-	gnutls_init(&session, GNUTLS_CLIENT);
+	assert(gnutls_init(&session, GNUTLS_CLIENT) >= 0);
 	gnutls_session_set_ptr(session, test);
 	cli_session = session;

@@ -300,7 +203,7 @@ client(int fd, const char *prio, unsigned int text_size,

 	/* put the anonymous credentials to the current session
 	 */
-	gnutls_credentials_set(session, GNUTLS_CRD_CERTIFICATE, x509_cred);
+	gnutls_credentials_set(session, GNUTLS_CRD_PSK, pskcred);
 	gnutls_transport_set_int(session, fd);

 	/* Perform the TLS handshake
@@ -324,111 +227,84 @@ client(int fd, const char *prio, unsigned int text_size,

 	gnutls_transport_set_push_function(session, push_crippled);

-#ifndef REHANDSHAKE
-      restart:
-#endif
+ restart:
 	do {
 		ret = gnutls_record_send(session, text, sizeof(text));
 	} while (ret == GNUTLS_E_AGAIN || ret == GNUTLS_E_INTERRUPTED);
 	/* measure peer's processing time */
-	clock_gettime(CLOCK_PROCESS_CPUTIME_ID, &start);

-#define TLS_RECV
-#ifdef TLS_RECV
 	do {
 		ret = gnutls_record_recv(session, buffer, sizeof(buffer));
 	} while (ret < 0
 		 && (ret == GNUTLS_E_AGAIN
 		     || ret == GNUTLS_E_INTERRUPTED));
-#else
-	do {
-		ret = recv(fd, buffer, sizeof(buffer), 0);
-	} while (ret == -1 && errno == EAGAIN);
-#endif

-	if (taken < MAX_MEASUREMENTS(test->npoints) && ret > 0) {
-		clock_gettime(CLOCK_PROCESS_CPUTIME_ID, &stop);
-		taken++;
-		measurement = timespec_sub_ns(&stop, &start);
-		prev_point_ptr->measurements[prev_point_ptr->midx] =
-		    measurement;
+	if (ret > 0) {
+		struct point_st *point_ptr = NULL;

-/*fprintf(stderr, "(%u,%u): %lu\n", (unsigned) prev_point_ptr->byte1,
- (unsigned) prev_point_ptr->byte2, measurements[taken]);*/
-		memcpy(&measurement, buffer, sizeof(measurement));
-		prev_point_ptr->smeasurements[prev_point_ptr->midx] =
-		    measurement;
-		prev_point_ptr->midx++;
+		assert(ret == sizeof(measurement));

-		/* read server's measurement */
+		point_ptr = &test->points[point_idx];
+		point_ptr->taken++;
+
+		if (point_idx == 0) {
+			printf("%s: measurement: %u / %d\r", test->name, (unsigned)point_ptr->taken+1, MAX_PER_POINT+WARM_UP);
+		}
+
+		if (point_idx == 0 && point_ptr->midx+1 >= MAX_PER_POINT) {
+			goto finish;
+		}
+
+		if (point_ptr->taken >= WARM_UP) {
+			memcpy(&measurement, buffer, sizeof(measurement));
+			if (point_ptr->midx < MAX_PER_POINT) {
+				point_ptr->smeasurements[point_ptr->midx] =
+				    measurement;
+				point_ptr->midx++;
+				point_idx++;
+
+				if (point_idx >= test->npoints)
+					point_idx = 0;
+			}
+		}

-#ifdef REHANDSHAKE
-		gnutls_deinit(session);
-#endif
 		goto restart;
+	} else {
+		abort();
 	}
-#ifndef TLS_RECV
-	else if (ret < 0) {
-		fprintf(stderr, "Error in recv()\n");
-		exit(1);
-	}
-#endif
+
+finish:
+	fprintf(stderr, "\ntest completed\n");

 	gnutls_transport_set_push_function(session, push);

 	gnutls_bye(session, GNUTLS_SHUT_WR);

 	{
-		double avg2, med, savg, smed;
 		unsigned i;
 		FILE *fp = NULL;

-		if (test->file)
-			fp = fopen(test->file, "w");
-
-		if (fp)		/* point, avg, median */
-			fprintf(fp,
-				"Delta,TimeAvg,TimeMedian,ServerAvg,ServerMedian\n");
+		fp = fopen(test->file, "w");
+		assert(fp != NULL);

+		fprintf(fp, "Delta,");
+		for (j = 0; j < MAX_PER_POINT; j++) {
+			fprintf(fp, "measurement-%u%s", j, j!=(MAX_PER_POINT-1)?",":"");
+		}
+		fprintf(fp, "\n");
 		for (i = 0; i < test->npoints; i++) {
-			qsort(test->points[i].measurements,
-			      test->points[i].midx,
-			      sizeof(test->points[i].measurements[0]),
-			      compar);
-
-			qsort(test->points[i].smeasurements,
-			      test->points[i].midx,
-			      sizeof(test->points[i].smeasurements[0]),
-			      compar);
-
-			avg2 =
-			    calc_avg(test->points[i].measurements,
-				     test->points[i].midx);
-			/*var = calc_var( test->points[i].measurements, test->points[i].midx, avg2); */
-			med =
-			    calc_median(test->points[i].measurements,
-					test->points[i].midx);
-
-			savg =
-			    calc_avg(test->points[i].smeasurements,
-				     test->points[i].midx);
-			/*var = calc_var( test->points[i].measurements, test->points[i].midx, avg2); */
-			smed =
-			    calc_median(test->points[i].smeasurements,
-					test->points[i].midx);
-			/*min = calc_min( test->points[i].measurements, test->points[i].midx); */
-
-			if (fp)	/* point, avg, median */
-				fprintf(fp, "%u,%.2lf,%.2lf,%.2lf,%.2lf\n",
-					(unsigned) test->points[i].byte1,
-					avg2, med, savg, smed);
-
-			/*printf("(%u) Avg: %.3f nanosec, Median: %.3f, Variance: %.3f\n", (unsigned)test->points[i].byte1,
-			   avg2, med, var); */
+			fprintf(fp, "%u,", (unsigned)test->points[i].byte1);
+			for (j = 0; j < MAX_PER_POINT; j++) {
+				fprintf(fp, "%u%s",
+					(unsigned) test->points[i].smeasurements[j],
+					(j!=MAX_PER_POINT-1)?",":"");
+
+			}
+			fprintf(fp, "\n");
 		}
+		printf("\n");

-		if (fp)
-			fclose(fp);
+		fclose(fp);
 	}

 	if (test->desc)
@@ -438,46 +314,51 @@ client(int fd, const char *prio, unsigned int text_size,

 	gnutls_deinit(session);

-	gnutls_certificate_free_credentials(x509_cred);
+	gnutls_psk_free_client_credentials(pskcred);

 	gnutls_global_deinit();
 }

-
+static int
+pskfunc(gnutls_session_t session, const char *username,
+	gnutls_datum_t * key)
+{
+	key->data = gnutls_malloc(4);
+	key->data[0] = 0xDE;
+	key->data[1] = 0xAD;
+	key->data[2] = 0xBE;
+	key->data[3] = 0xEF;
+	key->size = 4;
+	return 0;
+}

 static void server(int fd, const char *prio)
 {
 	int ret;
 	char buffer[MAX_BUF + 1];
 	gnutls_session_t session;
-	gnutls_certificate_credentials_t x509_cred;
+	gnutls_psk_server_credentials_t server_pskcred;
 	const char *err;
+#ifndef USE_RDTSC
 	struct timespec start, stop;
+#else
+	uint64_t c1, c2;
+	unsigned int i1;
+#endif
 	static unsigned long measurement;

 	setpriority(PRIO_PROCESS, getpid(), -15);

-	/* this must be called once in the program
-	 */
-	global_init();
+	gnutls_global_init();
 	memset(buffer, 0, sizeof(buffer));

 #ifdef DEBUG
 	gnutls_global_set_log_function(server_log_func);
 	gnutls_global_set_log_level(6);
 #endif
-	assert(gnutls_certificate_allocate_credentials(&x509_cred)>=0);
-	ret =
-	    gnutls_certificate_set_x509_key_mem(x509_cred, &server_cert,
-						&server_key,
-						GNUTLS_X509_FMT_PEM);
-	if (ret < 0) {
-		fprintf(stderr, "Could not set certificate: %s\n", gnutls_strerror(ret));
-		return;
-	}
-#ifdef REHANDSHAKE
-      restart:
-#endif
+	assert(gnutls_psk_allocate_server_credentials(&server_pskcred)>=0);
+	gnutls_psk_set_server_credentials_function(server_pskcred,
+						   pskfunc);
 	assert(gnutls_init(&session, GNUTLS_SERVER)>=0);

 	/* avoid calling all the priority functions, since the defaults
@@ -489,7 +370,7 @@ static void server(int fd, const char *prio)
 		exit(1);
 	}

-	gnutls_credentials_set(session, GNUTLS_CRD_CERTIFICATE, x509_cred);
+	gnutls_credentials_set(session, GNUTLS_CRD_PSK, server_pskcred);
 	gnutls_transport_set_int(session, fd);

 	do {
@@ -511,21 +392,37 @@ static void server(int fd, const char *prio)
 		}
 		goto finish;
 	}
-#ifndef REHANDSHAKE
-      restart:
+#ifdef TEST_ETM
+	assert(gnutls_session_etm_status(session)!=0);
+#else
+	assert(gnutls_session_etm_status(session)==0);
 #endif

-	clock_gettime(CLOCK_PROCESS_CPUTIME_ID, &start);
+ restart:
+	do {
+		ret = recv(fd, buffer, 1, MSG_PEEK);
+	} while (ret == -1 && errno == EAGAIN);
+
+#ifdef USE_RDTSC
+	c1 = __rdtscp(&i1);
+#else
+	clock_gettime(CLOCK_TO_USE, &start);
+#endif

 	do {
 		ret = gnutls_record_recv(session, buffer, sizeof(buffer));
 	} while (ret == GNUTLS_E_AGAIN || ret == GNUTLS_E_INTERRUPTED);

-	clock_gettime(CLOCK_PROCESS_CPUTIME_ID, &stop);
+#ifdef USE_RDTSC
+	c2 = __rdtscp(&i1);
+	measurement = c2 - c1;
+#else
+	clock_gettime(CLOCK_TO_USE, &stop);
+	measurement = timespec_sub_ns(&stop, &start);
+#endif

 	if (ret == GNUTLS_E_DECRYPTION_FAILED) {
 		gnutls_session_force_valid(session);
-		measurement = timespec_sub_ns(&stop, &start);
 		do {
 			ret =
 			    gnutls_record_send(session, &measurement,
@@ -534,13 +431,14 @@ static void server(int fd, const char *prio)
 		} while (ret == GNUTLS_E_AGAIN
 			 || ret == GNUTLS_E_INTERRUPTED);

-#ifdef REHANDSHAKE
-		gnutls_deinit(session);
-#endif
-		if (ret >= 0)
+		if (ret >= 0) {
 			goto restart;
-	} else if (ret < 0)
-		fprintf(stderr, "err: %s\n", gnutls_strerror(ret));
+		}
+	} else if (ret > 0) {
+		goto restart;
+	}
+
+	assert(ret <= 0);

 	/* do not wait for the peer to close the connection.
 	 */
@@ -550,7 +448,7 @@ static void server(int fd, const char *prio)
 	close(fd);
 	gnutls_deinit(session);

-	gnutls_certificate_free_credentials(x509_cred);
+	gnutls_psk_free_server_credentials(server_pskcred);

 	gnutls_global_deinit();
 }
@@ -602,11 +500,9 @@ static void ch_handler(int sig)
 	return;
 }

-static struct point_st all_points[256];
-static struct point_st all_points_one[256];
-
-
-#define NPOINTS(points) (sizeof(points)/sizeof(points[0]))
+#define NPOINTS 256
+static struct point_st all_points[NPOINTS];
+static struct point_st all_points_one[NPOINTS];

 /* Test that outputs a graph of the timings
  * when manipulating the last record byte (pad)
@@ -614,10 +510,11 @@ static struct point_st all_points_one[256];
  */
 static struct test_st test_sha1 = {
 	.points = all_points,
-	.npoints = NPOINTS(all_points),
+	.npoints = NPOINTS,
 	.text_size = 18 * 16,
 	.name = "sha1",
 	.file = "out-sha1.txt",
+	.fill = 0x00,
 	.desc = NULL
 };

@@ -627,10 +524,31 @@ static struct test_st test_sha1 = {
  */
 static struct test_st test_sha256 = {
 	.points = all_points,
-	.npoints = NPOINTS(all_points),
+	.npoints = NPOINTS,
 	.text_size = 17 * 16,
 	.name = "sha256",
 	.file = "out-sha256.txt",
+	.fill = 0x00,
+	.desc = NULL
+};
+
+static struct test_st test_sha256_new = {
+	.points = all_points,
+	.npoints = NPOINTS,
+	.text_size = 1024 * 16,
+	.name = "sha256-new",
+	.file = "out-sha256-new.txt",
+	.fill = 0xff,
+	.desc = NULL
+};
+
+static struct test_st test_sha384 = {
+	.points = all_points,
+	.npoints = NPOINTS,
+	.text_size = 33 * 16,
+	.name = "sha384",
+	.file = "out-sha384.txt",
+	.fill = 0x00,
 	.desc = NULL
 };

@@ -640,10 +558,11 @@ static struct test_st test_sha256 = {
  */
 static struct test_st test_sha1_short = {
 	.points = all_points,
-	.npoints = NPOINTS(all_points),
+	.npoints = NPOINTS,
 	.text_size = 16 * 2,
 	.name = "sha1-short",
 	.file = "out-sha1-short.txt",
+	.fill = 0x00,
 	.desc = NULL
 };

@@ -653,10 +572,21 @@ static struct test_st test_sha1_short = {
  */
 static struct test_st test_sha256_short = {
 	.points = all_points,
-	.npoints = NPOINTS(all_points),
+	.npoints = NPOINTS,
 	.text_size = 16 * 2,
 	.name = "sha256-short",
 	.file = "out-sha256-short.txt",
+	.fill = 0x00,
+	.desc = NULL
+};
+
+static struct test_st test_sha384_short = {
+	.points = all_points,
+	.npoints = NPOINTS,
+	.text_size = 16 * 2,
+	.name = "sha384-short",
+	.file = "out-sha384-short.txt",
+	.fill = 0x00,
 	.desc = NULL
 };

@@ -669,10 +599,11 @@ static struct test_st test_sha256_short = {
  */
 static struct test_st test_sha1_one = {
 	.points = all_points_one,
-	.npoints = NPOINTS(all_points_one),
+	.npoints = NPOINTS,
 	.text_size = 16 * 2,
 	.name = "sha1-one",
 	.file = "out-sha1-one.txt",
+	.fill = 0x00,
 	.desc = NULL
 };

@@ -682,6 +613,10 @@ int main(int argc, char **argv)
 	struct test_st *test;
 	const char *hash;
 	char prio[512];
+	struct timespec res;
+
+	assert(clock_getres(CLOCK_TO_USE, &res) >= 0);
+	assert(res.tv_nsec < 100);

 	signal(SIGCHLD, ch_handler);
 	signal(SIGPIPE, SIG_IGN);
@@ -690,15 +625,24 @@ int main(int argc, char **argv)
 		if (strcmp(argv[1], "sha1") == 0) {
 			test = &test_sha1;
 			hash = "SHA1";
-		} else if (strncmp(argv[1], "sha2", 4) == 0) {
-			test = &test_sha256;
-			hash = "SHA256";
 		} else if (strcmp(argv[1], "sha1-short") == 0) {
 			test = &test_sha1_short;
 			hash = "SHA1";
 		} else if (strcmp(argv[1], "sha256-short") == 0) {
 			test = &test_sha256_short;
 			hash = "SHA256";
+		} else if (strcmp(argv[1], "sha256-new") == 0) {
+			test = &test_sha256_new;
+			hash = "SHA256";
+		} else if (strcmp(argv[1], "sha256") == 0) {
+			test = &test_sha256;
+			hash = "SHA256";
+		} else if (strcmp(argv[1], "sha384-short") == 0) {
+			test = &test_sha384_short;
+			hash = "SHA384";
+		} else if (strcmp(argv[1], "sha384") == 0) {
+			test = &test_sha384;
+			hash = "SHA384";
 		} else if (strcmp(argv[1], "sha1-one") == 0) {
 			test = &test_sha1_one;
 			hash = "SHA1";
@@ -715,20 +659,16 @@ int main(int argc, char **argv)
 	memset(&all_points, 0, sizeof(all_points));
 	for (i = 0; i < 256; i++) {
 		all_points[i].byte1 = i;
-		all_points[i].measurements =
-		    malloc(MAX_PER_POINT *
-			   sizeof(all_points[i].measurements[0]));
+		all_points[i].byte2 = 0;
 		all_points[i].smeasurements =
 		    malloc(MAX_PER_POINT *
-			   sizeof(all_points[i].measurements[0]));
+			   sizeof(all_points[i].smeasurements[0]));
 	}

 	memset(&all_points_one, 0, sizeof(all_points_one));
 	for (i = 0; i < 256; i++) {
 		all_points_one[i].byte1 = i;
 		all_points_one[i].byte2 = 1;
-		all_points_one[i].measurements =
-		    all_points[i].measurements;
 		all_points_one[i].smeasurements =
 		    all_points[i].smeasurements;
 	}
@@ -736,7 +676,11 @@ int main(int argc, char **argv)

 	remove(test->file);
 	snprintf(prio, sizeof(prio),
-		 "NONE:+COMP-NULL:+AES-128-CBC:+%s:+RSA:%%COMPAT:+VERS-TLS1.2:+VERS-TLS1.1:+SIGN-ALL",
+#ifdef TEST_ETM
+		 "NONE:+COMP-NULL:+AES-128-CBC:+AES-256-CBC:+%s:+PSK:+VERS-TLS1.2:+VERS-TLS1.1:+SIGN-ALL:+CURVE-ALL",
+#else
+		 "NONE:+COMP-NULL:+AES-128-CBC:+AES-256-CBC:+%s:+PSK:%%NO_ETM:+VERS-TLS1.2:+VERS-TLS1.1:+SIGN-ALL:+CURVE-ALL",
+#endif
 		 hash);

 	printf("\nAES-%s (calculating different padding timings)\n", hash);
@@ -744,57 +688,6 @@ int main(int argc, char **argv)

 	signal(SIGCHLD, SIG_IGN);

-#ifdef PDF
-	snprintf(prio, sizeof(prio),
-		 "R -e 'pdf(file=\"%s-timings-avg.pdf\");z=read.csv(\"%s\");"
-		 "plot(z$Delta,z$TimeAvg,xlab=\"Delta\",ylab=\"Average timings (ns)\");"
-		 "dev.off();'" test->name, test->file);
-	system(prio);
-
-	snprintf(prio, sizeof(prio),
-		 "R -e 'pdf(file=\"%s-timings-med.pdf\");z=read.csv(\"%s\");"
-		 "plot(z$Delta,z$TimeMedian,xlab=\"Delta\",ylab=\"Median timings (ns)\");"
-		 "dev.off();'"; test->name, test->file);
-	system(prio);
-
-	snprintf(prio, sizeof(prio),
-		 "R -e 'pdf(file=\"%s-server-timings-avg.pdf\");z=read.csv(\"%s\");"
-		 "plot(z$Delta,z$ServerAvg,xlab=\"Delta\",ylab=\"Average timings (ns)\");"
-		 "dev.off();'" test->name, test->file);
-	system(prio);
-
-	snprintf(prio, sizeof(prio),
-		 "R -e 'pdf(file=\"%s-server-timings-med.pdf\");z=read.csv(\"%s\");"
-		 "plot(z$Delta,z$ServerMedian,xlab=\"Delta\",ylab=\"Median timings (ns)\");"
-		 "dev.off();'"; test->name, test->file);
-	system(prio);
-#else
-	snprintf(prio, sizeof(prio),
-		 "R -e 'z=read.csv(\"%s\");png(filename = \"%s-timings-avg.png\",width=1024,height=1024,units=\"px\","
-		 "bg=\"white\");plot(z$Delta,z$TimeAvg,xlab=\"Delta\",ylab=\"Average timings (ns)\");dev.off();'",
-		 test->file, test->name);
-	system(prio);
-
-	snprintf(prio, sizeof(prio),
-		 "R -e 'z=read.csv(\"%s\");"
-		 "png(filename = \"%s-timings-med.png\",width=1024,height=1024,units=\"px\","
-		 "bg=\"white\");plot(z$Delta,z$TimeMedian,xlab=\"Delta\",ylab=\"Median timings (ns)\");dev.off();'",
-		 test->file, test->name);
-	system(prio);
-
-	snprintf(prio, sizeof(prio),
-		 "R -e 'z=read.csv(\"%s\");png(filename = \"%s-server-timings-avg.png\",width=1024,height=1024,units=\"px\","
-		 "bg=\"white\");plot(z$Delta,z$ServerAvg,xlab=\"Delta\",ylab=\"Average timings (ns)\");dev.off();'",
-		 test->file, test->name);
-	system(prio);
-
-	snprintf(prio, sizeof(prio),
-		 "R -e 'z=read.csv(\"%s\");"
-		 "png(filename = \"%s-server-timings-med.png\",width=1024,height=1024,units=\"px\","
-		 "bg=\"white\");plot(z$Delta,z$ServerMedian,xlab=\"Delta\",ylab=\"Median timings (ns)\");dev.off();'",
-		 test->file, test->name);
-	system(prio);
-#endif
 	return 0;
 }

diff --git a/tests/suite/tls-fuzzer/tls-fuzzer-nocert.sh b/tests/suite/tls-fuzzer/tls-fuzzer-nocert.sh
index 62d75344f71e5c909f741e03e5ac283aa1c90638..b4b7c10883f78c9a322054e6937efa28f3729b2b 100755
--- a/tests/suite/tls-fuzzer/tls-fuzzer-nocert.sh
+++ b/tests/suite/tls-fuzzer/tls-fuzzer-nocert.sh
@@ -49,10 +49,10 @@ wait_for_free_port $PORT

 retval=0

-PRIORITY="NORMAL:%VERIFY_ALLOW_SIGN_WITH_SHA1:+ARCFOUR-128:+3DES-CBC:+DHE-DSS:+SIGN-DSA-SHA256:+SIGN-DSA-SHA1:-CURVE-SECP192R1:+VERS-SSL3.0"
+PRIORITY="NORMAL:%VERIFY_ALLOW_SIGN_WITH_SHA1:+ARCFOUR-128:+3DES-CBC:+DHE-DSS:+SIGN-DSA-SHA256:+SIGN-DSA-SHA1:-CURVE-SECP192R1:+VERS-SSL3.0:+SHA256"
 ${CLI} --list --priority "${PRIORITY}" >/dev/null 2>&1
 if test $? != 0;then
-	PRIORITY="NORMAL:%VERIFY_ALLOW_SIGN_WITH_SHA1:+ARCFOUR-128:+3DES-CBC:+DHE-DSS:+SIGN-DSA-SHA256:+SIGN-DSA-SHA1:+VERS-SSL3.0"
+	PRIORITY="NORMAL:%VERIFY_ALLOW_SIGN_WITH_SHA1:+ARCFOUR-128:+3DES-CBC:+DHE-DSS:+SIGN-DSA-SHA256:+SIGN-DSA-SHA1:+VERS-SSL3.0:+SHA256"
 fi

 TLS_PY=./tlslite-ng/scripts/tls.py
diff --git a/tests/tls-force-etm.c b/tests/tls-force-etm.c
new file mode 100644
index 0000000000000000000000000000000000000000..1cc42ec5ec5ceede568d2cb4f3ea2852d09cd547
--- /dev/null
+++ b/tests/tls-force-etm.c
@@ -0,0 +1,396 @@
+/*
+ * Copyright (C) 2015-2018 Red Hat, Inc.
+ *
+ * Author: Nikos Mavrogiannopoulos
+ *
+ * This file is part of GnuTLS.
+ *
+ * GnuTLS is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * GnuTLS is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>
+ */
+
+#ifdef HAVE_CONFIG_H
+#include <config.h>
+#endif
+
+#include <stdio.h>
+#include <stdlib.h>
+
+#if defined(_WIN32)
+
+int main()
+{
+	exit(77);
+}
+
+#else
+
+#include <string.h>
+#include <sys/types.h>
+#include <netinet/in.h>
+#include <sys/socket.h>
+#include <sys/wait.h>
+#include <arpa/inet.h>
+#include <unistd.h>
+#include <gnutls/gnutls.h>
+#include <gnutls/dtls.h>
+#include <signal.h>
+#include <assert.h>
+
+#include "utils.h"
+#include "cert-common.h"
+
+/* This program tests whether forced EtM is negotiated as expected.
+ */
+
+static void server_log_func(int level, const char *str)
+{
+	fprintf(stderr, "server|<%d>| %s", level, str);
+}
+
+static void client_log_func(int level, const char *str)
+{
+	fprintf(stderr, "client|<%d>| %s", level, str);
+}
+
+#define MAX_BUF 1024
+
+static void client(int fd, const char *prio, unsigned etm, int eret)
+{
+	int ret;
+	char buffer[MAX_BUF + 1];
+	gnutls_anon_client_credentials_t anoncred;
+	gnutls_certificate_credentials_t x509_cred;
+	gnutls_session_t session;
+	/* Need to enable anonymous KX specifically. */
+
+	global_init();
+
+	if (debug) {
+		gnutls_global_set_log_function(client_log_func);
+		gnutls_global_set_log_level(7);
+	}
+
+	gnutls_anon_allocate_client_credentials(&anoncred);
+	gnutls_certificate_allocate_credentials(&x509_cred);
+
+	assert(gnutls_init(&session, GNUTLS_CLIENT)>=0);
+	gnutls_handshake_set_timeout(session, 20 * 1000);
+
+	/* Use default priorities */
+	assert(gnutls_priority_set_direct(session, prio, NULL)>=0);
+
+	/* put the anonymous credentials to the current session
+	 */
+	gnutls_credentials_set(session, GNUTLS_CRD_ANON, anoncred);
+	gnutls_credentials_set(session, GNUTLS_CRD_CERTIFICATE, x509_cred);
+
+	gnutls_transport_set_int(session, fd);
+
+	/* Perform the TLS handshake
+	 */
+	do {
+		ret = gnutls_handshake(session);
+	}
+	while (ret < 0 && gnutls_error_is_fatal(ret) == 0);
+
+	if (eret < 0) {
+		if (eret != ret) {
+			fail("client: Handshake failed with unexpected error: %s\n", gnutls_strerror(ret));
+		}
+		goto end;
+	}
+
+	if (ret < 0) {
+		fail("client: Handshake failed: %s\n", gnutls_strerror(ret));
+	} else {
+		if (debug)
+			success("client: Handshake was completed\n");
+	}
+
+	if (debug)
+		success("client: TLS version is: %s\n",
+			gnutls_protocol_get_name
+			(gnutls_protocol_get_version(session)));
+
+	if (etm != 0 && gnutls_session_etm_status(session) == 0) {
+		fail("client: EtM was not negotiated with %s!\n", prio);
+		exit(1);
+	} else if (etm == 0 && gnutls_session_etm_status(session) != 0) {
+		fail("client: EtM was negotiated with %s!\n", prio);
+		exit(1);
+	}
+
+	if (etm != 0 && ((gnutls_session_get_flags(session) & GNUTLS_SFLAGS_ETM) == 0)) {
+		fail("client: EtM was not negotiated with %s!\n", prio);
+		exit(1);
+	} else if (etm == 0 && ((gnutls_session_get_flags(session) & GNUTLS_SFLAGS_ETM) != 0)) {
+		fail("client: EtM was negotiated with %s!\n", prio);
+		exit(1);
+	}
+
+	do {
+		do {
+			ret = gnutls_record_recv(session, buffer, MAX_BUF);
+		} while (ret == GNUTLS_E_AGAIN
+			 || ret == GNUTLS_E_INTERRUPTED);
+	} while (ret > 0);
+
+	if (ret == 0) {
+		if (debug)
+			success
+			    ("client: Peer has closed the TLS connection\n");
+		goto end;
+	} else if (ret < 0) {
+		if (ret != 0) {
+			fail("client: Error: %s\n", gnutls_strerror(ret));
+			exit(1);
+		}
+	}
+
+	gnutls_bye(session, GNUTLS_SHUT_WR);
+
+      end:
+
+	close(fd);
+
+	gnutls_deinit(session);
+
+	gnutls_anon_free_client_credentials(anoncred);
+	gnutls_certificate_free_credentials(x509_cred);
+
+	gnutls_global_deinit();
+}
+
+
+static void server(int fd, const char *prio, unsigned etm, int eret)
+{
+	int ret;
+	char buffer[MAX_BUF + 1];
+	gnutls_session_t session;
+	gnutls_anon_server_credentials_t anoncred;
+	gnutls_certificate_credentials_t x509_cred;
+	unsigned to_send = sizeof(buffer)/4;
+
+	/* this must be called once in the program
+	 */
+	global_init();
+	memset(buffer, 0, sizeof(buffer));
+
+	if (debug) {
+		gnutls_global_set_log_function(server_log_func);
+		gnutls_global_set_log_level(4711);
+	}
+
+	gnutls_certificate_allocate_credentials(&x509_cred);
+	gnutls_certificate_set_x509_key_mem(x509_cred, &server_cert,
+					    &server_key,
+					    GNUTLS_X509_FMT_PEM);
+
+	gnutls_anon_allocate_server_credentials(&anoncred);
+
+	assert(gnutls_init(&session, GNUTLS_SERVER)>=0);
+	gnutls_handshake_set_timeout(session, 20 * 1000);
+
+	/* avoid calling all the priority functions, since the defaults
+	 * are adequate.
+	 */
+	assert(gnutls_priority_set_direct(session, prio, NULL) >= 0);
+
+	gnutls_credentials_set(session, GNUTLS_CRD_ANON, anoncred);
+	gnutls_credentials_set(session, GNUTLS_CRD_CERTIFICATE, x509_cred);
+
+	gnutls_transport_set_int(session, fd);
+
+	do {
+		ret = gnutls_handshake(session);
+	} while (ret < 0 && gnutls_error_is_fatal(ret) == 0);
+
+	if (eret < 0) {
+		if (eret != -1 && eret != ret) {
+			fail("server: Handshake failed with unexpected error: %s\n", gnutls_strerror(ret));
+		}
+		goto end;
+	}
+
+	if (ret < 0) {
+		close(fd);
+		gnutls_deinit(session);
+		fail("server: Handshake has failed (%s)\n\n",
+		     gnutls_strerror(ret));
+	}
+
+	if (etm != 0 && gnutls_session_etm_status(session) == 0) {
+		fail("server: EtM was not negotiated with %s!\n", prio);
+		exit(1);
+	} else if (etm == 0 && gnutls_session_etm_status(session) != 0) {
+		fail("server: EtM was negotiated with %s!\n", prio);
+		exit(1);
+	}
+
+	if (etm != 0 && ((gnutls_session_get_flags(session) & GNUTLS_SFLAGS_ETM) == 0)) {
+		fail("server: EtM was not negotiated with %s!\n", prio);
+		exit(1);
+	} else if (etm == 0 && ((gnutls_session_get_flags(session) & GNUTLS_SFLAGS_ETM) != 0)) {
+		fail("server: EtM was negotiated with %s!\n", prio);
+		exit(1);
+	}
+
+	if (debug)
+		success("server: Handshake was completed\n");
+
+	if (debug)
+		success("server: TLS version is: %s\n",
+			gnutls_protocol_get_name
+			(gnutls_protocol_get_version(session)));
+
+	do {
+		do {
+			ret =
+			    gnutls_record_send(session, buffer,
+						sizeof(buffer));
+		} while (ret == GNUTLS_E_AGAIN
+			 || ret == GNUTLS_E_INTERRUPTED);
+
+		if (ret < 0) {
+			fail("Error sending %d byte packet: %s\n", to_send,
+			     gnutls_strerror(ret));
+		}
+		to_send++;
+	}
+	while (to_send < 64);
+
+	to_send = -1;
+	/* do not wait for the peer to close the connection.
+	 */
+	gnutls_bye(session, GNUTLS_SHUT_WR);
+ end:
+	close(fd);
+	gnutls_deinit(session);
+
+	gnutls_anon_free_server_credentials(anoncred);
+	gnutls_certificate_free_credentials(x509_cred);
+
+	gnutls_global_deinit();
+
+	if (debug)
+		success("server: finished\n");
+}
+
+struct test_st {
+	const char *name;
+	const char *server_prio;
+	const char *client_prio;
+	unsigned etm;
+	int client_err;
+	int server_err;
+};
+
+static void start(struct test_st *test)
+{
+	int fd[2];
+	int ret, status;
+	pid_t child;
+
+
+	success("trying: %s\n", test->name);
+	ret = socketpair(AF_UNIX, SOCK_STREAM, 0, fd);
+	if (ret < 0) {
+		perror("socketpair");
+		exit(1);
+	}
+
+	child = fork();
+	if (child < 0) {
+		perror("fork");
+		fail("fork");
+		exit(1);
+	}
+
+	if (child) {
+		/* parent */
+		close(fd[1]);
+		server(fd[0], test->server_prio, test->etm, test->server_err);
+		wait(&status);
+		check_wait_status(status);
+	} else {
+		close(fd[0]);
+		client(fd[1], test->client_prio, test->etm, test->client_err);
+		exit(0);
+	}
+}
+
+#define AES_CBC "NONE:+VERS-TLS1.0:-CIPHER-ALL:+AES-128-CBC:+SHA1:+SIGN-ALL:+COMP-ALL:+ANON-ECDH:+CURVE-ALL"
+#define AES_CBC_SHA256 "NONE:+VERS-TLS1.2:-CIPHER-ALL:+RSA:+AES-128-CBC:+AES-256-CBC:+SHA256:+SIGN-ALL:+COMP-ALL:+ANON-ECDH:+CURVE-ALL"
+#define AES_GCM "NONE:+VERS-TLS1.2:-CIPHER-ALL:+RSA:+AES-128-GCM:+MAC-ALL:+SIGN-ALL:+COMP-ALL:+ANON-ECDH:+CURVE-ALL"
+
+#define AES_CBC_TLS12 "NONE:+VERS-TLS1.2:-CIPHER-ALL:+RSA:+AES-128-CBC:+MAC-ALL:+SIGN-ALL:+COMP-ALL:+ANON-ECDH:+CURVE-ALL"
+
+static void ch_handler(int sig)
+{
+	return;
+}
+
+static struct test_st tests[] = {
+	{
+		.name = "aes-cbc-hmac-sha1 with force etm",
+		.server_prio = AES_CBC":%FORCE_ETM",
+		.client_prio = AES_CBC":%FORCE_ETM",
+		.etm = 1
+	},
+	{
+		.name = "aes-cbc-hmac-sha256 with force etm",
+		.server_prio = AES_CBC_SHA256":%FORCE_ETM",
+		.client_prio = AES_CBC_SHA256":%FORCE_ETM",
+		.etm = 1
+	},
+	{
+		.name = "server aes-cbc-hmac-sha1 with force etm, gcm fallback",
+		.server_prio = AES_CBC_TLS12":+AES-128-GCM:%FORCE_ETM",
+		.client_prio = AES_CBC_TLS12":+AES-128-GCM:%NO_ETM",
+		.etm = 0
+	},
+	{
+		.name = "aes-gcm with force etm",
+		.server_prio = AES_GCM":%FORCE_ETM",
+		.client_prio = AES_GCM":%FORCE_ETM",
+		.etm = 0
+	},
+	{
+		.name = "server aes-cbc-hmac-sha1 with force etm failure",
+		.server_prio = AES_CBC":%FORCE_ETM",
+		.client_prio = AES_CBC":%NO_ETM",
+		.etm = 0,
+		.client_err = GNUTLS_E_PREMATURE_TERMINATION,
+		.server_err = GNUTLS_E_NO_CIPHER_SUITES
+	},
+	{
+		.name = "client aes-cbc-hmac-sha1 with force etm failure",
+		.server_prio = AES_CBC":%NO_ETM",
+		.client_prio = AES_CBC":%FORCE_ETM",
+		.etm = 0,
+		.client_err = GNUTLS_E_UNWANTED_ALGORITHM,
+		.server_err = -1
+	}
+};
+
+void doit(void)
+{
+	unsigned i;
+	signal(SIGCHLD, ch_handler);
+
+	for (i=0;i<sizeof(tests)/sizeof(tests[0]);i++) {
+		start(&tests[i]);
+	}
+}
+#endif				/* _WIN32 */
diff --git a/tests/utils.h b/tests/utils.h
index 1247402e9fd956b0bebd60b0920370559ccbd1ee..58e9aef8a22509651f1cbbe36a3eb1bcc51a3eaf 100644
--- a/tests/utils.h
+++ b/tests/utils.h
@@ -16,9 +16,8 @@
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  * General Public License for more details.
  *
- * You should have received a copy of the GNU General Public License
- * along with GnuTLS; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>
  */

 #ifndef UTILS_H